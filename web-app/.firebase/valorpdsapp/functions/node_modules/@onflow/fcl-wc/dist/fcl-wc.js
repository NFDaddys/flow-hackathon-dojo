'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var _regeneratorRuntime = require('@babel/runtime/regenerator');
var fcl = require('@onflow/fcl');
var SignClient = require('@walletconnect/sign-client');
var utilInvariant = require('@onflow/util-invariant');
var utilLogger = require('@onflow/util-logger');
var utils = require('@walletconnect/utils');
var _toConsumableArray = require('@babel/runtime/helpers/toConsumableArray');
var _typeof = require('@babel/runtime/helpers/typeof');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var QRCodeModal = require('@walletconnect/qrcode-modal');
var config = require('@onflow/config');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);
var _regeneratorRuntime__default = /*#__PURE__*/_interopDefaultLegacy(_regeneratorRuntime);
var fcl__namespace = /*#__PURE__*/_interopNamespace(fcl);
var SignClient__default = /*#__PURE__*/_interopDefaultLegacy(SignClient);
var _toConsumableArray__default = /*#__PURE__*/_interopDefaultLegacy(_toConsumableArray);
var _typeof__default = /*#__PURE__*/_interopDefaultLegacy(_typeof);
var _objectSpread__default = /*#__PURE__*/_interopDefaultLegacy(_objectSpread);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var QRCodeModal__default = /*#__PURE__*/_interopDefaultLegacy(QRCodeModal);

var CONFIGURED_NETWORK = null;
var setConfiguredNetwork = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee() {
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return config.config.get("flow.network");

          case 2:
            CONFIGURED_NETWORK = _context.sent;
            utilInvariant.invariant(CONFIGURED_NETWORK === "mainnet" || CONFIGURED_NETWORK === "testnet", "FCL Configuration value for 'flow.network' is required (testnet || mainnet)");

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function setConfiguredNetwork() {
    return _ref.apply(this, arguments);
  };
}();

var makeFlowServicesFromWallets = function makeFlowServicesFromWallets(wallets) {
  return Object.values(wallets).filter(function (w) {
    return w.app_type === "wallet";
  }).map(function (wallet) {
    var _wallet$mobile, _wallet$image_url, _wallet$metadata, _wallet$metadata$colo;

    return {
      f_type: "Service",
      f_vsn: "1.0.0",
      type: "authn",
      method: "WC/RPC",
      uid: (_wallet$mobile = wallet.mobile) === null || _wallet$mobile === void 0 ? void 0 : _wallet$mobile.universal,
      endpoint: "flow_authn",
      optIn: true,
      provider: {
        address: null,
        name: wallet.name,
        icon: (_wallet$image_url = wallet.image_url) === null || _wallet$image_url === void 0 ? void 0 : _wallet$image_url.sm,
        description: wallet.description,
        website: wallet.homepage,
        color: (_wallet$metadata = wallet.metadata) === null || _wallet$metadata === void 0 ? void 0 : (_wallet$metadata$colo = _wallet$metadata.colors) === null || _wallet$metadata$colo === void 0 ? void 0 : _wallet$metadata$colo.primary,
        supportEmail: null
      }
    };
  });
};

var fetchFlowWallets = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(projectId) {
    var wcApiWallets;
    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return fetch("https://explorer-api.walletconnect.com/v3/wallets?projectId=".concat(projectId, "&chains=flow:").concat(CONFIGURED_NETWORK, "&entries=5&page=1")).then(function (res) {
              return res.json();
            });

          case 3:
            wcApiWallets = _context2.sent;

            if (!((wcApiWallets === null || wcApiWallets === void 0 ? void 0 : wcApiWallets.count) > 0)) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", makeFlowServicesFromWallets(wcApiWallets.listings));

          case 6:
            return _context2.abrupt("return", []);

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](0);
            utilLogger.log({
              title: "".concat(_context2.t0.name, " Error fetching wallets from WalletConnect API"),
              message: _context2.t0.message,
              level: utilLogger.LEVELS.error
            });

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 9]]);
  }));

  return function fetchFlowWallets(_x) {
    return _ref2.apply(this, arguments);
  };
}();
function isAndroid() {
  return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
}
function isSmallIOS() {
  return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
}
function isLargeIOS() {
  return typeof navigator !== "undefined" && /iPad/.test(navigator.userAgent);
}
function isIOS() {
  return isSmallIOS() || isLargeIOS();
}
function isMobile() {
  return isAndroid() || isIOS();
}

var FLOW_METHODS = {
  FLOW_AUTHN: "flow_authn",
  FLOW_AUTHZ: "flow_authz",
  FLOW_USER_SIGN: "flow_user_sign"
};
var REQUEST_TYPES = {
  SESSION_REQUEST: "session_proposal",
  SIGNING_REQUEST: "signing_request"
};

var makeServicePlugin = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(client) {
    var opts,
        _args = arguments;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
            _context.next = 3;
            return makeWcServices(opts);

          case 3:
            _context.t0 = _context.sent;
            _context.t1 = {
              method: "WC/RPC",
              exec: makeExec(client, opts)
            };
            return _context.abrupt("return", {
              name: "fcl-plugin-service-walletconnect",
              f_type: "ServicePlugin",
              type: "discovery-service",
              services: _context.t0,
              serviceStrategy: _context.t1
            });

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function makeServicePlugin(_x) {
    return _ref.apply(this, arguments);
  };
}();

var makeExec = function makeExec(client, _ref2) {
  var wcRequestHook = _ref2.wcRequestHook,
      pairingModalOverride = _ref2.pairingModalOverride;
  return function (_ref3) {
    var service = _ref3.service,
        body = _ref3.body,
        opts = _ref3.opts;
    return new Promise( /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2(resolve, reject) {
        var session, pairing, windowRef, method, appLink, pairings, lastKeyIndex, _session, _pairing, _makeSessionData, _makeSessionData2, chainId, addr, address, data, result, validateAppLink, openDeepLink, makeSessionData, onResponse, onClose;

        return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                onClose = function _onClose() {
                  reject("Declined: Externally Halted");
                };

                onResponse = function _onResponse(resp) {
                  try {
                    if (_typeof__default["default"](resp) !== "object") return;

                    switch (resp.status) {
                      case "APPROVED":
                        resolve(resp.data);
                        break;

                      case "DECLINED":
                        reject("Declined: ".concat(resp.reason || "No reason supplied"));
                        break;

                      case "REDIRECT":
                        resolve(resp);
                        break;

                      default:
                        reject("Declined: No reason supplied");
                        break;
                    }
                  } catch (error) {
                    utilLogger.log({
                      title: "".concat(error.name, " \"WC/RPC onResponse error\""),
                      message: error.message,
                      level: utilLogger.LEVELS.error
                    });
                    throw error;
                  }
                };

                makeSessionData = function _makeSessionData3(session) {
                  var _Object$values$map$fl = Object.values(session.namespaces).map(function (namespace) {
                    return namespace.accounts;
                  }).flat().filter(function (account) {
                    return account.startsWith("flow:");
                  })[0].split(":"),
                      _Object$values$map$fl2 = _slicedToArray__default["default"](_Object$values$map$fl, 3),
                      namespace = _Object$values$map$fl2[0],
                      reference = _Object$values$map$fl2[1],
                      address = _Object$values$map$fl2[2];

                  var chainId = "".concat(namespace, ":").concat(reference);
                  var addr = address;
                  return [chainId, addr, address];
                };

                openDeepLink = function _openDeepLink() {
                  if (windowRef) {
                    if (appLink.startsWith("http") && !isIOS()) {
                      // Workaround for https://github.com/rainbow-me/rainbowkit/issues/524.
                      // Using 'window.open' causes issues on iOS in non-Safari browsers and
                      // WebViews where a blank tab is left behind after connecting.
                      // This is especially bad in some WebView scenarios (e.g. following a
                      // link from Twitter) where the user doesn't have any mechanism for
                      // closing the blank tab.
                      // For whatever reason, links with a target of "_blank" don't suffer
                      // from this problem, and programmatically clicking a detached link
                      // element with the same attributes also avoids the issue.
                      var link = document.createElement("a");
                      link.href = appLink;
                      link.target = "_blank";
                      link.rel = "noreferrer noopener";
                      link.click();
                    } else {
                      windowRef.location.href = appLink;
                    }
                  } else {
                    utilLogger.log({
                      title: "Problem opening deep link in new window",
                      message: "Window failed to open (was it blocked by the browser?)",
                      level: utilLogger.LEVELS.warn
                    });
                  }
                };

                validateAppLink = function _validateAppLink(_ref5) {
                  var uid = _ref5.uid;

                  if (!(uid && /^(ftp|http|https):\/\/[^ "]+$/.test(uid))) {
                    utilLogger.log({
                      title: "WalletConnect Service Warning",
                      message: "service.uid should be a valid universal link url. Found: ".concat(uid),
                      level: utilLogger.LEVELS.warn
                    });
                  }

                  return uid;
                };

                utilInvariant.invariant(client, "WalletConnect is not initialized");
                method = service.endpoint;
                appLink = validateAppLink(service);
                pairings = client.pairing.getAll({
                  active: true
                });

                if (pairings.length > 0) {
                  pairing = pairings === null || pairings === void 0 ? void 0 : pairings.find(function (p) {
                    var _p$peerMetadata;

                    return ((_p$peerMetadata = p.peerMetadata) === null || _p$peerMetadata === void 0 ? void 0 : _p$peerMetadata.url) === service.uid;
                  });
                }

                if (client.session.length > 0) {
                  lastKeyIndex = client.session.keys.length - 1;
                  session = client.session.get(client.session.keys.at(lastKeyIndex));
                }

                if (isMobile()) {
                  if (opts.windowRef) {
                    windowRef = opts.windowRef;
                  } else {
                    windowRef = window.open("", "_blank");
                  }
                }

                if (!(session == null)) {
                  _context2.next = 16;
                  break;
                }

                _context2.next = 15;
                return connectWc({
                  service: service,
                  onClose: onClose,
                  appLink: appLink,
                  windowRef: windowRef,
                  client: client,
                  method: method,
                  pairing: pairing,
                  wcRequestHook: wcRequestHook,
                  pairingModalOverride: pairingModalOverride
                });

              case 15:
                session = _context2.sent;

              case 16:
                if (wcRequestHook && wcRequestHook instanceof Function) {
                  wcRequestHook({
                    type: REQUEST_TYPES.SIGNING_REQUEST,
                    method: method,
                    service: service,
                    session: (_session = session) !== null && _session !== void 0 ? _session : null,
                    pairing: (_pairing = pairing) !== null && _pairing !== void 0 ? _pairing : null,
                    uri: null
                  });
                }

                if (isMobile() && method !== FLOW_METHODS.FLOW_AUTHN) {
                  openDeepLink();
                }

                _makeSessionData = makeSessionData(session), _makeSessionData2 = _slicedToArray__default["default"](_makeSessionData, 3), chainId = _makeSessionData2[0], addr = _makeSessionData2[1], address = _makeSessionData2[2];
                data = JSON.stringify(_objectSpread__default["default"](_objectSpread__default["default"]({}, body), {}, {
                  addr: addr,
                  address: address
                }));
                _context2.prev = 20;
                _context2.next = 23;
                return client.request({
                  topic: session.topic,
                  chainId: chainId,
                  request: {
                    method: method,
                    params: [data]
                  }
                });

              case 23:
                result = _context2.sent;
                onResponse(result);
                _context2.next = 31;
                break;

              case 27:
                _context2.prev = 27;
                _context2.t0 = _context2["catch"](20);
                utilLogger.log({
                  title: "".concat(_context2.t0.name, " Error on WalletConnect client ").concat(method, " request"),
                  message: _context2.t0.message,
                  level: utilLogger.LEVELS.error
                });
                reject("Declined: Externally Halted");

              case 31:
                _context2.prev = 31;

                if (windowRef && !windowRef.closed) {
                  windowRef.close();
                }

                return _context2.finish(31);

              case 34:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[20, 27, 31, 34]]);
      }));

      return function (_x2, _x3) {
        return _ref4.apply(this, arguments);
      };
    }());
  };
};

function connectWc(_x4) {
  return _connectWc.apply(this, arguments);
}

function _connectWc() {
  _connectWc = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee3(_ref6) {
    var service, onClose, appLink, windowRef, client, method, pairing, wcRequestHook, pairingModalOverride, requiredNamespaces, _yield$client$connect, uri, approval, _uri, queryString, url, session;

    return _regeneratorRuntime__default["default"].wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            service = _ref6.service, onClose = _ref6.onClose, appLink = _ref6.appLink, windowRef = _ref6.windowRef, client = _ref6.client, method = _ref6.method, pairing = _ref6.pairing, wcRequestHook = _ref6.wcRequestHook, pairingModalOverride = _ref6.pairingModalOverride;
            requiredNamespaces = {
              flow: {
                methods: [FLOW_METHODS.FLOW_AUTHN, FLOW_METHODS.FLOW_AUTHZ, FLOW_METHODS.FLOW_USER_SIGN],
                chains: ["flow:".concat(CONFIGURED_NETWORK)],
                events: ["chainChanged", "accountsChanged"]
              }
            };
            _context3.prev = 2;
            _context3.next = 5;
            return client.connect({
              pairingTopic: pairing === null || pairing === void 0 ? void 0 : pairing.topic,
              requiredNamespaces: requiredNamespaces
            });

          case 5:
            _yield$client$connect = _context3.sent;
            uri = _yield$client$connect.uri;
            approval = _yield$client$connect.approval;
            _uri = uri;

            if (wcRequestHook && wcRequestHook instanceof Function) {
              wcRequestHook({
                type: REQUEST_TYPES.SESSION_REQUEST,
                method: method,
                service: service,
                session: session !== null && session !== void 0 ? session : null,
                pairing: pairing !== null && pairing !== void 0 ? pairing : null,
                uri: uri !== null && uri !== void 0 ? uri : null
              });
            }

            if (!pairing) {
              utilInvariant.invariant(uri, "Cannot establish connection, WalletConnect URI is undefined");
            }

            if (isMobile()) {
              queryString = new URLSearchParams({
                uri: uri
              }).toString();
              url = pairing == null ? appLink + "?" + queryString : appLink;
              windowRef.location.href = url;
            } else if (!pairing) {
              if (!pairingModalOverride) {
                QRCodeModal__default["default"].open(uri, function () {
                  onClose();
                });
              } else {
                pairingModalOverride(uri, onClose);
              }
            }

            _context3.next = 14;
            return approval();

          case 14:
            session = _context3.sent;
            return _context3.abrupt("return", session);

          case 18:
            _context3.prev = 18;
            _context3.t0 = _context3["catch"](2);
            utilLogger.log({
              title: "".concat(_context3.t0.name, " Error establishing WalletConnect session"),
              message: "\n        ".concat(_context3.t0.message, "\n        uri: ").concat(_uri, "\n      "),
              level: utilLogger.LEVELS.error
            });
            onClose();
            throw _context3.t0;

          case 23:
            _context3.prev = 23;

            if (windowRef && !windowRef.closed) {
              windowRef.close();
            }

            QRCodeModal__default["default"].close();
            return _context3.finish(23);

          case 27:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[2, 18, 23, 27]]);
  }));
  return _connectWc.apply(this, arguments);
}

var makeBaseWalletConnectService = function makeBaseWalletConnectService(includeBaseWC) {
  return {
    f_type: "Service",
    f_vsn: "1.0.0",
    type: "authn",
    method: "WC/RPC",
    uid: "https://walletconnect.com",
    endpoint: "flow_authn",
    optIn: !includeBaseWC,
    provider: {
      address: null,
      name: "WalletConnect",
      icon: "https://avatars.githubusercontent.com/u/37784886",
      description: "WalletConnect Base Service",
      website: "https://walletconnect.com",
      color: null,
      supportEmail: null
    }
  };
};

function makeWcServices(_x5) {
  return _makeWcServices.apply(this, arguments);
}

function _makeWcServices() {
  _makeWcServices = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee4(_ref7) {
    var _yield$fetchFlowWalle;

    var projectId, includeBaseWC, wallets, wcBaseService, flowWcWalletServices, injectedWalletServices;
    return _regeneratorRuntime__default["default"].wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            projectId = _ref7.projectId, includeBaseWC = _ref7.includeBaseWC, wallets = _ref7.wallets;
            wcBaseService = makeBaseWalletConnectService(includeBaseWC);
            _context4.next = 4;
            return fetchFlowWallets(projectId);

          case 4:
            _context4.t1 = _yield$fetchFlowWalle = _context4.sent;
            _context4.t0 = _context4.t1 !== null;

            if (!_context4.t0) {
              _context4.next = 8;
              break;
            }

            _context4.t0 = _yield$fetchFlowWalle !== void 0;

          case 8:
            if (!_context4.t0) {
              _context4.next = 12;
              break;
            }

            _context4.t2 = _yield$fetchFlowWalle;
            _context4.next = 13;
            break;

          case 12:
            _context4.t2 = [];

          case 13:
            flowWcWalletServices = _context4.t2;
            injectedWalletServices = CONFIGURED_NETWORK === "testnet" ? wallets : [];
            return _context4.abrupt("return", [wcBaseService].concat(_toConsumableArray__default["default"](flowWcWalletServices), _toConsumableArray__default["default"](injectedWalletServices)));

          case 16:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _makeWcServices.apply(this, arguments);
}

var DEFAULT_RELAY_URL = "wss://relay.walletconnect.com";
var DEFAULT_LOGGER = "debug";
var client = null;

var initClient = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee(_ref) {
    var projectId, metadata;
    return _regeneratorRuntime__default["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            projectId = _ref.projectId, metadata = _ref.metadata;
            utilInvariant.invariant(projectId != null, "FCL Wallet Connect Error: WalletConnect projectId is required");
            _context.prev = 2;
            _context.next = 5;
            return SignClient__default["default"].init({
              logger: DEFAULT_LOGGER,
              relayUrl: DEFAULT_RELAY_URL,
              projectId: projectId,
              metadata: metadata
            });

          case 5:
            client = _context.sent;
            return _context.abrupt("return", client);

          case 9:
            _context.prev = 9;
            _context.t0 = _context["catch"](2);
            utilLogger.log({
              title: "".concat(_context.t0.name, " fcl-wc Init Client"),
              message: _context.t0.message,
              level: utilLogger.LEVELS.error
            });
            throw _context.t0;

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[2, 9]]);
  }));

  return function initClient(_x) {
    return _ref2.apply(this, arguments);
  };
}();

var init = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator__default["default"]( /*#__PURE__*/_regeneratorRuntime__default["default"].mark(function _callee2() {
    var _client2;

    var _ref4,
        projectId,
        metadata,
        _ref4$includeBaseWC,
        includeBaseWC,
        _ref4$wcRequestHook,
        wcRequestHook,
        _ref4$pairingModalOve,
        pairingModalOverride,
        _ref4$wallets,
        wallets,
        _client,
        FclWcServicePlugin,
        _args2 = arguments;

    return _regeneratorRuntime__default["default"].wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _ref4 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, projectId = _ref4.projectId, metadata = _ref4.metadata, _ref4$includeBaseWC = _ref4.includeBaseWC, includeBaseWC = _ref4$includeBaseWC === void 0 ? false : _ref4$includeBaseWC, _ref4$wcRequestHook = _ref4.wcRequestHook, wcRequestHook = _ref4$wcRequestHook === void 0 ? null : _ref4$wcRequestHook, _ref4$pairingModalOve = _ref4.pairingModalOverride, pairingModalOverride = _ref4$pairingModalOve === void 0 ? null : _ref4$pairingModalOve, _ref4$wallets = _ref4.wallets, wallets = _ref4$wallets === void 0 ? [] : _ref4$wallets;
            _context2.next = 3;
            return setConfiguredNetwork();

          case 3:
            if (!((_client2 = client) !== null && _client2 !== void 0)) {
              _context2.next = 7;
              break;
            }

            _context2.t0 = _client2;
            _context2.next = 10;
            break;

          case 7:
            _context2.next = 9;
            return initClient({
              projectId: projectId,
              metadata: metadata
            });

          case 9:
            _context2.t0 = _context2.sent;

          case 10:
            _client = _context2.t0;
            _context2.next = 13;
            return makeServicePlugin(_client, {
              projectId: projectId,
              includeBaseWC: includeBaseWC,
              wcRequestHook: wcRequestHook,
              pairingModalOverride: pairingModalOverride,
              wallets: wallets
            });

          case 13:
            FclWcServicePlugin = _context2.sent;
            fcl__namespace.discovery.authn.update();
            return _context2.abrupt("return", {
              FclWcServicePlugin: FclWcServicePlugin,
              client: client
            });

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function init() {
    return _ref3.apply(this, arguments);
  };
}();

Object.defineProperty(exports, 'getSdkError', {
  enumerable: true,
  get: function () { return utils.getSdkError; }
});
exports.init = init;
//# sourceMappingURL=fcl-wc.js.map
