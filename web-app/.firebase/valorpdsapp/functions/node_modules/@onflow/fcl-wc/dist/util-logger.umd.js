(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["onflowFcl-wc"] = {}));
})(this, (function (exports) { 'use strict';

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof$1(obj);
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function () {
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var regeneratorRuntime$1 = {exports: {}};

  var _typeof = {exports: {}};

  (function (module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";

      return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
    }

    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof);

  (function (module) {
    var _typeof$1 = _typeof.exports["default"];

    function _regeneratorRuntime() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

      module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports = {},
          Op = Object.prototype,
          hasOwn = Op.hasOwnProperty,
          $Symbol = "function" == typeof Symbol ? Symbol : {},
          iteratorSymbol = $Symbol.iterator || "@@iterator",
          asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
          toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), obj[key];
      }

      try {
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }

      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
            generator = Object.create(protoGenerator.prototype),
            context = new Context(tryLocsList || []);
        return generator._invoke = function (innerFn, self, context) {
          var state = "suspendedStart";
          return function (method, arg) {
            if ("executing" === state) throw new Error("Generator is already running");

            if ("completed" === state) {
              if ("throw" === method) throw arg;
              return doneResult();
            }

            for (context.method = method, context.arg = arg;;) {
              var delegate = context.delegate;

              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);

                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }

              if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
                if ("suspendedStart" === state) throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record = tryCatch(innerFn, self, context);

              if ("normal" === record.type) {
                if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                return {
                  value: record.arg,
                  done: context.done
                };
              }

              "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
          };
        }(innerFn, self, context), generator;
      }

      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }

      exports.wrap = wrap;
      var ContinueSentinel = {};

      function Generator() {}

      function GeneratorFunction() {}

      function GeneratorFunctionPrototype() {}

      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf,
          NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }

      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);

          if ("throw" !== record.type) {
            var result = record.arg,
                value = result.value;
            return value && "object" == _typeof$1(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }

          reject(record.arg);
        }

        var previousPromise;

        this._invoke = function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }

          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
      }

      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];

        if (undefined === method) {
          if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return ContinueSentinel;
        }

        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }

      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }

      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }

      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
      }

      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next) return iterable;

          if (!isNaN(iterable.length)) {
            var i = -1,
                next = function next() {
              for (; ++i < iterable.length;) {
                if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
              }

              return next.value = undefined, next.done = !0, next;
            };

            return next.next = next;
          }
        }

        return {
          next: doneResult
        };
      }

      function doneResult() {
        return {
          value: undefined,
          done: !0
        };
      }

      return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function (genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function (arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
        return this;
      }), define(Gp, "toString", function () {
        return "[object Generator]";
      }), exports.keys = function (object) {
        var keys = [];

        for (var key in object) {
          keys.push(key);
        }

        return keys.reverse(), function next() {
          for (; keys.length;) {
            var key = keys.pop();
            if (key in object) return next.value = key, next.done = !1, next;
          }

          return next.done = !0, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
          }
        },
        stop: function stop() {
          this.done = !0;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type) throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) throw exception;
          var context = this;

          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
          }

          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i],
                record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");

            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"),
                  hasFinally = hasOwn.call(entry, "finallyLoc");

              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              } else {
                if (!hasFinally) throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }

          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type) throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];

            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;

              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }

              return thrown;
            }
          }

          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      }, exports;
    }

    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);

  var runtime = regeneratorRuntime$1.exports();
  var regenerator = runtime; // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function F() {};

        return {
          s: F,
          n: function n() {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function e(_e) {
            throw _e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function s() {
        it = it.call(o);
      },
      n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function e(_e2) {
        didErr = true;
        err = _e2;
      },
      f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var promise;
  var queueMicrotask_1 = typeof queueMicrotask === 'function' ? queueMicrotask // reuse resolved promise, and allocate it lazily
  : function (cb) {
    return (promise || (promise = Promise.resolve())).then(cb)["catch"](function (err) {
      return setTimeout(function () {
        throw err;
      }, 0);
    });
  };

  var mailbox = function mailbox() {
    var queue = [];
    var next;
    return {
      deliver: function deliver(msg) {
        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  queue.push(msg);

                  if (next) {
                    next(queue.shift());
                    next = undefined;
                  }

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      receive: function receive() {
        return new Promise(function innerReceive(resolve) {
          var msg = queue.shift();
          if (msg) return resolve(msg);
          next = resolve;
        });
      }
    };
  };

  var INIT = "INIT";
  var SUBSCRIBE = "SUBSCRIBE";
  var UNSUBSCRIBE = "UNSUBSCRIBE";
  var UPDATED$3 = "UPDATED";
  var SNAPSHOT$1 = "SNAPSHOT";
  var EXIT = "EXIT";
  var TERMINATE = "TERMINATE";
  var root = (typeof self === "undefined" ? "undefined" : _typeof$1(self)) === "object" && self.self === self && self || (typeof global === "undefined" ? "undefined" : _typeof$1(global)) === "object" && global.global === global && global || (typeof window === "undefined" ? "undefined" : _typeof$1(window)) === "object" && window.window === window && window;
  root.FCL_REGISTRY = root.FCL_REGISTRY == null ? {} : root.FCL_REGISTRY;
  var pid = 0;
  var DEFAULT_TIMEOUT = 5000;

  var _send = function send(addr, tag, data) {
    var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    return new Promise(function (reply, reject) {
      var expectReply = opts.expectReply || false;
      var timeout = opts.timeout != null ? opts.timeout : DEFAULT_TIMEOUT;

      if (expectReply && timeout) {
        setTimeout(function () {
          return reject(new Error("Timeout: ".concat(timeout, "ms passed without a response.")));
        }, timeout);
      }

      var payload = {
        to: addr,
        from: opts.from,
        tag: tag,
        data: data,
        timeout: timeout,
        reply: reply,
        reject: reject
      };

      try {
        root.FCL_REGISTRY[addr] && root.FCL_REGISTRY[addr].mailbox.deliver(payload);
        if (!expectReply) reply(true);
      } catch (error) {
        console.error("FCL.Actor -- Could Not Deliver Message", payload, root.FCL_REGISTRY[addr], error);
      }
    });
  };

  var kill = function kill(addr) {
    delete root.FCL_REGISTRY[addr];
  };

  var fromHandlers = function fromHandlers() {
    var handlers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ctx) {
        var letter;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (!(typeof handlers[INIT] === "function")) {
                  _context.next = 3;
                  break;
                }

                _context.next = 3;
                return handlers[INIT](ctx);

              case 3:
                _context.next = 6;
                return ctx.receive();

              case 6:
                letter = _context.sent;
                _context.prev = 7;

                if (!(letter.tag === EXIT)) {
                  _context.next = 13;
                  break;
                }

                if (!(typeof handlers[TERMINATE] === "function")) {
                  _context.next = 12;
                  break;
                }

                _context.next = 12;
                return handlers[TERMINATE](ctx, letter, letter.data || {});

              case 12:
                return _context.abrupt("break", 25);

              case 13:
                _context.next = 15;
                return handlers[letter.tag](ctx, letter, letter.data || {});

              case 15:
                _context.next = 20;
                break;

              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](7);
                console.error("".concat(ctx.self(), " Error"), letter, _context.t0);

              case 20:
                _context.prev = 20;
                return _context.abrupt("continue", 3);

              case 23:
                _context.next = 3;
                break;

              case 25:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[7, 17, 20, 23]]);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
  };

  var spawn = function spawn(fn) {
    var addr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (addr == null) addr = ++pid;
    if (root.FCL_REGISTRY[addr] != null) return addr;
    root.FCL_REGISTRY[addr] = {
      addr: addr,
      mailbox: mailbox(),
      subs: new Set(),
      kvs: {},
      error: null
    };
    var ctx = {
      self: function self() {
        return addr;
      },
      receive: function receive() {
        return root.FCL_REGISTRY[addr].mailbox.receive();
      },
      send: function send(to, tag, data) {
        var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        opts.from = addr;
        return _send(to, tag, data, opts);
      },
      sendSelf: function sendSelf(tag, data, opts) {
        if (root.FCL_REGISTRY[addr]) _send(addr, tag, data, opts);
      },
      broadcast: function broadcast(tag, data) {
        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        opts.from = addr;

        var _iterator = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var to = _step.value;

            _send(to, tag, data, opts);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      },
      subscribe: function subscribe(sub) {
        return sub != null && root.FCL_REGISTRY[addr].subs.add(sub);
      },
      unsubscribe: function unsubscribe(sub) {
        return sub != null && root.FCL_REGISTRY[addr].subs["delete"](sub);
      },
      subscriberCount: function subscriberCount() {
        return root.FCL_REGISTRY[addr].subs.size;
      },
      hasSubs: function hasSubs() {
        return !!root.FCL_REGISTRY[addr].subs.size;
      },
      put: function put(key, value) {
        if (key != null) root.FCL_REGISTRY[addr].kvs[key] = value;
      },
      get: function get(key, fallback) {
        var value = root.FCL_REGISTRY[addr].kvs[key];
        return value == null ? fallback : value;
      },
      "delete": function _delete(key) {
        delete root.FCL_REGISTRY[addr].kvs[key];
      },
      update: function update(key, fn) {
        if (key != null) root.FCL_REGISTRY[addr].kvs[key] = fn(root.FCL_REGISTRY[addr].kvs[key]);
      },
      keys: function keys() {
        return Object.keys(root.FCL_REGISTRY[addr].kvs);
      },
      all: function all() {
        return root.FCL_REGISTRY[addr].kvs;
      },
      where: function where(pattern) {
        return Object.keys(root.FCL_REGISTRY[addr].kvs).reduce(function (acc, key) {
          return pattern.test(key) ? _objectSpread2(_objectSpread2({}, acc), {}, _defineProperty({}, key, root.FCL_REGISTRY[addr].kvs[key])) : acc;
        }, {});
      },
      merge: function merge() {
        var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        Object.keys(data).forEach(function (key) {
          return root.FCL_REGISTRY[addr].kvs[key] = data[key];
        });
      },
      fatalError: function fatalError(error) {
        root.FCL_REGISTRY[addr].error = error;

        var _iterator2 = _createForOfIteratorHelper(root.FCL_REGISTRY[addr].subs),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var to = _step2.value;

            _send(to, UPDATED$3);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    };
    if (_typeof$1(fn) === "object") fn = fromHandlers(fn);
    queueMicrotask_1( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return fn(ctx);

            case 2:
              kill(addr);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    return addr;
  }; // Returns an unsubscribe function
  // A SUBSCRIBE handler will need to be created to handle the subscription event
  //
  //  [SUBSCRIBE]: (ctx, letter) => {
  //    ctx.subscribe(letter.from)
  //    ctx.send(letter.from, UPDATED, ctx.all())
  //  }
  //


  function subscriber(address, spawnFn, callback) {
    spawnFn(address);
    var EXIT = "@EXIT";
    var self = spawn( /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ctx) {
        var letter, error;
        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                ctx.send(address, SUBSCRIBE);

              case 1:
                _context3.next = 4;
                return ctx.receive();

              case 4:
                letter = _context3.sent;
                error = root.FCL_REGISTRY[address].error;

                if (!(letter.tag === EXIT)) {
                  _context3.next = 9;
                  break;
                }

                ctx.send(address, UNSUBSCRIBE);
                return _context3.abrupt("return");

              case 9:
                if (!error) {
                  _context3.next = 13;
                  break;
                }

                callback(null, error);
                ctx.send(address, UNSUBSCRIBE);
                return _context3.abrupt("return");

              case 13:
                callback(letter.data, null);
                _context3.next = 1;
                break;

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }));

      return function (_x2) {
        return _ref3.apply(this, arguments);
      };
    }());
    return function () {
      return _send(self, EXIT);
    };
  } // Returns a promise that returns a result
  // A SNAPSHOT handler will need to be created to handle the snapshot event
  //
  //  [SNAPSHOT]: (ctx, letter) => {
  //    letter.reply(ctx.all())
  //  }
  //


  function snapshoter(address, spawnFn) {
    spawnFn(address);
    return _send(address, SNAPSHOT$1, null, {
      expectReply: true,
      timeout: 0
    });
  }

  var _HANDLERS$4;

  var NAME$1 = "config";
  var PUT = "PUT_CONFIG";
  var GET = "GET_CONFIG";
  var GET_ALL = "GET_ALL_CONFIG";
  var UPDATE = "UPDATE_CONFIG";
  var DELETE = "DELETE_CONFIG";
  var CLEAR = "CLEAR_CONFIG";
  var WHERE = "WHERE_CONFIG";
  var UPDATED$2 = "CONFIG/UPDATED";

  var identity$3 = function identity(v) {
    return v;
  };

  var HANDLERS = (_HANDLERS$4 = {}, _defineProperty(_HANDLERS$4, PUT, function (ctx, _letter, _ref) {
    var key = _ref.key,
        value = _ref.value;
    if (key == null) throw new Error("Missing 'key' for config/put.");
    ctx.put(key, value);
    ctx.broadcast(UPDATED$2, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS$4, GET, function (ctx, letter, _ref2) {
    var key = _ref2.key,
        fallback = _ref2.fallback;
    if (key == null) throw new Error("Missing 'key' for config/get");
    letter.reply(ctx.get(key, fallback));
  }), _defineProperty(_HANDLERS$4, GET_ALL, function (ctx, letter) {
    letter.reply(_objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS$4, UPDATE, function (ctx, letter, _ref3) {
    var key = _ref3.key,
        fn = _ref3.fn;
    if (key == null) throw new Error("Missing 'key' for config/update");
    ctx.update(key, fn || identity$3);
    ctx.broadcast(UPDATED$2, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS$4, DELETE, function (ctx, letter, _ref4) {
    var key = _ref4.key;
    if (key == null) throw new Error("Missing 'key' for config/delete");
    ctx["delete"](key);
    ctx.broadcast(UPDATED$2, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS$4, CLEAR, function (ctx, letter) {
    var keys = Object.keys(ctx.all());

    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];
      ctx["delete"](key);
    }

    ctx.broadcast(UPDATED$2, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS$4, WHERE, function (ctx, letter, _ref5) {
    var pattern = _ref5.pattern;
    if (pattern == null) throw new Error("Missing 'pattern' for config/where");
    letter.reply(ctx.where(pattern));
  }), _defineProperty(_HANDLERS$4, SUBSCRIBE, function (ctx, letter) {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED$2, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS$4, UNSUBSCRIBE, function (ctx, letter) {
    ctx.unsubscribe(letter.from);
  }), _HANDLERS$4);
  spawn(HANDLERS, NAME$1);

  function put$1(key, value) {
    _send(NAME$1, PUT, {
      key: key,
      value: value
    });
    return config();
  }

  function get$1(key, fallback) {
    return _send(NAME$1, GET, {
      key: key,
      fallback: fallback
    }, {
      expectReply: true,
      timeout: 10
    });
  }

  function first() {
    return _first.apply(this, arguments);
  }

  function _first() {
    _first = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      var wants,
          fallback,
          _wants,
          head,
          rest,
          ret,
          _args2 = arguments;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              wants = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : [];
              fallback = _args2.length > 1 ? _args2[1] : undefined;

              if (wants.length) {
                _context2.next = 4;
                break;
              }

              return _context2.abrupt("return", fallback);

            case 4:
              _wants = _toArray(wants), head = _wants[0], rest = _wants.slice(1);
              _context2.next = 7;
              return get$1(head);

            case 7:
              ret = _context2.sent;

              if (!(ret == null)) {
                _context2.next = 10;
                break;
              }

              return _context2.abrupt("return", first(rest, fallback));

            case 10:
              return _context2.abrupt("return", ret);

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _first.apply(this, arguments);
  }

  function all() {
    return _send(NAME$1, GET_ALL, null, {
      expectReply: true,
      timeout: 10
    });
  }

  function update$1(key) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$3;
    _send(NAME$1, UPDATE, {
      key: key,
      fn: fn
    });
    return config();
  }

  function _delete(key) {
    _send(NAME$1, DELETE, {
      key: key
    });
    return config();
  }

  function where(pattern) {
    return _send(NAME$1, WHERE, {
      pattern: pattern
    }, {
      expectReply: true,
      timeout: 10
    });
  }

  function subscribe(callback) {
    return subscriber(NAME$1, function () {
      return spawn(HANDLERS, NAME$1);
    }, callback);
  }

  function clearConfig() {
    return _send(NAME$1, CLEAR);
  }

  function config(values) {
    if (values != null && _typeof$1(values) === "object") {
      Object.keys(values).map(function (d) {
        return put$1(d, values[d]);
      });
    }

    return {
      put: put$1,
      get: get$1,
      all: all,
      first: first,
      update: update$1,
      "delete": _delete,
      where: where,
      subscribe: subscribe,
      overload: overload
    };
  }

  config.put = put$1;
  config.get = get$1;
  config.all = all;
  config.first = first;
  config.update = update$1;
  config["delete"] = _delete;
  config.where = where;
  config.subscribe = subscribe;
  config.overload = overload;

  var noop$6 = function noop(v) {
    return v;
  };

  function overload() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$6;
    return new Promise( /*#__PURE__*/function () {
      var _ref6 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(resolve, reject) {
        var oldConfig, result;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return all();

              case 2:
                oldConfig = _context.sent;
                _context.prev = 3;
                config(opts);
                _context.t0 = callback;
                _context.next = 8;
                return all();

              case 8:
                _context.t1 = _context.sent;
                _context.next = 11;
                return (0, _context.t0)(_context.t1);

              case 11:
                result = _context.sent;
                _context.next = 14;
                return clearConfig();

              case 14:
                _context.next = 16;
                return config(oldConfig);

              case 16:
                resolve(result);
                _context.next = 26;
                break;

              case 19:
                _context.prev = 19;
                _context.t2 = _context["catch"](3);
                _context.next = 23;
                return clearConfig();

              case 23:
                _context.next = 25;
                return config(oldConfig);

              case 25:
                reject(_context.t2);

              case 26:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[3, 19]]);
      }));

      return function (_x, _x2) {
        return _ref6.apply(this, arguments);
      };
    }());
  }

  function invariant$1(fact, msg) {
    if (!fact) {
      var _console;

      var error = new Error("INVARIANT ".concat(msg));
      error.stack = error.stack.split("\n").filter(function (d) {
        return !/at invariant/.test(d);
      }).join("\n");

      for (var _len = arguments.length, rest = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        rest[_key - 2] = arguments[_key];
      }

      (_console = console).error.apply(_console, ["\n\n---\n\n", error, "\n\n"].concat(rest, ["\n\n---\n\n"]));

      throw error;
    }
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  var LEVELS = Object.freeze({
    debug: 5,
    info: 4,
    log: 3,
    warn: 2,
    error: 1
  });

  var buildLoggerMessageArgs = function buildLoggerMessageArgs(_ref) {
    var title = _ref.title,
        message = _ref.message;
    return ["\n    %c".concat(title, "\n    ============================\n\n    ").concat(message, "\n\n    ============================\n    ").replace(/\n[^\S\r\n]+/g, "\n").trim(),, "font-weight:bold;font-family:monospace;"];
  };

  var log = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref2) {
      var _console, _console2, _console3, _console4, _console5;

      var title, message, level, _ref2$always, always, configLoggerLevel, loggerMessageArgs;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              title = _ref2.title, message = _ref2.message, level = _ref2.level, _ref2$always = _ref2.always, always = _ref2$always === void 0 ? false : _ref2$always;
              _context.next = 3;
              return config.get("logger.level", LEVELS.warn);

            case 3:
              configLoggerLevel = _context.sent;

              if (!(!always && configLoggerLevel < level)) {
                _context.next = 6;
                break;
              }

              return _context.abrupt("return");

            case 6:
              loggerMessageArgs = buildLoggerMessageArgs({
                title: title,
                message: message
              });
              _context.t0 = level;
              _context.next = _context.t0 === LEVELS.debug ? 10 : _context.t0 === LEVELS.info ? 12 : _context.t0 === LEVELS.warn ? 14 : _context.t0 === LEVELS.error ? 16 : 18;
              break;

            case 10:
              (_console = console).debug.apply(_console, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 12:
              (_console2 = console).info.apply(_console2, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 14:
              (_console3 = console).warn.apply(_console3, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 16:
              (_console4 = console).error.apply(_console4, _toConsumableArray(loggerMessageArgs));

              return _context.abrupt("break", 19);

            case 18:
              (_console5 = console).log.apply(_console5, _toConsumableArray(loggerMessageArgs));

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function log(_x) {
      return _ref3.apply(this, arguments);
    };
  }();

  log.deprecate = function (_ref4) {
    var pkg = _ref4.pkg,
        subject = _ref4.subject,
        transition = _ref4.transition,
        _ref4$level = _ref4.level,
        level = _ref4$level === void 0 ? LEVELS.warn : _ref4$level,
        _ref4$message = _ref4.message,
        message = _ref4$message === void 0 ? "" : _ref4$message,
        _ref4$callback = _ref4.callback,
        callback = _ref4$callback === void 0 ? null : _ref4$callback;

    var capitalizeFirstLetter = function capitalizeFirstLetter(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    };

    var logMessage = function logMessage() {
      return log({
        title: "".concat(pkg ? pkg + " " : "", "Deprecation Notice"),
        message: "\n      ".concat(subject ? "".concat(capitalizeFirstLetter(subject), " is deprecated and will cease to work in future releases").concat(pkg ? " of " + pkg : "", ".") : "").concat(message ? "\n" + message : "").concat(transition ? "\nYou can learn more (including a guide on common transition paths) here: ".concat(transition) : "", "\n    ").trim(),
        level: level
      });
    };

    if (typeof callback === "function") {
      return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        var _args2 = arguments;
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return logMessage();

              case 2:
                _context2.next = 4;
                return callback.apply(void 0, _args2);

              case 4:
                return _context2.abrupt("return", _context2.sent);

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));
    }

    return logMessage();
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  var buffer$1 = {};

  var base64Js = {};

  base64Js.byteLength = byteLength$1;
  base64Js.toByteArray = toByteArray;
  base64Js.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var code$1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  for (var i$2 = 0, len = code$1.length; i$2 < len; ++i$2) {
    lookup[i$2] = code$1[i$2];
    revLookup[code$1.charCodeAt(i$2)] = i$2;
  } // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications


  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;

  function getLens(b64) {
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42


    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  } // base64 is 4/3 + up to two characters of the original data


  function byteLength$1(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }

  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;

    for (i = 0; i < len; i += 4) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[curByte++] = tmp >> 16 & 0xFF;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[curByte++] = tmp & 0xFF;
    }

    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 0xFF;
      arr[curByte++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3
    // go through the array every three bytes, we'll deal with trailing stuff later

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    } // pad the end with zeros, but make sure to not forget the extra bytes


    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }

    return parts.join('');
  }

  var ieee754 = {};

  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

  ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };

  ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  };

  (function (exports) {

    var base64 = base64Js;
    var ieee754$1 = ieee754;
    var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */

    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
    }

    function typedArraySupport() {
      // Can typed array instances can be augmented?
      try {
        var arr = new Uint8Array(1);
        var proto = {
          foo: function foo() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }

    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
      }
    });

    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      } // Return an augmented `Uint8Array` instance


      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */


    function Buffer(arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }

        return allocUnsafe(arg);
      }

      return from(arg, encodingOrOffset, length);
    }

    Buffer.poolSize = 8192; // not used by this implementation

    function from(value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
      }

      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }

      if (value == null) {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof$1(value));
      }

      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }

      var valueOf = value.valueOf && value.valueOf();

      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }

      var b = fromObject(value);
      if (b) return b;

      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
      }

      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof$1(value));
    }
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/


    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148


    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }

    function alloc(size, fill, encoding) {
      assertSize(size);

      if (size <= 0) {
        return createBuffer(size);
      }

      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }

      return createBuffer(size);
    }
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/


    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding);
    };

    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */


    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size);
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */


    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size);
    };

    function fromString(string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
      }

      return buf;
    }

    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);

      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }

      return buf;
    }

    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }

      return fromArrayLike(arrayView);
    }

    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }

      var buf;

      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      } // Return an augmented `Uint8Array` instance


      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }

    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);

        if (buf.length === 0) {
          return buf;
        }

        obj.copy(buf, 0, 0, len);
        return buf;
      }

      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }

        return fromArrayLike(obj);
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }

    function checked(length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
      }

      return length | 0;
    }

    function SlowBuffer(length) {
      if (+length != length) {
        // eslint-disable-line eqeqeq
        length = 0;
      }

      return Buffer.alloc(+length);
    }

    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
    };

    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }

      if (a === b) return 0;
      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;

        default:
          return false;
      }
    };

    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer.alloc(0);
      }

      var i;

      if (length === undefined) {
        length = 0;

        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;

      for (i = 0; i < list.length; ++i) {
        var buf = list[i];

        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }

        pos += buf.length;
      }

      return buffer;
    };

    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }

      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }

      if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof$1(string));
      }

      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;

          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length;

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;

          case 'hex':
            return len >>> 1;

          case 'base64':
            return base64ToBytes(string).length;

          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
            }

            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

      if (start === undefined || start < 0) {
        start = 0;
      } // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.


      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154


    Buffer.prototype._isBuffer = true;

    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;

      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }

      return this;
    };

    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;

      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }

      return this;
    };

    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;

      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }

      return this;
    };

    Buffer.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };

    Buffer.prototype.inspect = function inspect() {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
      if (this.length > max) str += ' ... ';
      return '<Buffer ' + str + '>';
    };

    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }

      if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof$1(target));
      }

      if (start === undefined) {
        start = 0;
      }

      if (end === undefined) {
        end = target ? target.length : 0;
      }

      if (thisStart === undefined) {
        thisStart = 0;
      }

      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }

      if (thisStart >= thisEnd) {
        return -1;
      }

      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf


    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1; // Normalize byteOffset

      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }

      byteOffset = +byteOffset; // Coerce to Number.

      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
      } // Normalize byteOffset: negative offsets start from the end of the buffer


      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      } // Normalize val


      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      } // Finally, search either indexOf (if dir is true) or lastIndexOf


      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1;
        }

        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]

        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }

        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();

        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }

          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      var i;

      if (dir) {
        var foundIndex = -1;

        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

        for (i = byteOffset; i >= 0; i--) {
          var found = true;

          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }

          if (found) return i;
        }
      }

      return -1;
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;

      if (!length) {
        length = remaining;
      } else {
        length = Number(length);

        if (length > remaining) {
          length = remaining;
        }
      }

      var strLen = string.length;

      if (length > strLen / 2) {
        length = strLen / 2;
      }

      var i;

      for (i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }

      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0; // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0; // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0;

        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
          case 'latin1':
          case 'binary':
            return asciiWrite(this, string, offset, length);

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;

      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte = void 0,
              thirdByte = void 0,
              fourthByte = void 0,
              tempCodePoint = void 0;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }

              break;

            case 2:
              secondByte = buf[i + 1];

              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }

          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety


    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;

      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
      } // Decode in chunks to avoid "call stack size exceeded".


      var res = '';
      var i = 0;

      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }

      return res;
    }

    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }

      return ret;
    }

    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }

      return ret;
    }

    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = '';

      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }

      return out;
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }

      return res;
    }

    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;
      var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */


    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;

      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
      var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
      var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];

      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
    });
    Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, 'offset');
      var first = this[offset];
      var last = this[offset + 7];

      if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
      }

      var val = (first << 24) + // Overflow
      this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
    });

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      var lo = Number(value & BigInt(0xffffffff));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }

    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      var lo = Number(value & BigInt(0xffffffff));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }

    Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
    });
    Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
    });

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    });
    Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
    });

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }

      if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
      if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

      if (end > this.length) end = this.length;

      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;

      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }

      return len;
    }; // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])


    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }

        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }

        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }

        if (val.length === 1) {
          var code = val.charCodeAt(0);

          if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } else if (typeof val === 'boolean') {
        val = Number(val);
      } // Invalid ranges are not set to a default, so can range check early.


      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;

      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;

        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }

        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    }; // CUSTOM ERRORS
    // =============
    // Simplified versions from Node, changed for Buffer-only usage


    var errors = {};

    function E(sym, getMessage, Base) {
      errors[sym] = /*#__PURE__*/function (_Base) {
        _inherits(NodeError, _Base);

        var _super = _createSuper(NodeError);

        function NodeError() {
          var _this;

          _classCallCheck(this, NodeError);

          _this = _super.call(this);
          Object.defineProperty(_assertThisInitialized(_this), 'message', {
            value: getMessage.apply(_assertThisInitialized(_this), arguments),
            writable: true,
            configurable: true
          }); // Add the error code to the name to include it in the stack trace.

          _this.name = "".concat(_this.name, " [").concat(sym, "]"); // Access the stack to generate the error message including the error code
          // from the name.

          _this.stack; // eslint-disable-line no-unused-expressions
          // Reset the name to the actual name.

          delete _this.name;
          return _this;
        }

        _createClass(NodeError, [{
          key: "code",
          get: function get() {
            return sym;
          },
          set: function set(value) {
            Object.defineProperty(this, 'code', {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true
            });
          }
        }, {
          key: "toString",
          value: function toString() {
            return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
          }
        }]);

        return NodeError;
      }(Base);
    }

    E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
      if (name) {
        return "".concat(name, " is outside of buffer bounds");
      }

      return 'Attempt to access memory outside buffer bounds';
    }, RangeError);
    E('ERR_INVALID_ARG_TYPE', function (name, actual) {
      return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof$1(actual));
    }, TypeError);
    E('ERR_OUT_OF_RANGE', function (str, range, input) {
      var msg = "The value of \"".concat(str, "\" is out of range.");
      var received = input;

      if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === 'bigint') {
        received = String(input);

        if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
          received = addNumericalSeparator(received);
        }

        received += 'n';
      }

      msg += " It must be ".concat(range, ". Received ").concat(received);
      return msg;
    }, RangeError);

    function addNumericalSeparator(val) {
      var res = '';
      var i = val.length;
      var start = val[0] === '-' ? 1 : 0;

      for (; i >= start + 4; i -= 3) {
        res = "_".concat(val.slice(i - 3, i)).concat(res);
      }

      return "".concat(val.slice(0, i)).concat(res);
    } // CHECK FUNCTIONS
    // ===============


    function checkBounds(buf, offset, byteLength) {
      validateNumber(offset, 'offset');

      if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
      }
    }

    function checkIntBI(value, min, max, buf, offset, byteLength) {
      if (value > max || value < min) {
        var n = typeof min === 'bigint' ? 'n' : '';
        var range;

        if (byteLength > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
          } else {
            range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
          }
        } else {
          range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
        }

        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
      }

      checkBounds(buf, offset, byteLength);
    }

    function validateNumber(value, name) {
      if (typeof value !== 'number') {
        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
      }
    }

    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
      }

      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }

      throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
    } // HELPER FUNCTIONS
    // ================


    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    function base64clean(str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

      str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

      if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

      while (str.length % 4 !== 0) {
        str = str + '=';
      }

      return str;
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i); // is surrogate component

        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } // valid lead


            leadSurrogate = codePoint;
            continue;
          } // 2 leads in a row


          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } // valid surrogate pair


          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null; // encode utf8

        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }

      return byteArray;
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      var i;

      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }

      return i;
    } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166


    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }

    function numberIsNaN(obj) {
      // For IE11 support
      return obj !== obj; // eslint-disable-line no-self-compare
    } // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219


    var hexSliceLookupTable = function () {
      var alphabet = '0123456789abcdef';
      var table = new Array(256);

      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;

        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }

      return table;
    }(); // Return not function with Error if BigInt not supported


    function defineBigIntMethod(fn) {
      return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
    }

    function BufferBigIntNotDefined() {
      throw new Error('BigInt not supported');
    }
  })(buffer$1);

  /**
   * Built on top of rlp library, removing the BN dependency for the flow.
   * Package : https://github.com/ethereumjs/rlp
   * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE
   *
   * ethereumjs/rlp is licensed under the
   * Mozilla Public License 2.0
   * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.
   **/

  /**
   * @param input - will be converted to buffer
   * @returns returns buffer of encoded data
   **/

  function encode$3(input) {
    if (Array.isArray(input)) {
      var output = [];

      for (var i = 0; i < input.length; i++) {
        output.push(encode$3(input[i]));
      }

      var buf = buffer$1.Buffer.concat(output);
      return buffer$1.Buffer.concat([encodeLength(buf.length, 192), buf]);
    } else {
      var inputBuf = toBuffer(input);
      return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : buffer$1.Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
    }
  }

  function encodeLength(len, offset) {
    if (len < 56) {
      return buffer$1.Buffer.from([len + offset]);
    } else {
      var hexLength = intToHex(len);
      var lLength = hexLength.length / 2;
      var firstByte = intToHex(offset + 55 + lLength);
      return buffer$1.Buffer.from(firstByte + hexLength, "hex");
    }
  }
  /** Check if a string is prefixed by 0x */


  function isHexPrefixed(str) {
    return str.slice(0, 2) === "0x";
  }
  /** Removes 0x from a given String */


  function stripHexPrefix(str) {
    if (typeof str !== "string") {
      return str;
    }

    return isHexPrefixed(str) ? str.slice(2) : str;
  }
  /** Transform an integer into its hexadecimal value */


  function intToHex(integer) {
    if (integer < 0) {
      throw new Error("Invalid integer as argument, must be unsigned!");
    }

    var hex = integer.toString(16);
    return hex.length % 2 ? "0" + hex : hex;
  }
  /** Pad a string to be even */


  function padToEven(a) {
    return a.length % 2 ? "0" + a : a;
  }
  /** Transform an integer into a Buffer */


  function intToBuffer(integer) {
    var hex = intToHex(integer);
    return buffer$1.Buffer.from(hex, "hex");
  }
  /** Transform anything into a Buffer */


  function toBuffer(v) {
    if (!buffer$1.Buffer.isBuffer(v)) {
      if (typeof v === "string") {
        if (isHexPrefixed(v)) {
          return buffer$1.Buffer.from(padToEven(stripHexPrefix(v)), "hex");
        } else {
          return buffer$1.Buffer.from(v);
        }
      } else if (typeof v === "number") {
        if (!v) {
          return buffer$1.Buffer.from([]);
        } else {
          return intToBuffer(v);
        }
      } else if (v === null || v === undefined) {
        return buffer$1.Buffer.from([]);
      } else if (v instanceof Uint8Array) {
        return buffer$1.Buffer.from(v);
      } else {
        throw new Error("invalid type");
      }
    }

    return v;
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  var browser$4 = {exports: {}};

  (function (module, exports) {

    var getGlobal = function getGlobal() {
      // the only reliable means to get the global object is
      // `Function('return this')()`
      // However, this causes CSP violations in Chrome apps.
      if (typeof self !== 'undefined') {
        return self;
      }

      if (typeof window !== 'undefined') {
        return window;
      }

      if (typeof global !== 'undefined') {
        return global;
      }

      throw new Error('unable to locate global object');
    };

    var global = getGlobal();
    module.exports = exports = global.fetch; // Needed for TypeScript and Webpack.

    if (global.fetch) {
      exports["default"] = global.fetch.bind(global);
    }

    exports.Headers = global.Headers;
    exports.Request = global.Request;
    exports.Response = global.Response;
  })(browser$4, browser$4.exports);

  var fetchTransport = browser$4.exports;

  function sansPrefix(address) {
    if (address == null) return null;
    return address.replace(/^0x/, "").replace(/^Fx/, "");
  }

  function withPrefix$1(address) {
    if (address == null) return null;
    return "0x" + sansPrefix(address);
  }

  var HTTPRequestError = /*#__PURE__*/function (_Error) {
    _inherits(HTTPRequestError, _Error);

    var _super = _createSuper(HTTPRequestError);

    function HTTPRequestError(_ref) {
      var _this;

      var error = _ref.error,
          hostname = _ref.hostname,
          path = _ref.path,
          method = _ref.method,
          requestBody = _ref.requestBody,
          responseBody = _ref.responseBody,
          responseStatusText = _ref.responseStatusText,
          statusCode = _ref.statusCode;

      _classCallCheck(this, HTTPRequestError);

      var msg = "\n      HTTP Request Error: An error occurred when interacting with the Access API.\n      ".concat(error ? "error=".concat(error) : "", "\n      ").concat(hostname ? "hostname=".concat(hostname) : "", "\n      ").concat(path ? "path=".concat(path) : "", "\n      ").concat(method ? "method=".concat(method) : "", "\n      ").concat(requestBody ? "requestBody=".concat(requestBody) : "", "\n      ").concat(responseBody ? "responseBody=".concat(responseBody) : "", "\n      ").concat(responseStatusText ? "responseStatusText=".concat(responseStatusText) : "", "\n      ").concat(statusCode ? "statusCode=".concat(statusCode) : "", "\n    ");
      _this = _super.call(this, msg);
      _this.name = "HTTP Request Error";
      _this.statusCode = statusCode;
      _this.errorMessage = error;
      return _this;
    }

    return _createClass(HTTPRequestError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
   * Creates an HTTP Request to be sent to a REST Access API via Fetch API.
   *
   * @param {Object} options - Options for the HTTP Request
   * @param {String} options.hostname - Access API Hostname
   * @param {String} options.path - Path to the resource on the Access API
   * @param {String} options.method - HTTP Method
   * @param {Object} options.body - HTTP Request Body
   * @param {Object | Headers} [options.headers] - HTTP Request Headers
   *
   * @returns JSON object response from Access API.
   */


  function httpRequest(_x) {
    return _httpRequest.apply(this, arguments);
  }

  function _httpRequest() {
    _httpRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(_ref2) {
      var hostname, path, method, body, headers, _ref2$retryLimit, retryLimit, _ref2$retryIntervalMs, retryIntervalMs, bodyJSON, makeRequest, requestLoop, _requestLoop;

      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _requestLoop = function _requestLoop3() {
                _requestLoop = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
                  var retryAttempt,
                      resp,
                      retryStatusCodes,
                      _args3 = arguments;
                  return regenerator.wrap(function _callee3$(_context3) {
                    while (1) {
                      switch (_context3.prev = _context3.next) {
                        case 0:
                          retryAttempt = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : 0;
                          _context3.prev = 1;
                          _context3.next = 4;
                          return makeRequest();

                        case 4:
                          resp = _context3.sent;
                          return _context3.abrupt("return", resp);

                        case 8:
                          _context3.prev = 8;
                          _context3.t0 = _context3["catch"](1);
                          retryStatusCodes = [408, 429, 500, 502, 503, 504];

                          if (!retryStatusCodes.includes(_context3.t0.statusCode)) {
                            _context3.next = 17;
                            break;
                          }

                          _context3.next = 14;
                          return new Promise(function (resolve, reject) {
                            if (retryAttempt < retryLimit) {
                              console.warn("Access node unavailable, retrying in ".concat(retryIntervalMs, " ms..."));
                              setTimeout(function () {
                                resolve(requestLoop(retryAttempt + 1));
                              }, retryIntervalMs);
                            } else {
                              reject(_context3.t0);
                            }
                          });

                        case 14:
                          return _context3.abrupt("return", _context3.sent);

                        case 17:
                          throw _context3.t0;

                        case 18:
                        case "end":
                          return _context3.stop();
                      }
                    }
                  }, _callee3, null, [[1, 8]]);
                }));
                return _requestLoop.apply(this, arguments);
              };

              requestLoop = function _requestLoop2() {
                return _requestLoop.apply(this, arguments);
              };

              makeRequest = function _makeRequest() {
                return fetchTransport("".concat(hostname).concat(path), {
                  method: method,
                  body: bodyJSON,
                  headers: headers
                }).then( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(res) {
                    var responseText, response;
                    return regenerator.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            if (!res.ok) {
                              _context.next = 2;
                              break;
                            }

                            return _context.abrupt("return", res.json());

                          case 2:
                            if (!res.body) {
                              _context.next = 8;
                              break;
                            }

                            _context.next = 5;
                            return res.text();

                          case 5:
                            _context.t0 = _context.sent;
                            _context.next = 9;
                            break;

                          case 8:
                            _context.t0 = null;

                          case 9:
                            responseText = _context.t0;
                            response = safeParseJSON(responseText);
                            throw new HTTPRequestError({
                              error: response === null || response === void 0 ? void 0 : response.message,
                              hostname: hostname,
                              path: path,
                              method: method,
                              requestBody: bodyJSON,
                              responseBody: responseText,
                              responseStatusText: res.statusText,
                              statusCode: res.status
                            });

                          case 12:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x2) {
                    return _ref3.apply(this, arguments);
                  };
                }())["catch"]( /*#__PURE__*/function () {
                  var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(e) {
                    return regenerator.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            if (!(e instanceof HTTPRequestError)) {
                              _context2.next = 2;
                              break;
                            }

                            throw e;

                          case 2:
                            _context2.next = 4;
                            return log({
                              title: "Access Node Error",
                              message: "The provided access node ".concat(hostname, " does not appear to be a valid REST/HTTP access node.\nPlease verify that you are not unintentionally using a GRPC access node.\nSee more here: https://docs.onflow.org/fcl/reference/sdk-guidelines/#connect"),
                              level: LEVELS.error
                            });

                          case 4:
                            throw new HTTPRequestError({
                              error: e === null || e === void 0 ? void 0 : e.message,
                              hostname: hostname,
                              path: path,
                              method: method,
                              requestBody: bodyJSON
                            });

                          case 5:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x3) {
                    return _ref4.apply(this, arguments);
                  };
                }());
              };

              hostname = _ref2.hostname, path = _ref2.path, method = _ref2.method, body = _ref2.body, headers = _ref2.headers, _ref2$retryLimit = _ref2.retryLimit, retryLimit = _ref2$retryLimit === void 0 ? 5 : _ref2$retryLimit, _ref2$retryIntervalMs = _ref2.retryIntervalMs, retryIntervalMs = _ref2$retryIntervalMs === void 0 ? 1000 : _ref2$retryIntervalMs;
              bodyJSON = body ? JSON.stringify(body) : null;
              _context4.next = 7;
              return requestLoop();

            case 7:
              return _context4.abrupt("return", _context4.sent);

            case 8:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _httpRequest.apply(this, arguments);
  }

  function safeParseJSON(data) {
    try {
      return JSON.parse(data);
    } catch (_unused) {
      return null;
    }
  }

  function sendExecuteScriptAtBlockIDRequest(_x, _x2, _x3) {
    return _sendExecuteScriptAtBlockIDRequest.apply(this, arguments);
  }

  function _sendExecuteScriptAtBlockIDRequest() {
    _sendExecuteScriptAtBlockIDRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/scripts?block_id=".concat(ix.block.id),
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })
                }
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$4(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendExecuteScriptAtBlockIDRequest.apply(this, arguments);
  }

  function sendExecuteScriptAtBlockHeightRequest(_x4, _x5, _x6) {
    return _sendExecuteScriptAtBlockHeightRequest.apply(this, arguments);
  }

  function _sendExecuteScriptAtBlockHeightRequest() {
    _sendExecuteScriptAtBlockHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/scripts?block_height=".concat(ix.block.height),
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })
                }
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$4(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendExecuteScriptAtBlockHeightRequest.apply(this, arguments);
  }

  function sendExecuteScriptAtLatestBlockRequest(_x7, _x8, _x9) {
    return _sendExecuteScriptAtLatestBlockRequest.apply(this, arguments);
  }

  function _sendExecuteScriptAtLatestBlockRequest() {
    _sendExecuteScriptAtLatestBlockRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context3.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/scripts?block_height=sealed",
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })
                }
              });

            case 3:
              res = _context3.sent;
              return _context3.abrupt("return", constructResponse$4(ix, context, res));

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendExecuteScriptAtLatestBlockRequest.apply(this, arguments);
  }

  function constructResponse$4(ix, context, res) {
    var ret = context.response();
    ret.tag = ix.tag;
    ret.encodedData = JSON.parse(context.Buffer.from(res, "base64").toString());
    return ret;
  }

  function sendExecuteScript(_x10) {
    return _sendExecuteScript.apply(this, arguments);
  }

  function _sendExecuteScript() {
    _sendExecuteScript = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ix) {
      var context,
          opts,
          _args4 = arguments;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              invariant$1(opts.node, "SDK Send Execute Script Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Execute Script Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Execute Script Error: context.Buffer must be defined.");
              _context4.next = 7;
              return ix;

            case 7:
              ix = _context4.sent;

              if (!ix.block.id) {
                _context4.next = 14;
                break;
              }

              _context4.next = 11;
              return sendExecuteScriptAtBlockIDRequest(ix, context, opts);

            case 11:
              return _context4.abrupt("return", _context4.sent);

            case 14:
              if (!ix.block.height) {
                _context4.next = 20;
                break;
              }

              _context4.next = 17;
              return sendExecuteScriptAtBlockHeightRequest(ix, context, opts);

            case 17:
              return _context4.abrupt("return", _context4.sent);

            case 20:
              _context4.next = 22;
              return sendExecuteScriptAtLatestBlockRequest(ix, context, opts);

            case 22:
              return _context4.abrupt("return", _context4.sent);

            case 23:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendExecuteScript.apply(this, arguments);
  }

  var HashAlgorithmIDs = {
    SHA2_256: 1,
    SHA2_384: 2,
    SHA3_256: 3,
    SHA3_384: 4,
    KMAC128_BLS_BLS12_381: 5
  };
  var SignatureAlgorithmIDs = {
    ECDSA_P256: 1,
    ECDSA_secp256k1: 2,
    BLS_BLS12_381: 3
  };

  function sendGetAccountAtBlockHeightRequest(_x, _x2, _x3) {
    return _sendGetAccountAtBlockHeightRequest.apply(this, arguments);
  }

  function _sendGetAccountAtBlockHeightRequest() {
    _sendGetAccountAtBlockHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/accounts/".concat(ix.account.addr, "?block_height=").concat(ix.block.height, "&expand=contracts,keys"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$3(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetAccountAtBlockHeightRequest.apply(this, arguments);
  }

  function sendGetAccountAtLatestBlockRequest(_x4, _x5, _x6) {
    return _sendGetAccountAtLatestBlockRequest.apply(this, arguments);
  }

  function _sendGetAccountAtLatestBlockRequest() {
    _sendGetAccountAtLatestBlockRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/accounts/".concat(ix.account.addr, "?block_height=sealed&expand=contracts,keys"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$3(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetAccountAtLatestBlockRequest.apply(this, arguments);
  }

  function constructResponse$3(ix, context, res) {
    var _res$keys$map, _res$keys;

    var ret = context.response();
    ret.tag = ix.tag;

    var unwrapContracts = function unwrapContracts(contracts) {
      var c = {};
      if (!contracts) return c;

      for (var _i = 0, _Object$keys = Object.keys(contracts); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        c[key] = context.Buffer.from(contracts[key], "base64").toString();
      }

      return c;
    };

    ret.account = {
      address: res.address,
      balance: Number(res.balance),
      code: "",
      contracts: unwrapContracts(res.contracts),
      keys: (_res$keys$map = (_res$keys = res.keys) === null || _res$keys === void 0 ? void 0 : _res$keys.map(function (key) {
        return {
          index: Number(key.index),
          publicKey: key.public_key.replace(/^0x/, ""),
          signAlgo: SignatureAlgorithmIDs[key.signing_algorithm],
          signAlgoString: key.signing_algorithm,
          hashAlgo: HashAlgorithmIDs[key.hashing_algorithm],
          hashAlgoString: key.hashing_algorithm,
          sequenceNumber: Number(key.sequence_number),
          weight: Number(key.weight),
          revoked: key.revoked
        };
      })) !== null && _res$keys$map !== void 0 ? _res$keys$map : []
    };
    return ret;
  }

  function sendGetAccount(_x7) {
    return _sendGetAccount.apply(this, arguments);
  }

  function _sendGetAccount() {
    _sendGetAccount = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix) {
      var context,
          opts,
          _args3 = arguments;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              context = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              opts = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
              invariant$1(opts.node, "SDK Send Get Account Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Account Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Get Account Error: context.Buffer must be defined.");
              _context3.next = 7;
              return ix;

            case 7:
              ix = _context3.sent;

              if (!(ix.block.height !== null)) {
                _context3.next = 14;
                break;
              }

              _context3.next = 11;
              return sendGetAccountAtBlockHeightRequest(ix, context, opts);

            case 11:
              return _context3.abrupt("return", _context3.sent);

            case 14:
              _context3.next = 16;
              return sendGetAccountAtLatestBlockRequest(ix, context, opts);

            case 16:
              return _context3.abrupt("return", _context3.sent);

            case 17:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetAccount.apply(this, arguments);
  }

  function sendGetBlockHeaderByIDRequest(_x, _x2, _x3) {
    return _sendGetBlockHeaderByIDRequest.apply(this, arguments);
  }

  function _sendGetBlockHeaderByIDRequest() {
    _sendGetBlockHeaderByIDRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks/".concat(ix.block.id),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$2(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetBlockHeaderByIDRequest.apply(this, arguments);
  }

  function sendGetBlockHeaderByHeightRequest(_x4, _x5, _x6) {
    return _sendGetBlockHeaderByHeightRequest.apply(this, arguments);
  }

  function _sendGetBlockHeaderByHeightRequest() {
    _sendGetBlockHeaderByHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(ix.block.height),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$2(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetBlockHeaderByHeightRequest.apply(this, arguments);
  }

  function sendGetLatestBlockHeaderRequest(_x7, _x8, _x9) {
    return _sendGetLatestBlockHeaderRequest.apply(this, arguments);
  }

  function _sendGetLatestBlockHeaderRequest() {
    _sendGetLatestBlockHeaderRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix, context, opts) {
      var _ix$block;

      var httpRequest$1, height, res;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              height = (_ix$block = ix.block) !== null && _ix$block !== void 0 && _ix$block.isSealed ? "sealed" : "finalized";
              _context3.next = 4;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(height),
                method: "GET",
                body: null
              });

            case 4:
              res = _context3.sent;
              return _context3.abrupt("return", constructResponse$2(ix, context, res));

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetLatestBlockHeaderRequest.apply(this, arguments);
  }

  function constructResponse$2(ix, context, res) {
    var block = res.length ? res[0] : null;
    var ret = context.response();
    ret.tag = ix.tag;
    ret.blockHeader = {
      id: block.header.id,
      parentId: block.header.parent_id,
      height: Number(block.header.height),
      timestamp: block.header.timestamp
    };
    return ret;
  }

  function sendGetBlockHeader(_x10) {
    return _sendGetBlockHeader.apply(this, arguments);
  }

  function _sendGetBlockHeader() {
    _sendGetBlockHeader = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ix) {
      var context,
          opts,
          interactionHasBlockID,
          interactionHasBlockHeight,
          _args4 = arguments;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              invariant$1(opts.node, "SDK Send Get Block Header Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Block Header Error: context.response must be defined.");
              _context4.next = 6;
              return ix;

            case 6:
              ix = _context4.sent;
              interactionHasBlockID = ix.block.id !== null;
              interactionHasBlockHeight = ix.block.height !== null;

              if (!interactionHasBlockID) {
                _context4.next = 15;
                break;
              }

              _context4.next = 12;
              return sendGetBlockHeaderByIDRequest(ix, context, opts);

            case 12:
              return _context4.abrupt("return", _context4.sent);

            case 15:
              if (!interactionHasBlockHeight) {
                _context4.next = 21;
                break;
              }

              _context4.next = 18;
              return sendGetBlockHeaderByHeightRequest(ix, context, opts);

            case 18:
              return _context4.abrupt("return", _context4.sent);

            case 21:
              _context4.next = 23;
              return sendGetLatestBlockHeaderRequest(ix, context, opts);

            case 23:
              return _context4.abrupt("return", _context4.sent);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendGetBlockHeader.apply(this, arguments);
  }

  function sendGetBlockByIDRequest(_x, _x2, _x3) {
    return _sendGetBlockByIDRequest.apply(this, arguments);
  }

  function _sendGetBlockByIDRequest() {
    _sendGetBlockByIDRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks/".concat(ix.block.id, "?expand=payload"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse$1(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetBlockByIDRequest.apply(this, arguments);
  }

  function sendGetBlockByHeightRequest(_x4, _x5, _x6) {
    return _sendGetBlockByHeightRequest.apply(this, arguments);
  }

  function _sendGetBlockByHeightRequest() {
    _sendGetBlockByHeightRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(ix.block.height, "&expand=payload"),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse$1(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetBlockByHeightRequest.apply(this, arguments);
  }

  function sendGetBlockRequest(_x7, _x8, _x9) {
    return _sendGetBlockRequest.apply(this, arguments);
  }

  function _sendGetBlockRequest() {
    _sendGetBlockRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix, context, opts) {
      var _ix$block;

      var httpRequest$1, height, res;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              height = (_ix$block = ix.block) !== null && _ix$block !== void 0 && _ix$block.isSealed ? "sealed" : "final";
              _context3.next = 4;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=".concat(height, "&expand=payload"),
                method: "GET",
                body: null
              });

            case 4:
              res = _context3.sent;
              return _context3.abrupt("return", constructResponse$1(ix, context, res));

            case 6:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetBlockRequest.apply(this, arguments);
  }

  function constructResponse$1(ix, context, res) {
    var block = res.length ? res[0] : null;
    var ret = context.response();
    ret.tag = ix.tag;
    ret.block = {
      id: block.header.id,
      parentId: block.header.parent_id,
      height: Number(block.header.height),
      timestamp: block.header.timestamp,
      collectionGuarantees: block.payload.collection_guarantees.map(function (collectionGuarantee) {
        return {
          collectionId: collectionGuarantee.collection_id,
          signerIds: collectionGuarantee.signer_ids
        };
      }),
      blockSeals: block.payload.block_seals.map(function (blockSeal) {
        return {
          blockId: blockSeal.block_id,
          executionReceiptId: blockSeal.result_id
        };
      })
    };
    return ret;
  }

  function sendGetBlock(_x10) {
    return _sendGetBlock.apply(this, arguments);
  }

  function _sendGetBlock() {
    _sendGetBlock = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ix) {
      var context,
          opts,
          interactionHasBlockID,
          interactionHasBlockHeight,
          _args4 = arguments;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              opts = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};
              invariant$1(opts.node, "SDK Send Get Block Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Block Error: context.response must be defined.");
              _context4.next = 6;
              return ix;

            case 6:
              ix = _context4.sent;
              interactionHasBlockID = ix.block.id !== null;
              interactionHasBlockHeight = ix.block.height !== null;

              if (!interactionHasBlockID) {
                _context4.next = 15;
                break;
              }

              _context4.next = 12;
              return sendGetBlockByIDRequest(ix, context, opts);

            case 12:
              return _context4.abrupt("return", _context4.sent);

            case 15:
              if (!interactionHasBlockHeight) {
                _context4.next = 21;
                break;
              }

              _context4.next = 18;
              return sendGetBlockByHeightRequest(ix, context, opts);

            case 18:
              return _context4.abrupt("return", _context4.sent);

            case 21:
              _context4.next = 23;
              return sendGetBlockRequest(ix, context, opts);

            case 23:
              return _context4.abrupt("return", _context4.sent);

            case 24:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _sendGetBlock.apply(this, arguments);
  }

  function sendGetCollection(_x) {
    return _sendGetCollection.apply(this, arguments);
  }

  function _sendGetCollection() {
    _sendGetCollection = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          res,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Get Collection Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Collection Error: context.response must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 7;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/collections/".concat(ix.collection.id, "?expand=transactions"),
                method: "GET",
                body: null
              });

            case 7:
              res = _context.sent;
              ret = context.response();
              ret.tag = ix.tag;
              ret.collection = {
                id: res.id,
                transactionIds: res.transactions.map(function (transaction) {
                  return transaction.id;
                })
              };
              return _context.abrupt("return", ret);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetCollection.apply(this, arguments);
  }

  function sendGetEventsForHeightRangeRequest(_x, _x2, _x3) {
    return _sendGetEventsForHeightRangeRequest.apply(this, arguments);
  }

  function _sendGetEventsForHeightRangeRequest() {
    _sendGetEventsForHeightRangeRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/events?type=".concat(ix.events.eventType, "&start_height=").concat(ix.events.start, "&end_height=").concat(ix.events.end),
                method: "GET",
                body: null
              });

            case 3:
              res = _context.sent;
              return _context.abrupt("return", constructResponse(ix, context, res));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetEventsForHeightRangeRequest.apply(this, arguments);
  }

  function sendGetEventsForBlockIDsRequest(_x4, _x5, _x6) {
    return _sendGetEventsForBlockIDsRequest.apply(this, arguments);
  }

  function _sendGetEventsForBlockIDsRequest() {
    _sendGetEventsForBlockIDsRequest = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix, context, opts) {
      var httpRequest$1, res;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context2.next = 3;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/events?type=".concat(ix.events.eventType, "&block_ids=").concat(ix.events.blockIds.join(",")),
                method: "GET",
                body: null
              });

            case 3:
              res = _context2.sent;
              return _context2.abrupt("return", constructResponse(ix, context, res));

            case 5:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _sendGetEventsForBlockIDsRequest.apply(this, arguments);
  }

  function constructResponse(ix, context, res) {
    var ret = context.response();
    ret.tag = ix.tag;
    ret.events = [];
    res.forEach(function (block) {
      return block.events ? block.events.forEach(function (event) {
        return ret.events.push({
          blockId: block.block_id,
          blockHeight: Number(block.block_height),
          blockTimestamp: block.block_timestamp,
          type: event.type,
          transactionId: event.transaction_id,
          transactionIndex: Number(event.transaction_index),
          eventIndex: Number(event.event_index),
          payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
        });
      }) : null;
    });
    return ret;
  }

  function sendGetEvents(_x7) {
    return _sendGetEvents.apply(this, arguments);
  }

  function _sendGetEvents() {
    _sendGetEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix) {
      var context,
          opts,
          interactionContainsBlockHeightRange,
          interactionContainsBlockIDsList,
          _args3 = arguments;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              context = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};
              opts = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
              invariant$1(opts.node, "SDK Send Get Events Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Events Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Get Events Error: context.Buffer must be defined.");
              _context3.next = 7;
              return ix;

            case 7:
              ix = _context3.sent;
              interactionContainsBlockHeightRange = ix.events.start !== null;
              interactionContainsBlockIDsList = Array.isArray(ix.events.blockIds) && ix.events.blockIds.length > 0;
              invariant$1(interactionContainsBlockHeightRange || interactionContainsBlockIDsList, "SendGetEventsError: Unable to determine which get events request to send. Either a block height range, or block IDs must be specified.");

              if (!interactionContainsBlockHeightRange) {
                _context3.next = 17;
                break;
              }

              _context3.next = 14;
              return sendGetEventsForHeightRangeRequest(ix, context, opts);

            case 14:
              return _context3.abrupt("return", _context3.sent);

            case 17:
              _context3.next = 19;
              return sendGetEventsForBlockIDsRequest(ix, context, opts);

            case 19:
              return _context3.abrupt("return", _context3.sent);

            case 20:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _sendGetEvents.apply(this, arguments);
  }

  function sendGetTransaction(_x) {
    return _sendGetTransaction.apply(this, arguments);
  }

  function _sendGetTransaction() {
    _sendGetTransaction = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          res,
          unwrapKey,
          unwrapSignature,
          unwrapArg,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Get Transaction Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Transaction Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Get Transaction Error: context.Buffer must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 8;
              return ix;

            case 8:
              ix = _context.sent;
              _context.next = 11;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/transactions/".concat(ix.transaction.id),
                method: "GET",
                body: null
              });

            case 11:
              res = _context.sent;

              unwrapKey = function unwrapKey(key) {
                return {
                  address: key.address,
                  keyId: Number(key.key_id),
                  sequenceNumber: Number(key.sequence_number)
                };
              };

              unwrapSignature = function unwrapSignature(sig) {
                return {
                  address: sig.address,
                  keyId: Number(sig.key_index),
                  signature: sig.signature
                };
              };

              unwrapArg = function unwrapArg(arg) {
                return JSON.parse(context.Buffer.from(arg, "base64").toString());
              };

              ret = context.response();
              ret.tag = ix.tag;
              ret.transaction = {
                script: context.Buffer.from(res.script, "base64").toString(),
                args: _toConsumableArray(res.arguments.map(unwrapArg)),
                referenceBlockId: res.reference_block_id,
                gasLimit: Number(res.gas_limit),
                payer: res.payer,
                proposalKey: res.proposal_key ? unwrapKey(res.proposal_key) : res.proposal_key,
                authorizers: res.authorizers,
                payloadSignatures: _toConsumableArray(res.payload_signatures.map(unwrapSignature)),
                envelopeSignatures: _toConsumableArray(res.envelope_signatures.map(unwrapSignature))
              };
              return _context.abrupt("return", ret);

            case 19:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetTransaction.apply(this, arguments);
  }

  var STATUS_MAP = {
    UNKNOWN: 0,
    PENDING: 1,
    FINALIZED: 2,
    EXECUTED: 3,
    SEALED: 4,
    EXPIRED: 5
  };

  function sendGetTransactionStatus(_x) {
    return _sendGetTransactionStatus.apply(this, arguments);
  }

  function _sendGetTransactionStatus() {
    _sendGetTransactionStatus = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          res,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Get Transaction Status Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Get Transaction Status Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Get Transaction Status Error: context.Buffer must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 8;
              return ix;

            case 8:
              ix = _context.sent;
              _context.next = 11;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/transaction_results/".concat(ix.transaction.id),
                method: "GET",
                body: null
              });

            case 11:
              res = _context.sent;
              ret = context.response();
              ret.tag = ix.tag;
              ret.transactionStatus = {
                blockId: res.block_id,
                status: STATUS_MAP[res.status.toUpperCase()] || "",
                statusString: res.status.toUpperCase(),
                statusCode: res.status_code,
                errorMessage: res.error_message,
                events: res.events.map(function (event) {
                  return {
                    type: event.type,
                    transactionId: event.transaction_id,
                    transactionIndex: Number(event.transaction_index),
                    eventIndex: Number(event.event_index),
                    payload: JSON.parse(context.Buffer.from(event.payload, "base64").toString())
                  };
                })
              };
              return _context.abrupt("return", ret);

            case 16:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendGetTransactionStatus.apply(this, arguments);
  }

  function sendPing(_x) {
    return _sendPing.apply(this, arguments);
  }

  function _sendPing() {
    _sendPing = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          ret,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Ping Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Ping Error: context.response must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 7;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/blocks?height=sealed",
                method: "GET",
                body: null
              });

            case 7:
              ret = context.response();
              ret.tag = ix.tag;
              return _context.abrupt("return", ret);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _sendPing.apply(this, arguments);
  }

  var idof = function idof(acct) {
    return "".concat(withPrefix(acct.addr), "-").concat(acct.keyId);
  };

  function sendTransaction(_x) {
    return _sendTransaction.apply(this, arguments);
  }

  function _sendTransaction() {
    _sendTransaction = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          httpRequest$1,
          payloadSignatures,
          _i,
          _Object$values,
          acct,
          envelopeSignatures,
          _i2,
          _Object$values2,
          _acct,
          id,
          t1,
          res,
          t2,
          ret,
          _args = arguments;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Transaction Error: opts.node must be defined.");
              invariant$1(context.response, "SDK Send Transaction Error: context.response must be defined.");
              invariant$1(context.Buffer, "SDK Send Transaction Error: context.Buffer must be defined.");
              httpRequest$1 = opts.httpRequest || httpRequest;
              _context.next = 8;
              return ix;

            case 8:
              ix = _context.sent; // Apply Non Payer Signatures to Payload Signatures

              payloadSignatures = [];
              _i = 0, _Object$values = Object.values(ix.accounts);

            case 11:
              if (!(_i < _Object$values.length)) {
                _context.next = 24;
                break;
              }

              acct = _Object$values[_i];
              _context.prev = 13;

              if (!acct.role.payer && acct.signature != null) {
                payloadSignatures.push({
                  address: sansPrefix(acct.addr),
                  key_index: String(acct.keyId),
                  signature: context.Buffer.from(acct.signature, "hex").toString("base64")
                });
              }

              _context.next = 21;
              break;

            case 17:
              _context.prev = 17;
              _context.t0 = _context["catch"](13);
              console.error("SDK HTTP Send Error: Trouble applying payload signature", {
                acct: acct,
                ix: ix
              });
              throw _context.t0;

            case 21:
              _i++;
              _context.next = 11;
              break;

            case 24:
              // Apply Payer Signatures to Envelope Signatures
              envelopeSignatures = {};
              _i2 = 0, _Object$values2 = Object.values(ix.accounts);

            case 26:
              if (!(_i2 < _Object$values2.length)) {
                _context.next = 39;
                break;
              }

              _acct = _Object$values2[_i2];
              _context.prev = 28;

              if (_acct.role.payer && _acct.signature != null) {
                id = _acct.tempId || idof(_acct);
                envelopeSignatures[id] = envelopeSignatures[id] || {
                  address: sansPrefix(_acct.addr),
                  key_index: String(_acct.keyId),
                  signature: context.Buffer.from(_acct.signature, "hex").toString("base64")
                };
              }

              _context.next = 36;
              break;

            case 32:
              _context.prev = 32;
              _context.t1 = _context["catch"](28);
              console.error("SDK HTTP Send Error: Trouble applying envelope signature", {
                acct: _acct,
                ix: ix
              });
              throw _context.t1;

            case 36:
              _i2++;
              _context.next = 26;
              break;

            case 39:
              envelopeSignatures = Object.values(envelopeSignatures);
              t1 = Date.now();
              _context.next = 43;
              return httpRequest$1({
                hostname: opts.node,
                path: "/v1/transactions",
                method: "POST",
                body: {
                  script: context.Buffer.from(ix.message.cadence).toString("base64"),
                  arguments: _toConsumableArray(ix.message.arguments.map(function (arg) {
                    return context.Buffer.from(JSON.stringify(ix.arguments[arg].asArgument)).toString("base64");
                  })),
                  reference_block_id: ix.message.refBlock ? ix.message.refBlock : null,
                  gas_limit: String(ix.message.computeLimit),
                  payer: sansPrefix(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
                  proposal_key: {
                    address: sansPrefix(ix.accounts[ix.proposer].addr),
                    key_index: String(ix.accounts[ix.proposer].keyId),
                    sequence_number: String(ix.accounts[ix.proposer].sequenceNum)
                  },
                  authorizers: ix.authorizations.map(function (tempId) {
                    return ix.accounts[tempId].addr;
                  }).reduce(function (prev, current) {
                    return prev.find(function (item) {
                      return item === current;
                    }) ? prev : [].concat(_toConsumableArray(prev), [current]);
                  }, []).map(sansPrefix),
                  payload_signatures: payloadSignatures,
                  envelope_signatures: envelopeSignatures
                }
              });

            case 43:
              res = _context.sent;
              t2 = Date.now();
              ret = context.response();
              ret.tag = ix.tag;
              ret.transactionId = res.id;

              if (typeof window !== "undefined") {
                window.dispatchEvent(new CustomEvent("FLOW::TX", {
                  detail: {
                    txId: ret.transactionId,
                    delta: t2 - t1
                  }
                }));
              }

              return _context.abrupt("return", ret);

            case 50:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[13, 17], [28, 32]]);
    }));
    return _sendTransaction.apply(this, arguments);
  }

  var send$1 = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var context,
          opts,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              context = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              invariant$1(opts.node, "SDK Send Error: Either opts.node or \"accessNode.api\" in config must be defined.");
              invariant$1(context.ix, "SDK Send Error: context.ix must be defined.");
              _context.next = 6;
              return ix;

            case 6:
              ix = _context.sent;
              _context.t0 = true;
              _context.next = _context.t0 === context.ix.isTransaction(ix) ? 10 : _context.t0 === context.ix.isGetTransactionStatus(ix) ? 11 : _context.t0 === context.ix.isGetTransaction(ix) ? 12 : _context.t0 === context.ix.isScript(ix) ? 13 : _context.t0 === context.ix.isGetAccount(ix) ? 14 : _context.t0 === context.ix.isGetEvents(ix) ? 15 : _context.t0 === context.ix.isGetBlock(ix) ? 16 : _context.t0 === context.ix.isGetBlockHeader(ix) ? 17 : _context.t0 === context.ix.isGetCollection(ix) ? 18 : _context.t0 === context.ix.isPing(ix) ? 19 : 20;
              break;

            case 10:
              return _context.abrupt("return", opts.sendTransaction ? opts.sendTransaction(ix, context, opts) : sendTransaction(ix, context, opts));

            case 11:
              return _context.abrupt("return", opts.sendGetTransactionStatus ? opts.sendGetTransactionStatus(ix, context, opts) : sendGetTransactionStatus(ix, context, opts));

            case 12:
              return _context.abrupt("return", opts.sendGetTransaction ? opts.sendGetTransaction(ix, context, opts) : sendGetTransaction(ix, context, opts));

            case 13:
              return _context.abrupt("return", opts.sendExecuteScript ? opts.sendExecuteScript(ix, context, opts) : sendExecuteScript(ix, context, opts));

            case 14:
              return _context.abrupt("return", opts.sendGetAccount ? opts.sendGetAccount(ix, context, opts) : sendGetAccount(ix, context, opts));

            case 15:
              return _context.abrupt("return", opts.sendGetEvents ? opts.sendGetEvents(ix, context, opts) : sendGetEvents(ix, context, opts));

            case 16:
              return _context.abrupt("return", opts.sendGetBlock ? opts.sendGetBlock(ix, context, opts) : sendGetBlock(ix, context, opts));

            case 17:
              return _context.abrupt("return", opts.sendGetBlockHeader ? opts.sendGetBlockHeader(ix, context, opts) : sendGetBlockHeader(ix, context, opts));

            case 18:
              return _context.abrupt("return", opts.sendGetCollection ? opts.sendGetCollection(ix, context, opts) : sendGetCollection(ix, context, opts));

            case 19:
              return _context.abrupt("return", opts.sendPing ? opts.sendPing(ix, context, opts) : sendPing(ix, context, opts));

            case 20:
              return _context.abrupt("return", ix);

            case 21:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function send(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var sha3$1 = {};

  var sponge$1 = {};

  var permute$1 = {};

  var chi$1 = {};

  var copy$3 = function copy(I, i) {
    return function (O, o) {
      var oi = o * 2;
      var ii = i * 2;
      O[oi] = I[ii];
      O[oi + 1] = I[ii + 1];
    };
  };

  var copy_1$1 = copy$3;

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _copy = _interopRequireDefault(copy_1$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var chi = function chi(_ref) {
      var A = _ref.A,
          C = _ref.C;

      for (var y = 0; y < 25; y += 5) {
        for (var x = 0; x < 5; x++) {
          (0, _copy["default"])(A, y + x)(C, x);
        }

        for (var _x = 0; _x < 5; _x++) {
          var xy = (y + _x) * 2;
          var x1 = (_x + 1) % 5 * 2;
          var x2 = (_x + 2) % 5 * 2;
          A[xy] ^= ~C[x1] & C[x2];
          A[xy + 1] ^= ~C[x1 + 1] & C[x2 + 1];
        }
      }
    };

    var _default = chi;
    exports["default"] = _default;
  })(chi$1);

  var iota$1 = {};

  var roundConstants$1 = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var ROUND_CONSTANTS = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);
    var _default = ROUND_CONSTANTS;
    exports["default"] = _default;
  })(roundConstants$1);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _roundConstants = _interopRequireDefault(roundConstants$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var iota = function iota(_ref) {
      var A = _ref.A,
          roundIndex = _ref.roundIndex;
      var i = roundIndex * 2;
      A[0] ^= _roundConstants["default"][i];
      A[1] ^= _roundConstants["default"][i + 1];
    };

    var _default = iota;
    exports["default"] = _default;
  })(iota$1);

  var rhoPi$1 = {};

  var piShuffles$1 = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var PI_SHUFFLES = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];
    var _default = PI_SHUFFLES;
    exports["default"] = _default;
  })(piShuffles$1);

  var rhoOffsets$1 = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var RHO_OFFSETS = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];
    var _default = RHO_OFFSETS;
    exports["default"] = _default;
  })(rhoOffsets$1);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _piShuffles = _interopRequireDefault(piShuffles$1);

    var _rhoOffsets = _interopRequireDefault(rhoOffsets$1);

    var _copy = _interopRequireDefault(copy_1$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var rhoPi = function rhoPi(_ref) {
      var A = _ref.A,
          C = _ref.C,
          W = _ref.W;
      (0, _copy["default"])(A, 1)(W, 0);
      var H = 0;
      var L = 0;
      var Wi = 0;
      var ri = 32;

      for (var i = 0; i < 24; i++) {
        var j = _piShuffles["default"][i];
        var r = _rhoOffsets["default"][i];
        (0, _copy["default"])(A, j)(C, 0);
        H = W[0];
        L = W[1];
        ri = 32 - r;
        Wi = r < 32 ? 0 : 1;
        W[Wi] = H << r | L >>> ri;
        W[(Wi + 1) % 2] = L << r | H >>> ri;
        (0, _copy["default"])(W, 0)(A, j);
        (0, _copy["default"])(C, 0)(W, 0);
      }
    };

    var _default = rhoPi;
    exports["default"] = _default;
  })(rhoPi$1);

  var theta$1 = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _copy = _interopRequireDefault(copy_1$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var theta = function theta(_ref) {
      var A = _ref.A,
          C = _ref.C,
          D = _ref.D,
          W = _ref.W;
      var H = 0;
      var L = 0;

      for (var x = 0; x < 5; x++) {
        var x20 = x * 2;
        var x21 = (x + 5) * 2;
        var x22 = (x + 10) * 2;
        var x23 = (x + 15) * 2;
        var x24 = (x + 20) * 2;
        C[x20] = A[x20] ^ A[x21] ^ A[x22] ^ A[x23] ^ A[x24];
        C[x20 + 1] = A[x20 + 1] ^ A[x21 + 1] ^ A[x22 + 1] ^ A[x23 + 1] ^ A[x24 + 1];
      }

      for (var _x = 0; _x < 5; _x++) {
        (0, _copy["default"])(C, (_x + 1) % 5)(W, 0);
        H = W[0];
        L = W[1];
        W[0] = H << 1 | L >>> 31;
        W[1] = L << 1 | H >>> 31;
        D[_x * 2] = C[(_x + 4) % 5 * 2] ^ W[0];
        D[_x * 2 + 1] = C[(_x + 4) % 5 * 2 + 1] ^ W[1];

        for (var y = 0; y < 25; y += 5) {
          A[(y + _x) * 2] ^= D[_x * 2];
          A[(y + _x) * 2 + 1] ^= D[_x * 2 + 1];
        }
      }
    };

    var _default = theta;
    exports["default"] = _default;
  })(theta$1);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _chi = _interopRequireDefault(chi$1);

    var _iota = _interopRequireDefault(iota$1);

    var _rhoPi = _interopRequireDefault(rhoPi$1);

    var _theta = _interopRequireDefault(theta$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var permute = function permute() {
      var C = new Uint32Array(10);
      var D = new Uint32Array(10);
      var W = new Uint32Array(2);
      return function (A) {
        for (var roundIndex = 0; roundIndex < 24; roundIndex++) {
          (0, _theta["default"])({
            A: A,
            C: C,
            D: D,
            W: W
          });
          (0, _rhoPi["default"])({
            A: A,
            C: C,
            W: W
          });
          (0, _chi["default"])({
            A: A,
            C: C
          });
          (0, _iota["default"])({
            A: A,
            roundIndex: roundIndex
          });
        }

        C.fill(0);
        D.fill(0);
        W.fill(0);
      };
    };

    var _default = permute;
    exports["default"] = _default;
  })(permute$1);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _buffer = buffer$1;

    var _permute = _interopRequireDefault(permute$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var xorWords = function xorWords(I, O) {
      for (var i = 0; i < I.length; i += 8) {
        var o = i / 4;
        O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];
        O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];
      }

      return O;
    };

    var readWords = function readWords(I, O) {
      for (var o = 0; o < O.length; o += 8) {
        var i = o / 4;
        O[o] = I[i + 1];
        O[o + 1] = I[i + 1] >>> 8;
        O[o + 2] = I[i + 1] >>> 16;
        O[o + 3] = I[i + 1] >>> 24;
        O[o + 4] = I[i];
        O[o + 5] = I[i] >>> 8;
        O[o + 6] = I[i] >>> 16;
        O[o + 7] = I[i] >>> 24;
      }

      return O;
    };

    var Sponge = function Sponge(_ref) {
      var _this = this;

      var capacity = _ref.capacity,
          padding = _ref.padding;
      var keccak = (0, _permute["default"])();
      var stateSize = 200;
      var blockSize = capacity / 8;
      var queueSize = stateSize - capacity / 4;
      var queueOffset = 0;
      var state = new Uint32Array(stateSize / 4);

      var queue = _buffer.Buffer.allocUnsafe(queueSize);

      this.absorb = function (buffer) {
        for (var i = 0; i < buffer.length; i++) {
          queue[queueOffset] = buffer[i];
          queueOffset += 1;

          if (queueOffset >= queueSize) {
            xorWords(queue, state);
            keccak(state);
            queueOffset = 0;
          }
        }

        return _this;
      };

      this.squeeze = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var output = {
          buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize),
          padding: options.padding || padding,
          queue: _buffer.Buffer.allocUnsafe(queue.length),
          state: new Uint32Array(state.length)
        };
        queue.copy(output.queue);

        for (var i = 0; i < state.length; i++) {
          output.state[i] = state[i];
        }

        output.queue.fill(0, queueOffset);
        output.queue[queueOffset] |= output.padding;
        output.queue[queueSize - 1] |= 128;
        xorWords(output.queue, output.state);

        for (var offset = 0; offset < output.buffer.length; offset += queueSize) {
          keccak(output.state);
          readWords(output.state, output.buffer.slice(offset, offset + queueSize));
        }

        return output.buffer;
      };

      this.reset = function () {
        queue.fill(0);
        state.fill(0);
        queueOffset = 0;
        return _this;
      };

      return this;
    };

    var _default = Sponge;
    exports["default"] = _default;
  })(sponge$1);

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = exports.SHAKE = exports.SHA3Hash = exports.SHA3 = exports.Keccak = void 0;
    var _buffer = buffer$1;

    var _sponge = _interopRequireDefault(sponge$1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var createHash = function createHash(_ref) {
      var allowedSizes = _ref.allowedSizes,
          defaultSize = _ref.defaultSize,
          padding = _ref.padding;
      return function Hash() {
        var _this = this;

        var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSize;

        if (!this || this.constructor !== Hash) {
          return new Hash(size);
        }

        if (allowedSizes && !allowedSizes.includes(size)) {
          throw new Error("Unsupported hash length");
        }

        var sponge = new _sponge["default"]({
          capacity: size
        });

        this.update = function (input) {
          var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";

          if (_buffer.Buffer.isBuffer(input)) {
            sponge.absorb(input);
            return _this;
          }

          if (typeof input === "string") {
            return _this.update(_buffer.Buffer.from(input, encoding));
          }

          throw new TypeError("Not a string or buffer");
        };

        this.digest = function () {
          var formatOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "binary";
          var options = typeof formatOrOptions === "string" ? {
            format: formatOrOptions
          } : formatOrOptions;
          var buffer = sponge.squeeze({
            buffer: options.buffer,
            padding: options.padding || padding
          });

          if (options.format && options.format !== "binary") {
            return buffer.toString(options.format);
          }

          return buffer;
        };

        this.reset = function () {
          sponge.reset();
          return _this;
        };

        return this;
      };
    };

    var Keccak = createHash({
      allowedSizes: [224, 256, 384, 512],
      defaultSize: 512,
      padding: 1
    });
    exports.Keccak = Keccak;
    var SHA3 = createHash({
      allowedSizes: [224, 256, 384, 512],
      defaultSize: 512,
      padding: 6
    });
    exports.SHA3 = SHA3;
    var SHAKE = createHash({
      allowedSizes: [128, 256],
      defaultSize: 256,
      padding: 31
    });
    exports.SHAKE = SHAKE;
    var SHA3Hash = Keccak;
    exports.SHA3Hash = SHA3Hash;
    SHA3.SHA3Hash = SHA3Hash;
    var _default = SHA3;
    exports["default"] = _default;
  })(sha3$1);

  function interleave() {
    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    if (!a.length && !b.length) return c;
    if (!a.length) return c;
    if (!b.length) return [].concat(_toConsumableArray(c), [a[0]]);

    var _a = _toArray(a),
        aHead = _a[0],
        aRest = _a.slice(1);

    var _b = _toArray(b),
        bHead = _b[0],
        bRest = _b.slice(1);

    if (aHead !== undefined) c.push(aHead);
    if (bHead !== undefined) c.push(bHead);
    return interleave(aRest, bRest, c);
  }

  function recApply(d) {
    return function (arg1) {
      if (typeof arg1 === "function") {
        log.deprecate({
          pkg: "FCL/SDK",
          subject: "Interopolation of functions into template literals",
          transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0001-deprecate-params"
        });
        return recApply(d)(arg1(d));
      }

      return String(arg1);
    };
  }

  function template(head) {
    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    if (typeof head === "string") return function () {
      return head;
    };

    if (Array.isArray(head)) {
      return function (d) {
        return interleave(head, rest.map(recApply(d))).join("").trim();
      };
    }

    return head;
  }

  var UNKNOWN
  /*                       */
  = "UNKNOWN";
  var SCRIPT
  /*                        */
  = "SCRIPT";
  var TRANSACTION
  /*                   */
  = "TRANSACTION";
  var GET_TRANSACTION_STATUS
  /*        */
  = "GET_TRANSACTION_STATUS";
  var GET_ACCOUNT
  /*                   */
  = "GET_ACCOUNT";
  var GET_EVENTS
  /*                    */
  = "GET_EVENTS";
  var PING
  /*                          */
  = "PING";
  var GET_TRANSACTION
  /*               */
  = "GET_TRANSACTION";
  var GET_BLOCK
  /*                     */
  = "GET_BLOCK";
  var GET_BLOCK_HEADER
  /*              */
  = "GET_BLOCK_HEADER";
  var GET_COLLECTION
  /*                */
  = "GET_COLLECTION";
  var BAD
  /* */
  = "BAD";
  var OK
  /*  */
  = "OK";
  var ACCOUNT
  /*  */
  = "ACCOUNT";
  var PARAM
  /*    */
  = "PARAM";
  var ARGUMENT
  /* */
  = "ARGUMENT";
  var AUTHORIZER
  /* */
  = "authorizer";
  var PAYER
  /*      */
  = "payer";
  var PROPOSER
  /*   */
  = "proposer";
  var ACCT = "{\n  \"kind\":\"".concat(ACCOUNT, "\",\n  \"tempId\":null,\n  \"addr\":null,\n  \"keyId\":null,\n  \"sequenceNum\":null,\n  \"signature\":null,\n  \"signingFunction\":null,\n  \"resolve\":null,\n  \"role\": {\n    \"proposer\":false,\n    \"authorizer\":false,\n    \"payer\":false,\n    \"param\":false\n  }\n}");
  var ARG = "{\n  \"kind\":\"".concat(ARGUMENT, "\",\n  \"tempId\":null,\n  \"value\":null,\n  \"asArgument\":null,\n  \"xform\":null,\n  \"resolve\": null,\n  \"resolveArgument\": null\n}");
  var IX = "{\n  \"tag\":\"".concat(UNKNOWN, "\",\n  \"assigns\":{},\n  \"status\":\"").concat(OK, "\",\n  \"reason\":null,\n  \"accounts\":{},\n  \"params\":{},\n  \"arguments\":{},\n  \"message\": {\n    \"cadence\":null,\n    \"refBlock\":null,\n    \"computeLimit\":null,\n    \"proposer\":null,\n    \"payer\":null,\n    \"authorizations\":[],\n    \"params\":[],\n    \"arguments\":[]\n  },\n  \"proposer\":null,\n  \"authorizations\":[],\n  \"payer\":[],\n  \"events\": {\n    \"eventType\":null,\n    \"start\":null,\n    \"end\":null,\n    \"blockIds\":[]\n  },\n  \"transaction\": {\n    \"id\":null\n  },\n  \"block\": {\n    \"id\":null,\n    \"height\":null,\n    \"isSealed\":null\n  },\n  \"account\": {\n    \"addr\":null\n  },\n  \"collection\": {\n    \"id\":null\n  }\n}");
  var KEYS = new Set(Object.keys(JSON.parse(IX)));

  var interaction = function interaction() {
    return JSON.parse(IX);
  };

  var CHARS = "abcdefghijklmnopqrstuvwxyz0123456789".split("");

  var randChar = function randChar() {
    return CHARS[~~(Math.random() * CHARS.length)];
  };

  var uuid = function uuid() {
    return Array.from({
      length: 10
    }, randChar).join("");
  };

  var isNumber$1 = function isNumber(d) {
    return typeof d === "number";
  };

  var isArray$1$1 = function isArray(d) {
    return Array.isArray(d);
  };

  var isObj$1 = function isObj(d) {
    return d !== null && _typeof$1(d) === "object";
  };

  var isNull$1 = function isNull(d) {
    return d == null;
  };

  var isFn$3 = function isFn(d) {
    return typeof d === "function";
  };

  var isInteraction = function isInteraction(ix) {
    if (!isObj$1(ix) || isNull$1(ix) || isNumber$1(ix)) return false;

    var _iterator = _createForOfIteratorHelper(KEYS),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var key = _step.value;
        if (!ix.hasOwnProperty(key)) return false;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  };

  var Ok = function Ok(ix) {
    ix.status = OK;
    return ix;
  };

  var Bad = function Bad(ix, reason) {
    ix.status = BAD;
    ix.reason = reason;
    return ix;
  };

  var makeIx = function makeIx(wat) {
    return function (ix) {
      ix.tag = wat;
      return Ok(ix);
    };
  };

  var prepAccountKeyId = function prepAccountKeyId(acct) {
    if (acct.keyId == null) return acct;
    invariant$1(!isNaN(parseInt(acct.keyId)), "account.keyId must be an integer");
    return _objectSpread2(_objectSpread2({}, acct), {}, {
      keyId: parseInt(acct.keyId)
    });
  };

  var prepAccount = function prepAccount(acct) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return function (ix) {
      invariant$1(typeof acct === "function" || _typeof$1(acct) === "object", "prepAccount must be passed an authorization function or an account object");
      invariant$1(opts.role != null, "Account must have a role");
      var ACCOUNT = JSON.parse(ACCT);
      var role = opts.role;
      var tempId = uuid();
      if (acct.authorization && isFn$3(acct.authorization)) acct = {
        resolve: acct.authorization
      };
      if (!acct.authorization && isFn$3(acct)) acct = {
        resolve: acct
      };
      var resolve = acct.resolve;
      if (resolve) acct.resolve = function (acct) {
        for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }

        return [resolve, prepAccountKeyId].reduce( /*#__PURE__*/function () {
          var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(d, fn) {
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.t0 = fn;
                    _context.t1 = void 0;
                    _context.next = 4;
                    return d;

                  case 4:
                    _context.t2 = _context.sent;
                    _context.t3 = [_context.t2].concat(rest);
                    return _context.abrupt("return", _context.t0.apply.call(_context.t0, _context.t1, _context.t3));

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          return function (_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }(), acct);
      };
      acct = prepAccountKeyId(acct);
      ix.accounts[tempId] = _objectSpread2(_objectSpread2(_objectSpread2({}, ACCOUNT), {}, {
        tempId: tempId
      }, acct), {}, {
        role: _objectSpread2(_objectSpread2(_objectSpread2({}, ACCOUNT.role), _typeof$1(acct.role) === "object" ? acct.role : {}), {}, _defineProperty({}, role, true))
      });

      if (role === AUTHORIZER) {
        ix.authorizations.push(tempId);
      } else if (role === PAYER) {
        ix.payer.push(tempId);
      } else {
        ix[role] = tempId;
      }

      return ix;
    };
  };

  var makeArgument = function makeArgument(arg) {
    return function (ix) {
      var tempId = uuid();
      ix.message.arguments.push(tempId);
      ix.arguments[tempId] = JSON.parse(ARG);
      ix.arguments[tempId].tempId = tempId;
      ix.arguments[tempId].value = arg.value;
      ix.arguments[tempId].asArgument = arg.asArgument;
      ix.arguments[tempId].xform = arg.xform;
      ix.arguments[tempId].resolve = arg.resolve;
      ix.arguments[tempId].resolveArgument = isFn$3(arg.resolveArgument) ? arg.resolveArgument.bind(arg) : arg.resolveArgument;
      return Ok(ix);
    };
  };

  var makeUnknown
  /*                 */
  = makeIx(UNKNOWN);
  var makeScript
  /*                  */
  = makeIx(SCRIPT);
  var makeTransaction
  /*             */
  = makeIx(TRANSACTION);
  var makeGetTransactionStatus
  /*    */
  = makeIx(GET_TRANSACTION_STATUS);
  var makeGetTransaction
  /*          */
  = makeIx(GET_TRANSACTION);
  var makeGetAccount
  /*              */
  = makeIx(GET_ACCOUNT);
  var makeGetEvents
  /*               */
  = makeIx(GET_EVENTS);
  var makePing
  /*                    */
  = makeIx(PING);
  var makeGetBlock
  /*                */
  = makeIx(GET_BLOCK);
  var makeGetBlockHeader
  /*          */
  = makeIx(GET_BLOCK_HEADER);
  var makeGetCollection
  /*           */
  = makeIx(GET_COLLECTION);

  var is$2 = function is(wat) {
    return function (ix) {
      return ix.tag === wat;
    };
  };

  var isUnknown
  /*                 */
  = is$2(UNKNOWN);
  var isScript
  /*                  */
  = is$2(SCRIPT);
  var isTransaction
  /*             */
  = is$2(TRANSACTION);
  var isGetTransactionStatus
  /*    */
  = is$2(GET_TRANSACTION_STATUS);
  var isGetTransaction
  /*          */
  = is$2(GET_TRANSACTION);
  var isGetAccount
  /*              */
  = is$2(GET_ACCOUNT);
  var isGetEvents
  /*               */
  = is$2(GET_EVENTS);
  var isPing
  /*                    */
  = is$2(PING);
  var isGetBlock
  /*                */
  = is$2(GET_BLOCK);
  var isGetBlockHeader
  /*          */
  = is$2(GET_BLOCK_HEADER);
  var isGetCollection
  /*           */
  = is$2(GET_COLLECTION);

  var isOk
  /*  */
  = function isOk
  /*  */
  (ix) {
    return ix.status === OK;
  };

  var isBad
  /* */
  = function isBad
  /* */
  (ix) {
    return ix.status === BAD;
  };

  var why
  /*   */
  = function why
  /*   */
  (ix) {
    return ix.reason;
  };

  var isAccount
  /*  */
  = function isAccount
  /*  */
  (account) {
    return account.kind === ACCOUNT;
  };

  var isParam
  /*    */
  = function isParam
  /*    */
  (param) {
    return param.kind === PARAM;
  };

  var isArgument
  /* */
  = function isArgument
  /* */
  (argument) {
    return argument.kind === ARGUMENT;
  };

  var hardMode = function hardMode(ix) {
    for (var _i = 0, _Object$keys = Object.keys(ix); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      if (!KEYS.has(key)) throw new Error("\"".concat(key, "\" is an invalid root level Interaction property."));
    }

    return ix;
  };

  var recPipe = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      var fns,
          _fns,
          hd,
          rest,
          cur,
          _args2 = arguments;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              fns = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : [];
              _context2.prev = 1;
              _context2.t0 = hardMode;
              _context2.next = 5;
              return ix;

            case 5:
              _context2.t1 = _context2.sent;
              ix = (0, _context2.t0)(_context2.t1);

              if (!isBad(ix)) {
                _context2.next = 9;
                break;
              }

              throw new Error("Interaction Error: ".concat(ix.reason));

            case 9:
              if (fns.length) {
                _context2.next = 11;
                break;
              }

              return _context2.abrupt("return", ix);

            case 11:
              _fns = _toArray(fns), hd = _fns[0], rest = _fns.slice(1);
              _context2.next = 14;
              return hd;

            case 14:
              cur = _context2.sent;

              if (!isFn$3(cur)) {
                _context2.next = 17;
                break;
              }

              return _context2.abrupt("return", recPipe(cur(ix), rest));

            case 17:
              if (!(isNull$1(cur) || !cur)) {
                _context2.next = 19;
                break;
              }

              return _context2.abrupt("return", recPipe(ix, rest));

            case 19:
              if (!isInteraction(cur)) {
                _context2.next = 21;
                break;
              }

              return _context2.abrupt("return", recPipe(cur, rest));

            case 21:
              throw new Error("Invalid Interaction Composition");

            case 24:
              _context2.prev = 24;
              _context2.t2 = _context2["catch"](1);
              throw _context2.t2;

            case 27:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[1, 24]]);
    }));

    return function recPipe(_x3) {
      return _ref2.apply(this, arguments);
    };
  }();

  var pipe = function pipe() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var arg1 = args[0],
        arg2 = args[1];
    if (isArray$1$1(arg1) && arg2 == null) return function (d) {
      return pipe(d, arg1);
    };
    return recPipe(arg1, arg2);
  };

  var identity$1$1 = function identity(v) {
    return v;
  };

  var get = function get(ix, key, fallback) {
    return ix.assigns[key] == null ? fallback : ix.assigns[key];
  };

  var put = function put(key, value) {
    return function (ix) {
      ix.assigns[key] = value;
      return Ok(ix);
    };
  };

  var update = function update(key) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$1$1;
    return function (ix) {
      ix.assigns[key] = fn(ix.assigns[key], ix);
      return Ok(ix);
    };
  };

  var destroy = function destroy(key) {
    return function (ix) {
      delete ix.assigns[key];
      return Ok(ix);
    };
  };

  var ixModule = /*#__PURE__*/Object.freeze({
    __proto__: null,
    UNKNOWN: UNKNOWN,
    SCRIPT: SCRIPT,
    TRANSACTION: TRANSACTION,
    GET_TRANSACTION_STATUS: GET_TRANSACTION_STATUS,
    GET_ACCOUNT: GET_ACCOUNT,
    GET_EVENTS: GET_EVENTS,
    PING: PING,
    GET_TRANSACTION: GET_TRANSACTION,
    GET_BLOCK: GET_BLOCK,
    GET_BLOCK_HEADER: GET_BLOCK_HEADER,
    GET_COLLECTION: GET_COLLECTION,
    BAD: BAD,
    OK: OK,
    ACCOUNT: ACCOUNT,
    PARAM: PARAM,
    ARGUMENT: ARGUMENT,
    AUTHORIZER: AUTHORIZER,
    PAYER: PAYER,
    PROPOSER: PROPOSER,
    interaction: interaction,
    uuid: uuid,
    isNumber: isNumber$1,
    isArray: isArray$1$1,
    isObj: isObj$1,
    isNull: isNull$1,
    isFn: isFn$3,
    isInteraction: isInteraction,
    Ok: Ok,
    Bad: Bad,
    prepAccount: prepAccount,
    makeArgument: makeArgument,
    makeUnknown: makeUnknown,
    makeScript: makeScript,
    makeTransaction: makeTransaction,
    makeGetTransactionStatus: makeGetTransactionStatus,
    makeGetTransaction: makeGetTransaction,
    makeGetAccount: makeGetAccount,
    makeGetEvents: makeGetEvents,
    makePing: makePing,
    makeGetBlock: makeGetBlock,
    makeGetBlockHeader: makeGetBlockHeader,
    makeGetCollection: makeGetCollection,
    isUnknown: isUnknown,
    isScript: isScript,
    isTransaction: isTransaction,
    isGetTransactionStatus: isGetTransactionStatus,
    isGetTransaction: isGetTransaction,
    isGetAccount: isGetAccount,
    isGetEvents: isGetEvents,
    isPing: isPing,
    isGetBlock: isGetBlock,
    isGetBlockHeader: isGetBlockHeader,
    isGetCollection: isGetCollection,
    isOk: isOk,
    isBad: isBad,
    why: why,
    isAccount: isAccount,
    isParam: isParam,
    isArgument: isArgument,
    pipe: pipe,
    get: get,
    put: put,
    update: update,
    destroy: destroy
  });

  function build() {
    var fns = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return pipe(interaction(), fns);
  }

  var DEFAULT_RESPONSE = "{\n    \"tag\":null,\n    \"transaction\":null,\n    \"transactionStatus\":null,\n    \"transactionId\":null,\n    \"encodedData\":null,\n    \"events\":null,\n    \"account\":null,\n    \"block\":null,\n    \"blockHeader\":null,\n    \"latestBlock\":null,\n    \"collection\":null\n}";

  var response = function response() {
    return JSON.parse(DEFAULT_RESPONSE);
  };

  function getBlock() {
    var isSealed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    return pipe([makeGetBlock, function (ix) {
      ix.block.isSealed = isSealed;
      return Ok(ix);
    }]);
  }

  function getAccount(addr) {
    return pipe([makeGetAccount, function (ix) {
      ix.account.addr = sansPrefix(addr);
      return Ok(ix);
    }]);
  }

  var latestBlockDeprecationNotice = function latestBlockDeprecationNotice() {
    log.deprecate({
      pkg: "@onflow/decode",
      subject: "Operating upon data of the latestBlock field of the response object",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/decode/WARNINGS.md#0001-Deprecating-latestBlock-field"
    });
  };

  var decodeImplicit = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(i) {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", i);

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function decodeImplicit(_x4) {
      return _ref2.apply(this, arguments);
    };
  }();

  var decodeVoid = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", null);

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function decodeVoid() {
      return _ref3.apply(this, arguments);
    };
  }();

  var decodeType = /*#__PURE__*/function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(type) {
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", type.staticType);

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function decodeType(_x5) {
      return _ref4.apply(this, arguments);
    };
  }();

  var decodePath = /*#__PURE__*/function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(path) {
      return regenerator.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", {
                domain: path.domain,
                identifier: path.identifier
              });

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function decodePath(_x6) {
      return _ref5.apply(this, arguments);
    };
  }();

  var decodeCapability = /*#__PURE__*/function () {
    var _ref6 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(cap) {
      return regenerator.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              return _context6.abrupt("return", {
                path: cap.path,
                address: cap.address,
                borrowType: cap.borrowType
              });

            case 1:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));

    return function decodeCapability(_x7) {
      return _ref6.apply(this, arguments);
    };
  }();

  var decodeOptional = /*#__PURE__*/function () {
    var _ref7 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(optional, decoders, stack) {
      return regenerator.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (!optional) {
                _context7.next = 6;
                break;
              }

              _context7.next = 3;
              return recurseDecode(optional, decoders, stack);

            case 3:
              _context7.t0 = _context7.sent;
              _context7.next = 7;
              break;

            case 6:
              _context7.t0 = null;

            case 7:
              return _context7.abrupt("return", _context7.t0);

            case 8:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));

    return function decodeOptional(_x8, _x9, _x10) {
      return _ref7.apply(this, arguments);
    };
  }();

  var decodeReference = /*#__PURE__*/function () {
    var _ref8 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(v) {
      return regenerator.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              return _context8.abrupt("return", {
                address: v.address,
                type: v.type
              });

            case 1:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    }));

    return function decodeReference(_x11) {
      return _ref8.apply(this, arguments);
    };
  }();

  var decodeArray = /*#__PURE__*/function () {
    var _ref9 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10(array, decoders, stack) {
      return regenerator.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return Promise.all(array.map(function (v) {
                return new Promise( /*#__PURE__*/function () {
                  var _ref10 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9(res) {
                    return regenerator.wrap(function _callee9$(_context9) {
                      while (1) {
                        switch (_context9.prev = _context9.next) {
                          case 0:
                            _context9.t0 = res;
                            _context9.next = 3;
                            return recurseDecode(v, decoders, [].concat(_toConsumableArray(stack), [v.type]));

                          case 3:
                            _context9.t1 = _context9.sent;
                            return _context9.abrupt("return", (0, _context9.t0)(_context9.t1));

                          case 5:
                          case "end":
                            return _context9.stop();
                        }
                      }
                    }, _callee9);
                  }));

                  return function (_x15) {
                    return _ref10.apply(this, arguments);
                  };
                }());
              }));

            case 2:
              return _context10.abrupt("return", _context10.sent);

            case 3:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    }));

    return function decodeArray(_x12, _x13, _x14) {
      return _ref9.apply(this, arguments);
    };
  }();

  var decodeDictionary = /*#__PURE__*/function () {
    var _ref11 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12(dictionary, decoders, stack) {
      return regenerator.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              _context12.next = 2;
              return dictionary.reduce( /*#__PURE__*/function () {
                var _ref12 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11(acc, v) {
                  return regenerator.wrap(function _callee11$(_context11) {
                    while (1) {
                      switch (_context11.prev = _context11.next) {
                        case 0:
                          _context11.next = 2;
                          return acc;

                        case 2:
                          acc = _context11.sent;
                          _context11.next = 5;
                          return recurseDecode(v.key, decoders, [].concat(_toConsumableArray(stack), [v.key]));

                        case 5:
                          _context11.t0 = _context11.sent;
                          _context11.next = 8;
                          return recurseDecode(v.value, decoders, [].concat(_toConsumableArray(stack), [v.key]));

                        case 8:
                          acc[_context11.t0] = _context11.sent;
                          return _context11.abrupt("return", acc);

                        case 10:
                        case "end":
                          return _context11.stop();
                      }
                    }
                  }, _callee11);
                }));

                return function (_x19, _x20) {
                  return _ref12.apply(this, arguments);
                };
              }(), Promise.resolve({}));

            case 2:
              return _context12.abrupt("return", _context12.sent);

            case 3:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));

    return function decodeDictionary(_x16, _x17, _x18) {
      return _ref11.apply(this, arguments);
    };
  }();

  var decodeComposite = /*#__PURE__*/function () {
    var _ref13 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14(composite, decoders, stack) {
      var decoded, decoder;
      return regenerator.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              _context14.next = 2;
              return composite.fields.reduce( /*#__PURE__*/function () {
                var _ref14 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13(acc, v) {
                  return regenerator.wrap(function _callee13$(_context13) {
                    while (1) {
                      switch (_context13.prev = _context13.next) {
                        case 0:
                          _context13.next = 2;
                          return acc;

                        case 2:
                          acc = _context13.sent;
                          _context13.next = 5;
                          return recurseDecode(v.value, decoders, [].concat(_toConsumableArray(stack), [v.name]));

                        case 5:
                          acc[v.name] = _context13.sent;
                          return _context13.abrupt("return", acc);

                        case 7:
                        case "end":
                          return _context13.stop();
                      }
                    }
                  }, _callee13);
                }));

                return function (_x24, _x25) {
                  return _ref14.apply(this, arguments);
                };
              }(), Promise.resolve({}));

            case 2:
              decoded = _context14.sent;
              decoder = composite.id && decoderLookup(decoders, composite.id);

              if (!decoder) {
                _context14.next = 10;
                break;
              }

              _context14.next = 7;
              return decoder(decoded);

            case 7:
              _context14.t0 = _context14.sent;
              _context14.next = 11;
              break;

            case 10:
              _context14.t0 = decoded;

            case 11:
              return _context14.abrupt("return", _context14.t0);

            case 12:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    }));

    return function decodeComposite(_x21, _x22, _x23) {
      return _ref13.apply(this, arguments);
    };
  }();

  var defaultDecoders = {
    UInt: decodeImplicit,
    Int: decodeImplicit,
    UInt8: decodeImplicit,
    Int8: decodeImplicit,
    UInt16: decodeImplicit,
    Int16: decodeImplicit,
    UInt32: decodeImplicit,
    Int32: decodeImplicit,
    UInt64: decodeImplicit,
    Int64: decodeImplicit,
    UInt128: decodeImplicit,
    Int128: decodeImplicit,
    UInt256: decodeImplicit,
    Int256: decodeImplicit,
    Word8: decodeImplicit,
    Word16: decodeImplicit,
    Word32: decodeImplicit,
    Word64: decodeImplicit,
    UFix64: decodeImplicit,
    Fix64: decodeImplicit,
    String: decodeImplicit,
    Character: decodeImplicit,
    Bool: decodeImplicit,
    Address: decodeImplicit,
    Void: decodeVoid,
    Optional: decodeOptional,
    Reference: decodeReference,
    Array: decodeArray,
    Dictionary: decodeDictionary,
    Event: decodeComposite,
    Resource: decodeComposite,
    Struct: decodeComposite,
    Enum: decodeComposite,
    Type: decodeType,
    Path: decodePath,
    Capability: decodeCapability
  };

  var decoderLookup = function decoderLookup(decoders, lookup) {
    var found = Object.keys(decoders).find(function (decoder) {
      if (/^\/.*\/$/.test(decoder)) {
        var reg = new RegExp(decoder.substring(1, decoder.length - 1));
        return reg.test(lookup);
      }

      return decoder === lookup;
    });
    return lookup && found && decoders[found];
  };

  var recurseDecode = /*#__PURE__*/function () {
    var _ref15 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee15(decodeInstructions, decoders, stack) {
      var decoder;
      return regenerator.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              decoder = decoderLookup(decoders, decodeInstructions.type);

              if (decoder) {
                _context15.next = 3;
                break;
              }

              throw new Error("Undefined Decoder Error: ".concat(decodeInstructions.type, "@").concat(stack.join(".")));

            case 3:
              _context15.next = 5;
              return decoder(decodeInstructions.value, decoders, stack);

            case 5:
              return _context15.abrupt("return", _context15.sent);

            case 6:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    }));

    return function recurseDecode(_x26, _x27, _x28) {
      return _ref15.apply(this, arguments);
    };
  }();

  var decode$1$1 = /*#__PURE__*/function () {
    var _ref16 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee16(decodeInstructions) {
      var customDecoders,
          stack,
          filteredDecoders,
          decoders,
          _args16 = arguments;
      return regenerator.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              customDecoders = _args16.length > 1 && _args16[1] !== undefined ? _args16[1] : {};
              stack = _args16.length > 2 && _args16[2] !== undefined ? _args16[2] : []; // Filter out all default decoders which are overridden by a custom decoder regex

              filteredDecoders = Object.keys(defaultDecoders).filter(function (decoder) {
                return !Object.keys(customDecoders).find(function (customDecoder) {
                  return new RegExp(customDecoder).test(decoder);
                });
              }).reduce(function (decoders, decoderKey) {
                decoders[decoderKey] = defaultDecoders[decoderKey];
                return decoders;
              }, customDecoders);
              decoders = _objectSpread2(_objectSpread2({}, filteredDecoders), customDecoders);
              return _context16.abrupt("return", recurseDecode(decodeInstructions, decoders, stack));

            case 5:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    }));

    return function decode(_x29) {
      return _ref16.apply(this, arguments);
    };
  }();

  var decodeResponse = /*#__PURE__*/function () {
    var _ref17 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee19(response) {
      var customDecoders,
          _args19 = arguments;
      return regenerator.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              customDecoders = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : {};

              if (!response.encodedData) {
                _context19.next = 5;
                break;
              }

              return _context19.abrupt("return", decode$1$1(response.encodedData, customDecoders));

            case 5:
              if (!response.transactionStatus) {
                _context19.next = 16;
                break;
              }

              _context19.t0 = _objectSpread2;
              _context19.t1 = _objectSpread2({}, response.transactionStatus);
              _context19.t2 = {};
              _context19.next = 11;
              return Promise.all(response.transactionStatus.events.map( /*#__PURE__*/function () {
                var _decodeEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee17(e) {
                  return regenerator.wrap(function _callee17$(_context17) {
                    while (1) {
                      switch (_context17.prev = _context17.next) {
                        case 0:
                          _context17.t0 = e.type;
                          _context17.t1 = e.transactionId;
                          _context17.t2 = e.transactionIndex;
                          _context17.t3 = e.eventIndex;
                          _context17.next = 6;
                          return decode$1$1(e.payload, customDecoders);

                        case 6:
                          _context17.t4 = _context17.sent;
                          return _context17.abrupt("return", {
                            type: _context17.t0,
                            transactionId: _context17.t1,
                            transactionIndex: _context17.t2,
                            eventIndex: _context17.t3,
                            data: _context17.t4
                          });

                        case 8:
                        case "end":
                          return _context17.stop();
                      }
                    }
                  }, _callee17);
                }));

                function decodeEvents(_x31) {
                  return _decodeEvents.apply(this, arguments);
                }

                return decodeEvents;
              }()));

            case 11:
              _context19.t3 = _context19.sent;
              _context19.t4 = {
                events: _context19.t3
              };
              return _context19.abrupt("return", (0, _context19.t0)(_context19.t1, _context19.t2, _context19.t4));

            case 16:
              if (!response.transaction) {
                _context19.next = 20;
                break;
              }

              return _context19.abrupt("return", response.transaction);

            case 20:
              if (!response.events) {
                _context19.next = 26;
                break;
              }

              _context19.next = 23;
              return Promise.all(response.events.map( /*#__PURE__*/function () {
                var _decodeEvents2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee18(e) {
                  return regenerator.wrap(function _callee18$(_context18) {
                    while (1) {
                      switch (_context18.prev = _context18.next) {
                        case 0:
                          _context18.t0 = e.blockId;
                          _context18.t1 = e.blockHeight;
                          _context18.t2 = e.blockTimestamp;
                          _context18.t3 = e.type;
                          _context18.t4 = e.transactionId;
                          _context18.t5 = e.transactionIndex;
                          _context18.t6 = e.eventIndex;
                          _context18.next = 9;
                          return decode$1$1(e.payload, customDecoders);

                        case 9:
                          _context18.t7 = _context18.sent;
                          return _context18.abrupt("return", {
                            blockId: _context18.t0,
                            blockHeight: _context18.t1,
                            blockTimestamp: _context18.t2,
                            type: _context18.t3,
                            transactionId: _context18.t4,
                            transactionIndex: _context18.t5,
                            eventIndex: _context18.t6,
                            data: _context18.t7
                          });

                        case 11:
                        case "end":
                          return _context18.stop();
                      }
                    }
                  }, _callee18);
                }));

                function decodeEvents(_x32) {
                  return _decodeEvents2.apply(this, arguments);
                }

                return decodeEvents;
              }()));

            case 23:
              return _context19.abrupt("return", _context19.sent);

            case 26:
              if (!response.account) {
                _context19.next = 30;
                break;
              }

              return _context19.abrupt("return", response.account);

            case 30:
              if (!response.block) {
                _context19.next = 34;
                break;
              }

              return _context19.abrupt("return", response.block);

            case 34:
              if (!response.blockHeader) {
                _context19.next = 38;
                break;
              }

              return _context19.abrupt("return", response.blockHeader);

            case 38:
              if (!response.latestBlock) {
                _context19.next = 43;
                break;
              }

              latestBlockDeprecationNotice();
              return _context19.abrupt("return", response.latestBlock);

            case 43:
              if (!response.transactionId) {
                _context19.next = 47;
                break;
              }

              return _context19.abrupt("return", response.transactionId);

            case 47:
              if (!response.collection) {
                _context19.next = 49;
                break;
              }

              return _context19.abrupt("return", response.collection);

            case 49:
              return _context19.abrupt("return", null);

            case 50:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19);
    }));

    return function decodeResponse(_x30) {
      return _ref17.apply(this, arguments);
    };
  }();

  var isFn$2 = function isFn(v) {
    return typeof v === "function";
  };

  var isString$1$1 = function isString(v) {
    return typeof v === "string";
  };

  function resolveCadence(_x) {
    return _resolveCadence.apply(this, arguments);
  }

  function _resolveCadence() {
    _resolveCadence = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var cadence;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(isTransaction(ix) || isScript(ix))) {
                _context.next = 11;
                break;
              }

              cadence = get(ix, "ix.cadence");
              invariant$1(isFn$2(cadence) || isString$1$1(cadence), "Cadence needs to be a function or a string.");

              if (!isFn$2(cadence)) {
                _context.next = 7;
                break;
              }

              _context.next = 6;
              return cadence({});

            case 6:
              cadence = _context.sent;

            case 7:
              invariant$1(isString$1$1(cadence), "Cadence needs to be a string at this point.");
              _context.next = 10;
              return config().where(/^0x/).then(function (d) {
                return Object.entries(d).reduce(function (cadence, _ref) {
                  var _ref2 = _slicedToArray(_ref, 2),
                      key = _ref2[0],
                      value = _ref2[1];

                  var regex = new RegExp("(\\b" + key + "\\b)", "g");
                  return cadence.replace(regex, value);
                }, cadence);
              });

            case 10:
              ix.message.cadence = _context.sent;

            case 11:
              return _context.abrupt("return", ix);

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveCadence.apply(this, arguments);
  }

  var isFn$1 = function isFn(v) {
    return typeof v === "function";
  };

  function cast(arg) {
    // prettier-ignore
    invariant$1(_typeof$1(arg.xform) != null, "No type specified for argument: ".concat(arg.value));
    if (isFn$1(arg.xform)) return arg.xform(arg.value);
    if (isFn$1(arg.xform.asArgument)) return arg.xform.asArgument(arg.value); // prettier-ignore

    invariant$1(false, "Invalid Argument", arg);
  }

  function handleArgResolution(_x) {
    return _handleArgResolution.apply(this, arguments);
  }

  function _handleArgResolution() {
    _handleArgResolution = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(arg) {
      var depth,
          resolvedArg,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              depth = _args.length > 1 && _args[1] !== undefined ? _args[1] : 3;
              invariant$1(depth > 0, "Argument Resolve Recursion Limit Exceeded for Arg: ".concat(arg.tempId));

              if (!isFn$1(arg.resolveArgument)) {
                _context.next = 9;
                break;
              }

              _context.next = 5;
              return arg.resolveArgument();

            case 5:
              resolvedArg = _context.sent;
              return _context.abrupt("return", handleArgResolution(resolvedArg, depth - 1));

            case 9:
              return _context.abrupt("return", arg);

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _handleArgResolution.apply(this, arguments);
  }

  function resolveArguments(_x2) {
    return _resolveArguments.apply(this, arguments);
  }

  function _resolveArguments() {
    _resolveArguments = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      var _i, _Object$entries, _Object$entries$_i, id, arg, res;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(isTransaction(ix) || isScript(ix))) {
                _context2.next = 11;
                break;
              }

              _i = 0, _Object$entries = Object.entries(ix.arguments);

            case 2:
              if (!(_i < _Object$entries.length)) {
                _context2.next = 11;
                break;
              }

              _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), id = _Object$entries$_i[0], arg = _Object$entries$_i[1];
              _context2.next = 6;
              return handleArgResolution(arg);

            case 6:
              res = _context2.sent;
              ix.arguments[id].asArgument = cast(res);

            case 8:
              _i++;
              _context2.next = 2;
              break;

            case 11:
              return _context2.abrupt("return", ix);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _resolveArguments.apply(this, arguments);
  }

  var encodeTransactionPayload = function encodeTransactionPayload(tx) {
    return prependTransactionDomainTag(rlpEncode(preparePayload(tx)));
  };

  var encodeTransactionEnvelope = function encodeTransactionEnvelope(tx) {
    return prependTransactionDomainTag(rlpEncode(prepareEnvelope(tx)));
  };

  var rightPaddedHexBuffer = function rightPaddedHexBuffer(value, pad) {
    return buffer$1.Buffer.from(value.padEnd(pad * 2, 0), "hex");
  };

  var leftPaddedHexBuffer = function leftPaddedHexBuffer(value, pad) {
    return buffer$1.Buffer.from(value.padStart(pad * 2, 0), "hex");
  };

  var TRANSACTION_DOMAIN_TAG = rightPaddedHexBuffer(buffer$1.Buffer.from("FLOW-V0.0-transaction").toString("hex"), 32).toString("hex");

  var prependTransactionDomainTag = function prependTransactionDomainTag(tx) {
    return TRANSACTION_DOMAIN_TAG + tx;
  };

  var addressBuffer = function addressBuffer(addr) {
    return leftPaddedHexBuffer(addr, 8);
  };

  var blockBuffer = function blockBuffer(block) {
    return leftPaddedHexBuffer(block, 32);
  };

  var argumentToString = function argumentToString(arg) {
    return buffer$1.Buffer.from(JSON.stringify(arg), "utf8");
  };

  var scriptBuffer = function scriptBuffer(script) {
    return buffer$1.Buffer.from(script, "utf8");
  };

  var signatureBuffer = function signatureBuffer(signature) {
    return buffer$1.Buffer.from(signature, "hex");
  };

  var rlpEncode = function rlpEncode(v) {
    return encode$3(v).toString("hex");
  };

  var preparePayload = function preparePayload(tx) {
    validatePayload(tx);
    return [scriptBuffer(tx.cadence), tx.arguments.map(argumentToString), blockBuffer(tx.refBlock), tx.computeLimit, addressBuffer(sansPrefix(tx.proposalKey.address)), tx.proposalKey.keyId, tx.proposalKey.sequenceNum, addressBuffer(sansPrefix(tx.payer)), tx.authorizers.map(function (authorizer) {
      return addressBuffer(sansPrefix(authorizer));
    })];
  };

  var prepareEnvelope = function prepareEnvelope(tx) {
    validateEnvelope(tx);
    return [preparePayload(tx), preparePayloadSignatures(tx)];
  };

  var preparePayloadSignatures = function preparePayloadSignatures(tx) {
    var signers = collectSigners(tx);
    return tx.payloadSigs.map(function (sig) {
      return {
        signerIndex: signers.get(sig.address),
        keyId: sig.keyId,
        sig: sig.sig
      };
    }).sort(function (a, b) {
      if (a.signerIndex > b.signerIndex) return 1;
      if (a.signerIndex < b.signerIndex) return -1;
      if (a.keyId > b.keyId) return 1;
      if (a.keyId < b.keyId) return -1;
    }).map(function (sig) {
      return [sig.signerIndex, sig.keyId, signatureBuffer(sig.sig)];
    });
  };

  var collectSigners = function collectSigners(tx) {
    var signers = new Map();
    var i = 0;

    var addSigner = function addSigner(addr) {
      if (!signers.has(addr)) {
        signers.set(addr, i);
        i++;
      }
    };

    addSigner(tx.proposalKey.address);
    addSigner(tx.payer);
    tx.authorizers.forEach(addSigner);
    return signers;
  };

  var validatePayload = function validatePayload(tx) {
    payloadFields.forEach(function (field) {
      return checkField(tx, field);
    });
    proposalKeyFields.forEach(function (field) {
      return checkField(tx.proposalKey, field, "proposalKey");
    });
  };

  var validateEnvelope = function validateEnvelope(tx) {
    payloadSigsFields.forEach(function (field) {
      return checkField(tx, field);
    });
    tx.payloadSigs.forEach(function (sig, index) {
      payloadSigFields.forEach(function (field) {
        return checkField(sig, field, "payloadSigs", index);
      });
    });
  };

  var isNumber$2 = function isNumber(v) {
    return typeof v === "number";
  };

  var isString$2 = function isString(v) {
    return typeof v === "string";
  };

  var isObject$1 = function isObject(v) {
    return v !== null && _typeof$1(v) === "object";
  };

  var isArray$3 = function isArray(v) {
    return isObject$1(v) && v instanceof Array;
  };

  var payloadFields = [{
    name: "cadence",
    check: isString$2
  }, {
    name: "arguments",
    check: isArray$3
  }, {
    name: "refBlock",
    check: isString$2,
    defaultVal: "0"
  }, {
    name: "computeLimit",
    check: isNumber$2
  }, {
    name: "proposalKey",
    check: isObject$1
  }, {
    name: "payer",
    check: isString$2
  }, {
    name: "authorizers",
    check: isArray$3
  }];
  var proposalKeyFields = [{
    name: "address",
    check: isString$2
  }, {
    name: "keyId",
    check: isNumber$2
  }, {
    name: "sequenceNum",
    check: isNumber$2
  }];
  var payloadSigsFields = [{
    name: "payloadSigs",
    check: isArray$3
  }];
  var payloadSigFields = [{
    name: "address",
    check: isString$2
  }, {
    name: "keyId",
    check: isNumber$2
  }, {
    name: "sig",
    check: isString$2
  }];

  var checkField = function checkField(obj, field, base, index) {
    var name = field.name,
        check = field.check,
        defaultVal = field.defaultVal;
    if (obj[name] == null && defaultVal != null) obj[name] = defaultVal;
    if (obj[name] == null) throw missingFieldError(name, base, index);
    if (!check(obj[name])) throw invalidFieldError(name, base, index);
  };

  var printFieldName = function printFieldName(field, base, index) {
    if (!!base) return index == null ? "".concat(base, ".").concat(field) : "".concat(base, ".").concat(index, ".").concat(field);
    return field;
  };

  var missingFieldError = function missingFieldError(field, base, index) {
    return new Error("Missing field ".concat(printFieldName(field, base, index)));
  };

  var invalidFieldError = function invalidFieldError(field, base, index) {
    return new Error("Invalid field ".concat(printFieldName(field, base, index)));
  };

  function findInsideSigners(ix) {
    // Inside Signers Are: (authorizers + proposer) - payer
    var inside = new Set(ix.authorizations);
    inside.add(ix.proposer);

    if (Array.isArray(ix.payer)) {
      ix.payer.forEach(function (p) {
        return inside["delete"](p);
      });
    } else {
      inside["delete"](ix.payer);
    }

    return Array.from(inside);
  }

  function findOutsideSigners(ix) {
    // Outside Signers Are: (payer)
    var outside = new Set(Array.isArray(ix.payer) ? ix.payer : [ix.payer]);
    return Array.from(outside);
  }

  var createSignableVoucher = function createSignableVoucher(ix) {
    var buildAuthorizers = function buildAuthorizers() {
      var authorizations = ix.authorizations.map(function (cid) {
        return withPrefix$1(ix.accounts[cid].addr);
      }).reduce(function (prev, current) {
        return prev.find(function (item) {
          return item === current;
        }) ? prev : [].concat(_toConsumableArray(prev), [current]);
      }, []);
      return authorizations[0] ? authorizations : [];
    };

    var buildInsideSigners = function buildInsideSigners() {
      return findInsideSigners(ix).map(function (id) {
        return {
          address: withPrefix$1(ix.accounts[id].addr),
          keyId: ix.accounts[id].keyId,
          sig: ix.accounts[id].signature
        };
      });
    };

    var buildOutsideSigners = function buildOutsideSigners() {
      return findOutsideSigners(ix).map(function (id) {
        return {
          address: withPrefix$1(ix.accounts[id].addr),
          keyId: ix.accounts[id].keyId,
          sig: ix.accounts[id].signature
        };
      });
    };

    return {
      cadence: ix.message.cadence,
      refBlock: ix.message.refBlock || null,
      computeLimit: ix.message.computeLimit,
      arguments: ix.message.arguments.map(function (id) {
        return ix.arguments[id].asArgument;
      }),
      proposalKey: {
        address: withPrefix$1(ix.accounts[ix.proposer].addr),
        keyId: ix.accounts[ix.proposer].keyId,
        sequenceNum: ix.accounts[ix.proposer].sequenceNum
      },
      payer: withPrefix$1(ix.accounts[Array.isArray(ix.payer) ? ix.payer[0] : ix.payer].addr),
      authorizers: buildAuthorizers(),
      payloadSigs: buildInsideSigners(),
      envelopeSigs: buildOutsideSigners()
    };
  };

  var idof$1 = function idof(acct) {
    return "".concat(withPrefix$1(acct.addr), "-").concat(acct.keyId);
  };

  var isFn = function isFn(v) {
    return typeof v === "function";
  };

  function buildPreSignable(acct, ix) {
    try {
      return {
        f_type: "PreSignable",
        f_vsn: "1.0.1",
        roles: acct.role,
        cadence: ix.message.cadence,
        args: ix.message.arguments.map(function (d) {
          return ix.arguments[d].asArgument;
        }),
        data: {},
        interaction: ix,
        voucher: createSignableVoucher(ix)
      };
    } catch (error) {
      console.error("buildPreSignable", error);
      throw error;
    }
  }

  function collectAccounts(_x, _x2, _x3) {
    return _collectAccounts.apply(this, arguments);
  }

  function _collectAccounts() {
    _collectAccounts = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix, accounts, last) {
      var depth,
          authorizations,
          _iterator,
          _step,
          _loop,
          old,
          _args2 = arguments;

      return regenerator.wrap(function _callee$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              depth = _args2.length > 3 && _args2[3] !== undefined ? _args2[3] : 3;
              invariant$1(depth, "Account Resolve Recursion Limit Exceeded", {
                ix: ix,
                accounts: accounts
              });
              authorizations = [];
              _iterator = _createForOfIteratorHelper(accounts);
              _context2.prev = 4;
              _loop = /*#__PURE__*/regenerator.mark(function _loop() {
                var ax, resolve, dupList, payerAccts, multiAccts;
                return regenerator.wrap(function _loop$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        ax = _step.value;
                        resolve = ax.resolve;
                        ax.resolve = null;
                        old = last || ax;

                        if (!isFn(resolve)) {
                          _context.next = 8;
                          break;
                        }

                        _context.next = 7;
                        return resolve(ax, buildPreSignable(ax, ix));

                      case 7:
                        ax = _context.sent;

                      case 8:
                        if (!Array.isArray(ax)) {
                          _context.next = 13;
                          break;
                        }

                        _context.next = 11;
                        return collectAccounts(ix, ax, old, depth - 1);

                      case 11:
                        _context.next = 30;
                        break;

                      case 13:
                        if (ax.addr) {
                          ax.addr = sansPrefix(ax.addr);
                        }

                        if (ax.addr != null && ax.keyId != null) {
                          ax.tempId = idof$1(ax);
                        }

                        ix.accounts[ax.tempId] = ix.accounts[ax.tempId] || ax;
                        ix.accounts[ax.tempId].role.proposer = ix.accounts[ax.tempId].role.proposer || ax.role.proposer;
                        ix.accounts[ax.tempId].role.payer = ix.accounts[ax.tempId].role.payer || ax.role.payer;
                        ix.accounts[ax.tempId].role.authorizer = ix.accounts[ax.tempId].role.authorizer || ax.role.authorizer;

                        if (ix.accounts[ax.tempId].role.proposer && ix.proposer === old.tempId) {
                          ix.proposer = ax.tempId;
                        }

                        if (!ix.accounts[ax.tempId].role.payer) {
                          _context.next = 29;
                          break;
                        }

                        if (Array.isArray(ix.payer)) {
                          ix.payer = Array.from(new Set([].concat(_toConsumableArray(ix.payer), [ax.tempId]).map(function (d) {
                            return d === old.tempId ? ax.tempId : d;
                          })));
                        } else {
                          ix.payer = Array.from(new Set([ix.payer, ax.tempId].map(function (d) {
                            return d === old.tempId ? ax.tempId : d;
                          })));
                        }

                        if (!(ix.payer.length > 1)) {
                          _context.next = 29;
                          break;
                        } // remove payer dups based on addr and keyId


                        dupList = [];
                        payerAccts = [];
                        ix.payer = ix.payer.reduce(function (g, tempId) {
                          var addr = ix.accounts[tempId].addr;
                          var key = idof$1(ix.accounts[tempId]);
                          payerAccts.push(addr);
                          if (dupList.includes(key)) return g;
                          dupList.push(key);
                          return [].concat(_toConsumableArray(g), [tempId]);
                        }, []);
                        multiAccts = Array.from(new Set(payerAccts));

                        if (!(multiAccts.length > 1)) {
                          _context.next = 29;
                          break;
                        }

                        throw new Error("Payer can not be different accounts");

                      case 29:
                        if (ix.accounts[ax.tempId].role.authorizer) {
                          if (last) {
                            // do group replacement
                            authorizations = Array.from(new Set([].concat(_toConsumableArray(authorizations), [ax.tempId])));
                          } else {
                            // do 1-1 replacement
                            ix.authorizations = ix.authorizations.map(function (d) {
                              return d === old.tempId ? ax.tempId : d;
                            });
                          }
                        }

                      case 30:
                        if (old.tempId != ax.tempId) delete ix.accounts[old.tempId];

                      case 31:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _loop);
              });

              _iterator.s();

            case 7:
              if ((_step = _iterator.n()).done) {
                _context2.next = 11;
                break;
              }

              return _context2.delegateYield(_loop(), "t0", 9);

            case 9:
              _context2.next = 7;
              break;

            case 11:
              _context2.next = 16;
              break;

            case 13:
              _context2.prev = 13;
              _context2.t1 = _context2["catch"](4);

              _iterator.e(_context2.t1);

            case 16:
              _context2.prev = 16;

              _iterator.f();

              return _context2.finish(16);

            case 19:
              if (last) {
                // complete (flatmap) group replacement
                ix.authorizations = ix.authorizations.map(function (d) {
                  return d === last.tempId ? authorizations : d;
                }).reduce(function (prev, curr) {
                  return Array.isArray(curr) ? [].concat(_toConsumableArray(prev), _toConsumableArray(curr)) : [].concat(_toConsumableArray(prev), [curr]);
                }, []);
              }

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee, null, [[4, 13, 16, 19]]);
    }));
    return _collectAccounts.apply(this, arguments);
  }

  function resolveAccounts(_x4) {
    return _resolveAccounts.apply(this, arguments);
  }

  function _resolveAccounts() {
    _resolveAccounts = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      return regenerator.wrap(function _callee2$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!isTransaction(ix)) {
                _context3.next = 13;
                break;
              }

              if (!Array.isArray(ix.payer)) {
                log.deprecate({
                  pkg: "FCL",
                  subject: '"ix.payer" must be an array. Support for ix.payer as a singular',
                  message: "See changelog for more info."
                });
              }

              _context3.prev = 2;
              _context3.next = 5;
              return collectAccounts(ix, Object.values(ix.accounts));

            case 5:
              _context3.next = 7;
              return collectAccounts(ix, Object.values(ix.accounts));

            case 7:
              _context3.next = 13;
              break;

            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](2);
              console.error("=== SAD PANDA ===\n\n", _context3.t0, "\n\n=== SAD PANDA ===");
              throw _context3.t0;

            case 13:
              return _context3.abrupt("return", ix);

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee2, null, [[2, 9]]);
    }));
    return _resolveAccounts.apply(this, arguments);
  }

  function resolveSignatures(_x) {
    return _resolveSignatures.apply(this, arguments);
  }

  function _resolveSignatures() {
    _resolveSignatures = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      var insideSigners, insidePayload, outsideSigners, outsidePayload;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!isTransaction(ix)) {
                _context2.next = 16;
                break;
              }

              _context2.prev = 1;
              insideSigners = findInsideSigners(ix);
              insidePayload = encodeTransactionPayload(prepForEncoding(ix));
              _context2.next = 6;
              return Promise.all(insideSigners.map(fetchSignature(ix, insidePayload)));

            case 6:
              outsideSigners = findOutsideSigners(ix);
              outsidePayload = encodeTransactionEnvelope(_objectSpread2(_objectSpread2({}, prepForEncoding(ix)), {}, {
                payloadSigs: insideSigners.map(function (id) {
                  return {
                    address: ix.accounts[id].addr,
                    keyId: ix.accounts[id].keyId,
                    sig: ix.accounts[id].signature
                  };
                })
              }));
              _context2.next = 10;
              return Promise.all(outsideSigners.map(fetchSignature(ix, outsidePayload)));

            case 10:
              _context2.next = 16;
              break;

            case 12:
              _context2.prev = 12;
              _context2.t0 = _context2["catch"](1);
              console.error("Signatures", _context2.t0, {
                ix: ix
              });
              throw _context2.t0;

            case 16:
              return _context2.abrupt("return", ix);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[1, 12]]);
    }));
    return _resolveSignatures.apply(this, arguments);
  }

  function fetchSignature(ix, payload) {
    return /*#__PURE__*/function () {
      var _innerFetchSignature = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(id) {
        var acct, _yield$acct$signingFu, signature;

        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                acct = ix.accounts[id];

                if (!(acct.signature != null)) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                _context.next = 5;
                return acct.signingFunction(buildSignable(acct, payload, ix));

              case 5:
                _yield$acct$signingFu = _context.sent;
                signature = _yield$acct$signingFu.signature;
                ix.accounts[id].signature = signature;

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function innerFetchSignature(_x2) {
        return _innerFetchSignature.apply(this, arguments);
      }

      return innerFetchSignature;
    }();
  }

  function buildSignable(acct, message, ix) {
    try {
      return {
        f_type: "Signable",
        f_vsn: "1.0.1",
        message: message,
        addr: sansPrefix(acct.addr),
        keyId: acct.keyId,
        roles: acct.role,
        cadence: ix.message.cadence,
        args: ix.message.arguments.map(function (d) {
          return ix.arguments[d].asArgument;
        }),
        data: {},
        interaction: ix,
        voucher: createSignableVoucher(ix)
      };
    } catch (error) {
      console.error("buildSignable", error);
      throw error;
    }
  }

  function prepForEncoding(ix) {
    var payerAddress = sansPrefix((Array.isArray(ix.payer) ? ix.accounts[ix.payer[0]] : ix.accounts[ix.payer]).addr);
    return {
      cadence: ix.message.cadence,
      refBlock: ix.message.refBlock || null,
      computeLimit: ix.message.computeLimit,
      arguments: ix.message.arguments.map(function (id) {
        return ix.arguments[id].asArgument;
      }),
      proposalKey: {
        address: sansPrefix(ix.accounts[ix.proposer].addr),
        keyId: ix.accounts[ix.proposer].keyId,
        sequenceNum: ix.accounts[ix.proposer].sequenceNum
      },
      payer: payerAddress,
      authorizers: ix.authorizations.map(function (cid) {
        return sansPrefix(ix.accounts[cid].addr);
      }).reduce(function (prev, current) {
        return prev.find(function (item) {
          return item === current;
        }) ? prev : [].concat(_toConsumableArray(prev), [current]);
      }, [])
    };
  }

  function resolveValidators(_x) {
    return _resolveValidators.apply(this, arguments);
  }

  function _resolveValidators() {
    _resolveValidators = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var validators;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              validators = get(ix, "ix.validators", []);
              return _context.abrupt("return", pipe(ix, validators.map(function (cb) {
                return function (ix) {
                  return cb(ix, {
                    Ok: Ok,
                    Bad: Bad
                  });
                };
              })));

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveValidators.apply(this, arguments);
  }

  function resolveFinalNormalization(_x) {
    return _resolveFinalNormalization.apply(this, arguments);
  }

  function _resolveFinalNormalization() {
    _resolveFinalNormalization = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var _i, _Object$keys, key;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              for (_i = 0, _Object$keys = Object.keys(ix.accounts); _i < _Object$keys.length; _i++) {
                key = _Object$keys[_i];
                ix.accounts[key].addr = sansPrefix(ix.accounts[key].addr);
              }

              return _context.abrupt("return", ix);

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveFinalNormalization.apply(this, arguments);
  }

  function resolveVoucherIntercept(_x) {
    return _resolveVoucherIntercept.apply(this, arguments);
  }

  function _resolveVoucherIntercept() {
    _resolveVoucherIntercept = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      var fn;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              fn = get(ix, "ix.voucher-intercept");

              if (!isFn$3(fn)) {
                _context.next = 4;
                break;
              }

              _context.next = 4;
              return fn(createSignableVoucher(ix));

            case 4:
              return _context.abrupt("return", ix);

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveVoucherIntercept.apply(this, arguments);
  }

  var DEFAULT_COMPUTE_LIMIT = 100;

  function resolveComputeLimit(_x) {
    return _resolveComputeLimit.apply(this, arguments);
  }

  function _resolveComputeLimit() {
    _resolveComputeLimit = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!isTransaction(ix)) {
                _context.next = 8;
                break;
              }

              _context.t0 = ix.message.computeLimit;

              if (_context.t0) {
                _context.next = 6;
                break;
              }

              _context.next = 5;
              return config.get("fcl.limit");

            case 5:
              _context.t0 = _context.sent;

            case 6:
              ix.message.computeLimit = _context.t0;

              if (!ix.message.computeLimit) {
                log.deprecate({
                  pkg: "FCL/SDK",
                  subject: "The built-in default compute limit (DEFAULT_COMPUTE_LIMIT=10)",
                  transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/sdk/TRANSITIONS.md#0009-deprecate-default-compute-limit"
                });
                ix.message.computeLimit = DEFAULT_COMPUTE_LIMIT;
              }

            case 8:
              return _context.abrupt("return", ix);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _resolveComputeLimit.apply(this, arguments);
  }

  var noop$5 = function noop(v) {
    return v;
  };

  var debug = function debug(key) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$5;
    return /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ix) {
        var accts, log;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                accts = function accts(ix) {
                  return ["\nAccounts:", {
                    proposer: ix.proposer,
                    authorizations: ix.authorizations,
                    payer: ix.payer
                  }, "\n\nDetails:", ix.accounts].filter(Boolean);
                };

                log = function log() {
                  var _console;

                  for (var _len = arguments.length, msg = new Array(_len), _key = 0; _key < _len; _key++) {
                    msg[_key] = arguments[_key];
                  }

                  (_console = console).log.apply(_console, ["debug[".concat(key, "] ---\n")].concat(msg, ["\n\n\n---"]));
                };

                _context.next = 5;
                return config.get("debug.".concat(key));

              case 5:
                if (!_context.sent) {
                  _context.next = 8;
                  break;
                }

                _context.next = 8;
                return fn(ix, log, accts);

              case 8:
                return _context.abrupt("return", ix);

              case 9:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
  };

  var resolve = pipe([resolveCadence, debug("cadence", function (ix, log) {
    return log(ix.message.cadence);
  }), resolveComputeLimit, debug("compute limit", function (ix, log) {
    return log(ix.message.computeLimit);
  }), resolveArguments, debug("arguments", function (ix, log) {
    return log(ix.message.arguments, ix.message);
  }), resolveAccounts, debug("accounts", function (ix, log, accts) {
    return log.apply(void 0, _toConsumableArray(accts(ix)));
  }),
  /* special */
  execFetchRef,
  /* special */
  execFetchSequenceNumber, resolveSignatures, debug("signatures", function (ix, log, accts) {
    return log.apply(void 0, _toConsumableArray(accts(ix)));
  }), resolveFinalNormalization, resolveValidators, resolveVoucherIntercept, debug("resolved", function (ix, log) {
    return log(ix);
  })]);

  function execFetchRef(_x2) {
    return _execFetchRef.apply(this, arguments);
  }

  function _execFetchRef() {
    _execFetchRef = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ix) {
      var node, sendFn;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(isTransaction(ix) && ix.message.refBlock == null)) {
                _context2.next = 11;
                break;
              }

              _context2.next = 3;
              return config().get("accessNode.api");

            case 3:
              node = _context2.sent;
              _context2.next = 6;
              return config.first(["sdk.transport", "sdk.send"], send$1);

            case 6:
              sendFn = _context2.sent;
              invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
              _context2.next = 10;
              return sendFn(build([getBlock()]), {
                config: config,
                response: response,
                Buffer: buffer$1.Buffer,
                ix: ixModule
              }, {
                node: node
              }).then(decodeResponse);

            case 10:
              ix.message.refBlock = _context2.sent.id;

            case 11:
              return _context2.abrupt("return", ix);

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _execFetchRef.apply(this, arguments);
  }

  function execFetchSequenceNumber(_x3) {
    return _execFetchSequenceNumber.apply(this, arguments);
  }

  function _execFetchSequenceNumber() {
    _execFetchSequenceNumber = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ix) {
      var acct, node, sendFn;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!isTransaction(ix)) {
                _context3.next = 20;
                break;
              }

              acct = Object.values(ix.accounts).find(function (a) {
                return a.role.proposer;
              });
              invariant$1(acct, "Transactions require a proposer");

              if (!(acct.sequenceNum == null)) {
                _context3.next = 20;
                break;
              }

              _context3.next = 6;
              return config().get("accessNode.api");

            case 6:
              node = _context3.sent;
              _context3.next = 9;
              return config.first(["sdk.transport", "sdk.send"], send$1);

            case 9:
              sendFn = _context3.sent;
              invariant$1(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
              _context3.t0 = sendFn;
              _context3.next = 14;
              return build([getAccount(acct.addr)]);

            case 14:
              _context3.t1 = _context3.sent;
              _context3.t2 = {
                config: config,
                response: response,
                Buffer: buffer$1.Buffer,
                ix: ixModule
              };
              _context3.t3 = {
                node: node
              };
              _context3.next = 19;
              return (0, _context3.t0)(_context3.t1, _context3.t2, _context3.t3).then(decodeResponse).then(function (acct) {
                return acct.keys;
              }).then(function (keys) {
                return keys.find(function (key) {
                  return key.index === acct.keyId;
                });
              }).then(function (key) {
                return key.sequenceNumber;
              });

            case 19:
              ix.accounts[acct.tempId].sequenceNum = _context3.sent;

            case 20:
              return _context3.abrupt("return", ix);

            case 21:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _execFetchSequenceNumber.apply(this, arguments);
  }

  function invariant() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length > 1) {
      var predicate = args[0],
          message = args[1];
      return invariant(function (ix, _ref) {
        var Ok = _ref.Ok,
            Bad = _ref.Bad;
        return predicate ? Ok(ix) : Bad(ix, message);
      });
    }

    var fn = args[0];
    return function (ix) {
      return fn(ix, {
        Ok: Ok,
        Bad: Bad
      });
    };
  }

  var send = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      var args,
          opts,
          sendFn,
          resolveFn,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              args = _args.length > 0 && _args[0] !== undefined ? _args[0] : [];
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.next = 4;
              return config.first(["sdk.transport", "sdk.send"], opts.send || send$1);

            case 4:
              sendFn = _context.sent;
              invariant(sendFn, "Required value for sdk.transport is not defined in config. See: ".concat("https://github.com/onflow/fcl-js/blob/master/packages/sdk/CHANGELOG.md#0057-alpha1----2022-01-21"));
              _context.next = 8;
              return config.first(["sdk.resolve"], opts.resolve || resolve);

            case 8:
              resolveFn = _context.sent;
              _context.t0 = opts.node;

              if (_context.t0) {
                _context.next = 14;
                break;
              }

              _context.next = 13;
              return config().get("accessNode.api");

            case 13:
              _context.t0 = _context.sent;

            case 14:
              opts.node = _context.t0;
              if (Array.isArray(args)) args = pipe(interaction(), args);
              _context.t1 = sendFn;
              _context.next = 19;
              return resolveFn(args);

            case 19:
              _context.t2 = _context.sent;
              _context.t3 = {
                config: config,
                response: response,
                ix: ixModule,
                Buffer: buffer$1.Buffer
              };
              _context.t4 = opts;
              return _context.abrupt("return", (0, _context.t1)(_context.t2, _context.t3, _context.t4));

            case 23:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function send() {
      return _ref.apply(this, arguments);
    };
  }();

  function decode$3(_x) {
    return _decode.apply(this, arguments);
  }

  function _decode() {
    _decode = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(response) {
      var decodersFromConfig, decoders;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return config().where(/^decoder\./);

            case 2:
              decodersFromConfig = _context.sent;
              decoders = Object.entries(decodersFromConfig).map(function (_ref) {
                var _ref2 = _slicedToArray(_ref, 2),
                    pattern = _ref2[0],
                    xform = _ref2[1];

                pattern = "/".concat(pattern.replace(/^decoder\./, ""), "$/");
                return [pattern, xform];
              });
              return _context.abrupt("return", decodeResponse(response, Object.fromEntries(decoders)));

            case 5:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _decode.apply(this, arguments);
  }

  function validator(cb) {
    return update("ix.validators", function (validators) {
      return Array.isArray(validators) ? validators.push(cb) : [cb];
    });
  }

  function atBlockHeight(height) {
    return pipe([function (ix) {
      ix.block.height = height;
      return ix;
    }, validator(function (ix) {
      if (typeof ix.block.isSealed === "boolean") throw new Error("Unable to specify both block height and isSealed.");
      if (ix.block.id) throw new Error("Unable to specify both block height and block id.");
      return ix;
    })]);
  }

  function atBlockId(id) {
    return pipe([function (ix) {
      ix.block.id = id;
      return Ok(ix);
    }, validator(function (ix, _ref) {
      var Ok = _ref.Ok,
          Bad = _ref.Bad;
      if (isGetAccount(ix)) return Bad(ix, "Unable to specify a block id with a Get Account interaction.");
      if (typeof ix.block.isSealed === "boolean") return Bad(ix, "Unable to specify both block id and isSealed.");
      if (ix.block.height) return Bad(ix, "Unable to specify both block id and block height.");
      return Ok(ix);
    })]);
  }

  function block() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$sealed = _ref.sealed,
        sealed = _ref$sealed === void 0 ? false : _ref$sealed,
        id = _ref.id,
        height = _ref.height;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    invariant$1(!(sealed && id || sealed && height), "Method: block -- Cannot pass \"sealed\" with \"id\" or \"height\"");
    invariant$1(!(id && height), "Method: block -- Cannot pass \"id\" and \"height\" simultaneously"); // Get block by ID

    if (id) return send([getBlock(), atBlockId(id)], opts).then(decodeResponse); // Get block by height

    if (height) return send([getBlock(), atBlockHeight(height)], opts).then(decodeResponse); // Get latest block

    return send([getBlock(sealed)], opts).then(decodeResponse);
  }

  function getEventsAtBlockHeightRange(eventType, start, end) {
    return pipe([makeGetEvents, function (ix) {
      ix.events.eventType = eventType;
      ix.events.start = start;
      ix.events.end = end;
      return Ok(ix);
    }]);
  }

  function getTransactionStatus(transactionId) {
    return pipe([makeGetTransactionStatus, function (ix) {
      ix.transaction.id = transactionId;
      return Ok(ix);
    }]);
  }

  function limit(computeLimit) {
    return function (ix) {
      ix.message.computeLimit = computeLimit;
      return ix;
    };
  }

  function args() {
    var ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return pipe(ax.map(makeArgument));
  }

  function arg(value, xform) {
    return {
      value: value,
      xform: xform
    };
  }

  function script() {
    return pipe([makeScript, put("ix.cadence", template.apply(void 0, arguments))]);
  }

  var type = function type(label, asArgument, asInjection) {
    return {
      label: label,
      asArgument: asArgument,
      asInjection: asInjection
    };
  };

  var isArray$2 = function isArray(d) {
    return Array.isArray(d);
  };

  var isObj = function isObj(d) {
    return _typeof$1(d) === "object";
  };

  var isNull = function isNull(d) {
    return d == null;
  };

  var isBoolean = function isBoolean(d) {
    return typeof d === "boolean";
  };

  var isNumber = function isNumber(d) {
    return typeof d === "number";
  };

  var isInteger = function isInteger(d) {
    return Number.isInteger(d);
  };

  var isString$1 = function isString(d) {
    return typeof d === "string";
  };

  var throwTypeError = function throwTypeError(msg) {
    throw new Error("Type Error: " + msg);
  };

  var numberValuesDeprecationNotice = function numberValuesDeprecationNotice(type) {
    log.deprecate({
      pkg: "@onflow/types",
      subject: "Passing in Number as value for ".concat(type),
      message: "Going forward, use String as value for ".concat(type, "."),
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0002-[U]Int*-and-Word*-as-Number"
    });
  };

  var Identity = type("Identity", function (v) {
    return v;
  }, function (v) {
    return v;
  });
  var UInt = type("UInt", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt");
      return {
        type: "UInt",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "UInt",
        value: v
      };
    }

    throwTypeError("Expected Positive Integer for type Unsigned Int");
  }, function (v) {
    return v;
  });
  var Int = type("Int", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int");
      return {
        type: "Int",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Int",
        value: v
      };
    }

    throwTypeError("Expected Integer for type Int");
  }, function (v) {
    return v;
  });
  var UInt8 = type("UInt8", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt8");
      return {
        type: "UInt8",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "UInt8",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt8");
  }, function (v) {
    return v;
  });
  var Int8 = type("Int8", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int8");
      return {
        type: "Int8",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Int8",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int8");
  }, function (v) {
    return v;
  });
  var UInt16 = type("UInt16", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt16");
      return {
        type: "UInt16",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "UInt16",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt16");
  }, function (v) {
    return v;
  });
  var Int16 = type("Int16", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int16");
      return {
        type: "Int16",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Int16",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int16");
  }, function (v) {
    return v;
  });
  var UInt32 = type("UInt32", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt32");
      return {
        type: "UInt32",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "UInt32",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt32");
  }, function (v) {
    return v;
  });
  var Int32 = type("Int32", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int32");
      return {
        type: "Int32",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Int32",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int32");
  }, function (v) {
    return v;
  });
  var UInt64 = type("UInt64", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt64");
      return {
        type: "UInt64",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "UInt64",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt64");
  }, function (v) {
    return v;
  });
  var Int64 = type("Int64", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int64");
      return {
        type: "Int64",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Int64",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int64");
  }, function (v) {
    return v;
  });
  var UInt128 = type("UInt128", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt128");
      return {
        type: "UInt128",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "UInt128",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt128");
  }, function (v) {
    return v;
  });
  var Int128 = type("Int128", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int128");
      return {
        type: "Int128",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Int128",
        value: v
      };
    }

    throwTypeError("Expected positive integer for Int128");
  }, function (v) {
    return v;
  });
  var UInt256 = type("UInt256", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("UInt256");
      return {
        type: "UInt256",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "UInt256",
        value: v
      };
    }

    throwTypeError("Expected integer for UInt256");
  }, function (v) {
    return v;
  });
  var Int256 = type("Int256", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Int256");
      return {
        type: "Int256",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Int256",
        value: v
      };
    }

    throwTypeError("Expected integer for Int256");
  }, function (v) {
    return v;
  });
  var Word8 = type("Word8", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word8");
      return {
        type: "Word8",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Word8",
        value: v
      };
    }

    throwTypeError("Expected positive number for Word8");
  }, function (v) {
    return v;
  });
  var Word16 = type("Word16", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word16");
      return {
        type: "Word16",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Word16",
        value: v
      };
    }

    throwTypeError("Expected positive number for Word16");
  }, function (v) {
    return v;
  });
  var Word32 = type("Word32", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word32");
      return {
        type: "Word32",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Word32",
        value: v
      };
    }

    throwTypeError("Expected positive number for Word32");
  }, function (v) {
    return v;
  });
  var Word64 = type("Word64", function (v) {
    if (isNumber(v) && isInteger(v)) {
      numberValuesDeprecationNotice("Word64");
      return {
        type: "Word64",
        value: v.toString()
      };
    }

    if (isString$1(v)) {
      return {
        type: "Word64",
        value: v
      };
    }

    throwTypeError("Expected positive number for Word64");
  }, function (v) {
    return v;
  });

  var UFix64AndFix64NumberDeprecationNotice = function UFix64AndFix64NumberDeprecationNotice() {
    log.deprecate({
      subject: "Passing in Numbers as values for Fix64 and UFix64 types",
      pkg: "@onflow/types",
      transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/types/WARNINGS.md#0001-[U]Fix64-as-Number"
    });
  };

  var UFix64 = type("UFix64", function (v) {
    if (isString$1(v)) {
      var vParts = v.split(".");

      if (vParts.length !== 2) {
        throwTypeError("Expected one decimal but found ".concat(vParts.length, " in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers"));
      }

      if (vParts[1].length == 0 || vParts[1].length > 8) {
        throwTypeError("Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ".concat(vParts[1].length, " digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers"));
      } // make sure the number is extended to 8 decimal places so it matches cadence encoding of UFix values


      vParts[1] = vParts[1].padEnd(8, "0");
      v = vParts.join(".");
      return {
        type: "UFix64",
        value: v
      };
    } else if (isNumber(v)) {
      UFix64AndFix64NumberDeprecationNotice();
      return {
        type: "UFix64",
        value: v.toString()
      };
    }

    throwTypeError("Expected String for UFix64");
  }, function (v) {
    return v;
  });
  var Fix64 = type("Fix64", function (v) {
    if (isString$1(v)) {
      var vParts = v.split(".");

      if (vParts.length !== 2) {
        throwTypeError("Expected one decimal but found ".concat(vParts.length, " in the [U]Fix64 value. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers"));
      }

      if (vParts[1].length == 0 || vParts[1].length > 8) {
        throwTypeError("Expected at least one digit, and at most 8 digits following the decimal of the [U]Fix64 value but found ".concat(vParts[1].length, " digits. Find out more about [U]Fix64 types here: https://docs.onflow.org/cadence/json-cadence-spec/#fixed-point-numbers"));
      } // make sure the number is extended to 8 decimal places so it matches cadence encoding of Fix64 values


      vParts[1] = vParts[1].padEnd(8, "0");
      v = vParts.join(".");
      return {
        type: "Fix64",
        value: v
      };
    } else if (isNumber(v)) {
      UFix64AndFix64NumberDeprecationNotice();
      return {
        type: "Fix64",
        value: v.toString()
      };
    }

    throwTypeError("Expected String for Fix64");
  }, function (v) {
    return v;
  });
  var String$1 = type("String", function (v) {
    if (isString$1(v)) return {
      type: "String",
      value: v
    };
    throwTypeError("Expected String for type String");
  }, function (v) {
    return v;
  });
  var Character = type("Character", function (v) {
    if (isString$1(v)) return {
      type: "Character",
      value: v
    };
    throwTypeError("Expected Character for type Character");
  }, function (v) {
    return v;
  });
  var Bool = type("Bool", function (v) {
    if (isBoolean(v)) return {
      type: "Bool",
      value: v
    };
    throwTypeError("Expected Boolean for type Bool");
  }, function (v) {
    return v;
  });
  var Address = type("Address", function (v) {
    if (isString$1(v)) return {
      type: "Address",
      value: v
    };
    throwTypeError("Expected Address for type Address");
  }, function (v) {
    return v;
  });
  var Void = type("Void", function (v) {
    if (!v || isNull(v)) return {
      type: "Void"
    };
    throwTypeError("Expected Void for type Void");
  }, function (v) {
    return v;
  });

  var Optional = function Optional(children) {
    return type("Optional", function (v) {
      return {
        type: "Optional",
        value: isNull(v) ? null : children.asArgument(v)
      };
    }, function (v) {
      return v;
    });
  };

  var Reference = type("Reference", function (v) {
    if (isObj(v)) return {
      type: "Reference",
      value: v
    };
    throwTypeError("Expected Object for type Reference");
  }, function (v) {
    return v;
  });

  var _Array = function _Array() {
    var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return type("Array", function (v) {
      return {
        type: "Array",
        value: isArray$2(children) ? children.map(function (c, i) {
          return c.asArgument(v[i]);
        }) : v.map(function (x) {
          return children.asArgument(x);
        })
      };
    }, function (v) {
      return v;
    });
  };

  var Dictionary = function Dictionary() {
    var children = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return type("Dictionary", function (v) {
      if (isObj(v)) return {
        type: "Dictionary",
        value: isArray$2(children) ? children.map(function (c, i) {
          return {
            key: c.key.asArgument(v[i].key),
            value: c.value.asArgument(v[i].value)
          };
        }) : isArray$2(v) ? v.map(function (x) {
          return {
            key: children.key.asArgument(x.key),
            value: children.value.asArgument(x.value)
          };
        }) : [{
          key: children.key.asArgument(v.key),
          value: children.value.asArgument(v.value)
        }]
      };
      throwTypeError("Expected Object for type Dictionary");
    }, function (v) {
      return v;
    });
  };

  var Event = function Event(id) {
    var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return type("Event", function (v) {
      if (isObj(v)) return {
        type: "Event",
        value: {
          id: id,
          fields: isArray$2(fields) ? fields.map(function (c, i) {
            return {
              name: v.fields[i].name,
              value: c.value.asArgument(v.fields[i].value)
            };
          }) : v.fields.map(function (x) {
            return {
              name: x.name,
              value: fields.value.asArgument(x.value)
            };
          })
        }
      };
      throwTypeError("Expected Object for type Event");
    }, function (v) {
      return v;
    });
  };

  var Resource = function Resource(id) {
    var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return type("Resource", function (v) {
      if (isObj(v)) return {
        type: "Resource",
        value: {
          id: id,
          fields: isArray$2(fields) ? fields.map(function (c, i) {
            return {
              name: v.fields[i].name,
              value: c.value.asArgument(v.fields[i].value)
            };
          }) : v.fields.map(function (x) {
            return {
              name: x.name,
              value: fields.value.asArgument(x.value)
            };
          })
        }
      };
      throwTypeError("Expected Object for type Resource");
    }, function (v) {
      return v;
    });
  };

  var Struct = function Struct(id) {
    var fields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return type("Struct", function (v) {
      if (isObj(v)) return {
        type: "Struct",
        value: {
          id: id,
          fields: isArray$2(fields) ? fields.map(function (c, i) {
            return {
              name: v.fields[i].name,
              value: c.value.asArgument(v.fields[i].value)
            };
          }) : v.fields.map(function (x) {
            return {
              name: x.name,
              value: fields.value.asArgument(x.value)
            };
          })
        }
      };
      throwTypeError("Expected Object for type Struct");
    }, function (v) {
      return v;
    });
  };

  var Path = type("Path", function (v) {
    if (isObj(v)) {
      if (!isString$1(v.domain)) {
        throwTypeError("Expected a string for the Path domain but found ".concat(v.domain, ". Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path"));
      }

      if (!(v.domain === "storage" || v.domain === "private" || v.domain === "public")) {
        throwTypeError("Expected either \"storage\", \"private\" or \"public\" as the Path domain but found ".concat(v.domain, ". Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path"));
      }

      if (!isString$1(v.identifier)) {
        throwTypeError("Expected a string for the Path identifier but found ".concat(v.identifier, ". Find out more about the Path type here: https://docs.onflow.org/cadence/json-cadence-spec/#path"));
      }

      return {
        type: "Path",
        value: {
          domain: v.domain,
          identifier: v.identifier
        }
      };
    }

    throwTypeError("Expected Object for type Path");
  }, function (v) {
    return v;
  });

  var t$1$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Address: Address,
    Array: _Array,
    Bool: Bool,
    Character: Character,
    Dictionary: Dictionary,
    Event: Event,
    Fix64: Fix64,
    Identity: Identity,
    Int: Int,
    Int128: Int128,
    Int16: Int16,
    Int256: Int256,
    Int32: Int32,
    Int64: Int64,
    Int8: Int8,
    Optional: Optional,
    Path: Path,
    Reference: Reference,
    Resource: Resource,
    String: String$1,
    Struct: Struct,
    UFix64: UFix64,
    UInt: UInt,
    UInt128: UInt128,
    UInt16: UInt16,
    UInt256: UInt256,
    UInt32: UInt32,
    UInt64: UInt64,
    UInt8: UInt8,
    Void: Void,
    Word16: Word16,
    Word32: Word32,
    Word64: Word64,
    Word8: Word8,
    _Array: _Array
  });

  // Inspired by: https://github.com/lukeed/uid/blob/master/src/index.js , thank you Luke! https://github.com/lukeed
  var HEX = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  var T$7 = HEX.length;

  function uid() {
    var str = "",
        num = 32;

    while (num--) {
      str += HEX[Math.random() * T$7 | 0];
    }

    return str;
  }

  var isServerSide = function isServerSide() {
    return typeof window === "undefined";
  };

  var SESSION_STORAGE = {
    can: !isServerSide(),
    get: function () {
      var _get = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(key) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", JSON.parse(sessionStorage.getItem(key)));

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      function get(_x) {
        return _get.apply(this, arguments);
      }

      return get;
    }(),
    put: function () {
      var _put = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(key, value) {
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", sessionStorage.setItem(key, JSON.stringify(value)));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }));

      function put(_x2, _x3) {
        return _put.apply(this, arguments);
      }

      return put;
    }()
  };
  config({
    "discovery.wallet.method.default": "IFRAME/RPC",
    "fcl.storage.default": SESSION_STORAGE
  });

  var VERSION = "1.3.0";

  var is$1 = function is(type) {
    return function (d) {
      return _typeof$1(d) === type;
    };
  };

  var isRequired = function isRequired(d) {
    return d != null;
  };

  var isObject = is$1("object");
  var isString = is$1("string");
  var isFunc = is$1("function");

  function normalizeArgs(ax) {
    if (isFunc(ax)) return ax(arg, t$1$1);
    return [];
  }

  function httpDocumentResolver(_x) {
    return _httpDocumentResolver.apply(this, arguments);
  }

  function _httpDocumentResolver() {
    _httpDocumentResolver = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
      var url, res, document;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              url = _ref.url;
              invariant$1(typeof url !== "undefined", "retrieve({ url }) -- url must be defined");
              _context.prev = 2;
              _context.next = 5;
              return fetchTransport(url);

            case 5:
              res = _context.sent;
              _context.next = 11;
              break;

            case 8:
              _context.prev = 8;
              _context.t0 = _context["catch"](2);
              throw new Error("httpDocumentResolver Error: Failed to retrieve document.");

            case 11:
              if (!res.ok) {
                _context.next = 17;
                break;
              }

              _context.next = 14;
              return res.json();

            case 14:
              _context.t1 = _context.sent;
              _context.next = 18;
              break;

            case 17:
              _context.t1 = null;

            case 18:
              document = _context.t1;
              return _context.abrupt("return", document);

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[2, 8]]);
    }));
    return _httpDocumentResolver.apply(this, arguments);
  }

  var DOCUMENT_RESOLVERS = new Map([["http", httpDocumentResolver], ["https", httpDocumentResolver]]);

  function retrieve(_x2) {
    return _retrieve.apply(this, arguments);
  }

  function _retrieve() {
    _retrieve = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(_ref2) {
      var url, documentResolversFromConfig, urlParts, protocol, resolver, document;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              url = _ref2.url;
              invariant$1(typeof url !== "undefined", "retrieve({ url }) -- url must be defined");
              invariant$1(typeof url === "string", "retrieve({ url }) -- url must be a string");
              _context2.next = 5;
              return config().where(/^document\.resolver\./);

            case 5:
              documentResolversFromConfig = _context2.sent;
              Object.keys(documentResolversFromConfig).map(function (key) {
                var resolverFromConfig = documentResolversFromConfig[key];
                var resolverProtocol = key.replace(/^document\.resolver\./, "");
                DOCUMENT_RESOLVERS.set(resolverProtocol, resolverFromConfig);
              });
              urlParts = /^(.*):\/\/([A-Za-z0-9\-\.]+)(:[0-9]+)?(.*)$/.exec(url);
              invariant$1(urlParts, "Failed to parse URL");
              protocol = urlParts[1];
              invariant$1(urlParts, "Failed to parse URL protocol");
              resolver = DOCUMENT_RESOLVERS.get(protocol);
              invariant$1(resolver, "No resolver found for protcol=".concat(protocol));
              _context2.next = 15;
              return resolver({
                url: url
              });

            case 15:
              document = _context2.sent;
              return _context2.abrupt("return", document);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _retrieve.apply(this, arguments);
  }

  function normalizeInteractionTemplate(template) {
    if (template == null) return null;

    switch (template["f_version"]) {
      case "1.0.0":
        return template;

      default:
        throw new Error("normalizeInteractionTemplate Error: Invalid InteractionTemplate");
    }
  }

  function deriveCadenceByNetwork(_ref) {
    var _template, _template$data;

    var network = _ref.network,
        template = _ref.template;
    invariant(network != undefined, "deriveCadenceByNetwork({ network }) -- network must be defined");
    invariant(typeof network === "string", "deriveCadenceByNetwork({ network }) -- network must be a string");
    invariant(template != undefined, "generateDependencyPin({ template }) -- template must be defined");
    invariant(_typeof$1(template) === "object", "generateDependencyPin({ template }) -- template must be an object");
    invariant(template.f_type === "InteractionTemplate", "generateDependencyPin({ template }) -- template must be an InteractionTemplate");
    template = normalizeInteractionTemplate(template);

    switch (template.f_version) {
      case "1.0.0":
        var networkDependencies = Object.keys((_template = template) === null || _template === void 0 ? void 0 : (_template$data = _template.data) === null || _template$data === void 0 ? void 0 : _template$data.dependencies).map(function (dependencyPlaceholder) {
          var _template2, _template2$data, _template2$data$depen;

          var dependencyNetworkContracts = Object.values((_template2 = template) === null || _template2 === void 0 ? void 0 : (_template2$data = _template2.data) === null || _template2$data === void 0 ? void 0 : (_template2$data$depen = _template2$data.dependencies) === null || _template2$data$depen === void 0 ? void 0 : _template2$data$depen[dependencyPlaceholder]);
          invariant(dependencyNetworkContracts, "deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ".concat(dependencyPlaceholder));
          invariant(dependencyNetworkContracts.length === 0, "deriveCadenceByNetwork -- Could not find contracts for dependency placeholder: ".concat(dependencyPlaceholder));
          var dependencyContract = dependencyNetworkContracts[0];
          var dependencyContractForNetwork = dependencyContract === null || dependencyContract === void 0 ? void 0 : dependencyContract[network];
          invariant(dependencyContractForNetwork, "deriveCadenceByNetwork -- Could not find ".concat(network, " network information for dependency: ").concat(dependencyPlaceholder));
          return [dependencyPlaceholder, dependencyContractForNetwork.address];
        });
        return networkDependencies.reduce(function (cadence, _ref2) {
          var _ref3 = _slicedToArray(_ref2, 2),
              placeholder = _ref3[0],
              address = _ref3[1];

          var regex = new RegExp("(\\b" + placeholder + "\\b)", "g");
          return cadence.replace(regex, address);
        }, template.data.cadence);

      default:
        throw new Error("deriveCadenceByNetwork Error: Unsupported template version");
    }
  }

  function deriveDependencies(_x) {
    return _deriveDependencies.apply(this, arguments);
  }

  function _deriveDependencies() {
    _deriveDependencies = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
      var _template$data;

      var template, network, derivedDependencies, dependencyPlaceholderKeys, _i, _dependencyPlaceholde, _template$data2, dependencyPlaceholderKey, dependencyPlaceholder, dependencyPlaceholderContractsKeys, dependencyPlaceholderContract, dependency;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              template = _ref.template;
              _context.next = 3;
              return config.get("flow.network");

            case 3:
              network = _context.sent;
              invariant$1(network, "FCL configureDependencies Error: Missing configuration value for 'flow.network'");
              derivedDependencies = {};
              _context.t0 = template["f_version"];
              _context.next = _context.t0 === "1.0.0" ? 9 : 12;
              break;

            case 9:
              dependencyPlaceholderKeys = Object.keys(template === null || template === void 0 ? void 0 : (_template$data = template.data) === null || _template$data === void 0 ? void 0 : _template$data.dependencies);

              for (_i = 0, _dependencyPlaceholde = dependencyPlaceholderKeys; _i < _dependencyPlaceholde.length; _i++) {
                dependencyPlaceholderKey = _dependencyPlaceholde[_i];
                dependencyPlaceholder = template === null || template === void 0 ? void 0 : (_template$data2 = template.data) === null || _template$data2 === void 0 ? void 0 : _template$data2.dependencies[dependencyPlaceholderKey];
                dependencyPlaceholderContractsKeys = Object.keys(dependencyPlaceholder);
                invariant$1(dependencyPlaceholderContractsKeys.length > 0, "FCL configureDependencies Error: No contracts found in template for placeholder=".concat(dependencyPlaceholderKey));
                dependencyPlaceholderContract = dependencyPlaceholder[dependencyPlaceholderContractsKeys[0]];
                dependency = dependencyPlaceholderContract[network];
                invariant$1(dependency, "FCL configureDependencies Error: No dependency information for placeholder=".concat(dependencyPlaceholderKey, " contract=").concat(dependencyPlaceholderContractsKeys[0], " network=").concat(network));
                invariant$1(dependency === null || dependency === void 0 ? void 0 : dependency.address, "FCL configureDependencies Error: No address information for placeholder=".concat(dependencyPlaceholderKey, " contract=").concat(dependencyPlaceholderContractsKeys[0], " network=").concat(network));
                derivedDependencies[dependencyPlaceholderKey] = withPrefix$1(dependency === null || dependency === void 0 ? void 0 : dependency.address);
              }

              return _context.abrupt("return", derivedDependencies);

            case 12:
              throw new Error("FCL configureDependencies Error: Unsupported template version");

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _deriveDependencies.apply(this, arguments);
  }

  function prepTemplateOpts(_x) {
    return _prepTemplateOpts.apply(this, arguments);
  }

  function _prepTemplateOpts() {
    _prepTemplateOpts = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(opts) {
      var dependencies, cadence;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!isString(opts === null || opts === void 0 ? void 0 : opts.template)) {
                _context.next = 4;
                break;
              }

              _context.next = 3;
              return retrieve({
                url: opts === null || opts === void 0 ? void 0 : opts.template
              });

            case 3:
              opts.template = _context.sent;

            case 4:
              dependencies = {};

              if (!(opts !== null && opts !== void 0 && opts.template)) {
                _context.next = 10;
                break;
              }

              opts.template = normalizeInteractionTemplate(opts === null || opts === void 0 ? void 0 : opts.template);
              _context.next = 9;
              return deriveDependencies({
                template: opts.template
              });

            case 9:
              dependencies = _context.sent;

            case 10:
              _context.t0 = opts.cadence;

              if (_context.t0) {
                _context.next = 19;
                break;
              }

              _context.t1 = deriveCadenceByNetwork;
              _context.t2 = opts.template;
              _context.next = 16;
              return config().get("flow.network");

            case 16:
              _context.t3 = _context.sent;
              _context.t4 = {
                template: _context.t2,
                network: _context.t3
              };
              _context.t0 = (0, _context.t1)(_context.t4);

            case 19:
              cadence = _context.t0;
              opts.cadence = cadence;
              opts.dependencies = dependencies;
              return _context.abrupt("return", opts);

            case 23:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _prepTemplateOpts.apply(this, arguments);
  }

  function pre(_x, _x2) {
    return _pre.apply(this, arguments);
  }

  function _pre() {
    _pre = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(type, opts) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              // prettier-ignore
              invariant$1(isRequired(opts), "".concat(type, "(opts) -- opts is required")); // prettier-ignore

              invariant$1(isObject(opts), "".concat(type, "(opts) -- opts must be an object")); // prettier-ignore

              invariant$1(!(opts.cadence && opts.template), "".concat(type, "({ template, cadence }) -- cannot pass both cadence and template")); // prettier-ignore

              invariant$1(isRequired(opts.cadence || (opts === null || opts === void 0 ? void 0 : opts.template)), "".concat(type, "({ cadence }) -- cadence is required")); // // prettier-ignore

              invariant$1(isString(opts.cadence) || (opts === null || opts === void 0 ? void 0 : opts.template), "".concat(type, "({ cadence }) -- cadence must be a string")); // prettier-ignore

              _context.t0 = invariant$1;
              _context.t1 = opts.cadence;

              if (_context.t1) {
                _context.next = 11;
                break;
              }

              _context.next = 10;
              return config().get("flow.network");

            case 10:
              _context.t1 = _context.sent;

            case 11:
              _context.t2 = _context.t1;
              _context.t3 = "".concat(type, "(opts) -- Required value for \"flow.network\" not defined in config. See: ", "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration");
              (0, _context.t0)(_context.t2, _context.t3);
              _context.t4 = invariant$1;
              _context.next = 17;
              return config().get("accessNode.api");

            case 17:
              _context.t5 = _context.sent;
              _context.t6 = "".concat(type, "(opts) -- Required value for \"accessNode.api\" not defined in config. See: ", "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/src/exec/query.md#configuration");
              (0, _context.t4)(_context.t5, _context.t6);

            case 20:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _pre.apply(this, arguments);
  }

  function preQuery(_x4) {
    return _preQuery.apply(this, arguments);
  }

  function _preQuery() {
    _preQuery = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(opts) {
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", pre("query", opts));

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _preQuery.apply(this, arguments);
  }
  /** Query the Flow Blockchain
   *
   *  @arg {Object} opts         - Query Options and configuration
   *  @arg {string} opts.cadence - Cadence Script used to query Flow
   *  @arg {ArgsFn} opts.args    - Arguments passed to cadence script
   *  @arg {Object} opts.template - Interaction Template for a script
   *  @arg {number} opts.limit   - Compute Limit for Query
   *  @returns {Promise<Response>}
   *
   *  Where:
   *    @callback ArgsFn
   *    @arg {ArgFn}  arg - Argument function to define a single argument
   *    @arg {Object} t   - Cadence Types object used to define the type
   *    @returns {args[]}
   *
   *    @callback ArgFn
   *    @arg {Any}  value - the value of the argument
   *    @arg {Type} type  - the cadence type of the value
   *    @returns {arg}
   *
   *  Example:
   *    const cadence = `
   *      cadence: `
   *        pub fun main(a: Int, b: Int, c: Address): Int {
   *          log(c)
   *          return a + b
   *        }
   *    `.trim()
   *
   *    const args = (arg, t) => [
   *      arg(5, t.Int),
   *      arg(7, t.Int),
   *      arg("0xb2db43ad6bc345fec9", t.Address),
   *    ]
   *
   *    await query({ cadence, args })
   */


  function query() {
    return _query.apply(this, arguments);
  }

  function _query() {
    _query = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      var opts,
          _args2 = arguments;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              opts = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
              _context2.next = 3;
              return preQuery(opts);

            case 3:
              _context2.next = 5;
              return prepTemplateOpts(opts);

            case 5:
              opts = _context2.sent;
              return _context2.abrupt("return", config().overload(opts.dependencies || {}, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
                return regenerator.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        return _context.abrupt("return", // prettier-ignore
                        send([script(opts.cadence), args(normalizeArgs(opts.args || [])), opts.limit && typeof opts.limit === "number" && limit(opts.limit)]).then(decode$3));

                      case 1:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }))));

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _query.apply(this, arguments);
  }

  var SERVICE_PRAGMA = {
    f_type: "Service",
    f_vsn: "1.0.0"
  };
  var POLLING_RESPONSE_PRAGMA = {
    f_type: "PollingResponse",
    f_vsn: "1.0.0"
  };
  //    "f_vsn": "1.0.0",
  //    "type": "frame",
  //    "endpoint": "https://rawr",
  //    "data": {},   // Sent to frame when ready
  //    "params": {}, // include in query params on frame
  // }


  function normalizeFrame(service) {
    if (service == null) return null;

    switch (service["f_vsn"]) {
      case "1.0.0":
        return service;

      default:
        return _objectSpread2(_objectSpread2({
          old: service
        }, SERVICE_PRAGMA), {}, {
          type: "frame",
          endpoint: service.endpoint,
          params: service.params || {},
          data: service.data || {}
        });
    }
  } //    "f_type": "Service",
  //    "f_vsn": "1.0.0",
  //    "type": "back-channel-rpc",
  //    "endpoint": "https://rawr",
  //    "method": "HTTP/GET", // HTTP/GET | HTTP/POST
  //    "data": {},           // included in body of rpc
  //    "params": {},         // included as query params on endpoint url
  // }


  function normalizeBackChannelRpc(service) {
    if (service == null) return null;

    switch (service["f_vsn"]) {
      case "1.0.0":
        return service;

      default:
        return _objectSpread2(_objectSpread2({}, SERVICE_PRAGMA), {}, {
          type: "back-channel-rpc",
          endpoint: service.endpoint,
          method: service.method,
          params: service.params || {},
          data: service.data || {}
        });
    }
  } //   "f_type": "Service",
  //    "f_vsn": "1.0.0",
  //    type: "local-view",
  //    method: "VIEW/IFRAME",
  //    endpoint: "https://woot.org/authz/local",
  //    data: {},
  //    params: {},
  // }


  function normalizeLocalView(resp) {
    if (resp == null) return null;

    if (resp.method == null) {
      resp = _objectSpread2(_objectSpread2({}, resp), {}, {
        type: "local-view",
        method: "VIEW/IFRAME"
      });
    }

    switch (resp["f_vsn"]) {
      case "1.0.0":
        return resp;

      default:
        return _objectSpread2(_objectSpread2({}, SERVICE_PRAGMA), {}, {
          type: resp.type || "local-view",
          method: resp.method,
          endpoint: resp.endpoint,
          data: resp.data || {},
          params: resp.params || {}
        });
    }
  } // {

  function serviceEndpoint(service) {
    var url = new URL(service.endpoint);
    url.searchParams.append("l6n", window.location.origin);

    if (service.params != null) {
      for (var _i = 0, _Object$entries = Object.entries(service.params || {}); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            key = _Object$entries$_i[0],
            value = _Object$entries$_i[1];

        url.searchParams.append(key, value);
      }
    }

    return url;
  }

  function fetchService(service) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var method = opts.method || "POST";
    var body = method === "GET" ? undefined : JSON.stringify(opts.data || service.data || {});
    return fetch(serviceEndpoint(service), {
      method: method,
      headers: _objectSpread2(_objectSpread2(_objectSpread2({}, service.headers || {}), opts.headers || {}), {}, {
        "Content-Type": "application/json"
      }),
      body: body
    }).then(function (d) {
      return d.json();
    });
  } //    "f_type": "PollingResponse",
  //    "f_vsn": "1.0.0",
  //    "status": "PENDING", // PENDING | APPROVED | DECLINED | REDIRECT
  //    "reason": null,      // Reason for Declining Transaction
  //    "data": null,        // Return value for APPROVED
  //    "updates": BackChannelRpc,
  //    "local": Frame,
  // }


  function normalizePollingResponse(resp) {
    var _resp$status, _resp$reason;

    if (resp == null) return null;

    switch (resp["f_vsn"]) {
      case "1.0.0":
        return resp;

      default:
        return _objectSpread2(_objectSpread2({}, POLLING_RESPONSE_PRAGMA), {}, {
          status: (_resp$status = resp.status) !== null && _resp$status !== void 0 ? _resp$status : "APPROVED",
          reason: (_resp$reason = resp.reason) !== null && _resp$reason !== void 0 ? _resp$reason : null,
          data: resp.compositeSignature || resp.data || _objectSpread2({}, resp) || {},
          updates: normalizeBackChannelRpc(resp.authorizationUpdates),
          local: normalizeFrame((resp.local || [])[0])
        });
    }
  }

  var OPTIONS = {
    "HTTP/GET": "GET",
    "HTTP/POST": "POST"
  };

  var serviceMethod = function serviceMethod(service) {
    invariant$1(OPTIONS[service.method], "Invalid Service Method for type back-channel-rpc", {
      service: service
    });
    return OPTIONS[service.method];
  };

  function poll(_x) {
    return _poll.apply(this, arguments);
  }

  function _poll() {
    _poll = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(service) {
      var canContinue,
          resp,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              canContinue = _args.length > 1 && _args[1] !== undefined ? _args[1] : function () {
                return true;
              };
              invariant$1(service, "Missing Polling Service", {
                service: service
              });

              if (canContinue()) {
                _context.next = 4;
                break;
              }

              throw new Error("Externally Halted");

            case 4:
              _context.next = 6;
              return fetchService(service, {
                method: serviceMethod(service)
              }).then(normalizePollingResponse);

            case 6:
              resp = _context.sent;
              _context.t0 = resp.status;
              _context.next = _context.t0 === "APPROVED" ? 10 : _context.t0 === "DECLINED" ? 11 : 12;
              break;

            case 10:
              return _context.abrupt("return", resp.data);

            case 11:
              throw new Error("Declined: ".concat(resp.reason || "No reason supplied."));

            case 12:
              _context.next = 14;
              return new Promise(function (r) {
                return setTimeout(r, 500);
              });

            case 14:
              return _context.abrupt("return", poll(resp.updates, canContinue));

            case 15:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _poll.apply(this, arguments);
  }

  var FRAME = "FCL_IFRAME";
  var FRAME_STYLES = "\n  position:fixed;\n  top: 0px;\n  right: 0px;\n  bottom: 0px;\n  left: 0px;\n  height: 100%;\n  width: 100vw;\n  display:block;\n  background:rgba(0,0,0,0.25);\n  z-index: 2147483647;\n  box-sizing: border-box;\n";

  function renderFrame(src) {
    invariant$1(!document.getElementById(FRAME), "Attempt at triggering multiple Frames", {
      src: src
    });
    var $frame = document.createElement("iframe");
    $frame.src = src;
    $frame.id = FRAME;
    $frame.allow = "usb *; hid *";
    $frame.frameBorder = "0";
    $frame.style.cssText = FRAME_STYLES;
    document.body.append($frame);

    var unmount = function unmount() {
      if (document.getElementById(FRAME)) {
        document.getElementById(FRAME).remove();
      }
    };

    return [$frame.contentWindow, unmount];
  }

  var POP = "FCL_POP";
  var popup = null;
  var previousUrl$1 = null;

  function popupWindow(url, windowName, win, w, h) {
    var y = win.top.outerHeight / 2 + win.top.screenY - h / 2;
    var x = win.top.outerWidth / 2 + win.top.screenX - w / 2;
    var popup = win.open(url, windowName, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=no, resizable=no, copyhistory=no, width=".concat(w, ", height=").concat(h, ", top=").concat(y, ", left=").concat(x));
    if (!popup) throw new Error("Popup failed to open (was it blocked by a popup blocker?)");
    return popup;
  }

  function renderPop(src) {
    var _popup;

    if (popup == null || (_popup = popup) !== null && _popup !== void 0 && _popup.closed) {
      popup = popupWindow(src, POP, window, 640, 770);
    } else if (previousUrl$1 !== src) {
      popup.location.replace(src);
      popup.focus();
    } else {
      popup.focus();
    }

    previousUrl$1 = src;

    var unmount = function unmount() {
      if (popup && !popup.closed) {
        popup.close();
      }

      popup = null;
    };

    return [popup, unmount];
  }

  var tab$1 = null;
  var previousUrl = null;

  function renderTab(src) {
    var _tab;

    if (tab$1 == null || (_tab = tab$1) !== null && _tab !== void 0 && _tab.closed) {
      tab$1 = window.open(src, "_blank");
      if (!tab$1) throw new Error("Tab failed to open (was it blocked by the browser?)");
    } else if (previousUrl !== src) {
      tab$1.location.replace(src);
      tab$1.focus();
    } else {
      tab$1.focus();
    }

    previousUrl = src;

    var unmount = function unmount() {
      if (tab$1 && !tab$1.closed) {
        tab$1.close();
      }

      tab$1 = null;
    };

    return [tab$1, unmount];
  }

  var VIEWS = {
    "VIEW/IFRAME": renderFrame,
    "VIEW/POP": renderPop,
    "VIEW/TAB": renderTab
  };

  function execLocal(_x) {
    return _execLocal.apply(this, arguments);
  }

  function _execLocal() {
    _execLocal = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(service) {
      var opts,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.prev = 1;
              return _context.abrupt("return", VIEWS[service.method](serviceEndpoint(service), opts));

            case 5:
              _context.prev = 5;
              _context.t0 = _context["catch"](1);
              console.error("execLocal({service, opts = {}})", _context.t0, {
                service: service,
                opts: opts
              });
              throw _context.t0;

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[1, 5]]);
    }));
    return _execLocal.apply(this, arguments);
  }

  function execHttpPost(_x) {
    return _execHttpPost.apply(this, arguments);
  }

  function _execHttpPost() {
    _execHttpPost = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
      var service, body, config, resp, canContinue, _yield$execLocal, _yield$execLocal2, unmount, close;

      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              service = _ref.service, body = _ref.body, config = _ref.config, _ref.opts;
              _context.next = 3;
              return fetchService(service, {
                data: _objectSpread2({
                  fclVersion: VERSION,
                  service: {
                    params: service.params,
                    data: service.data,
                    type: service.type
                  },
                  config: config
                }, body)
              }).then(normalizePollingResponse);

            case 3:
              resp = _context.sent;

              if (!(resp.status === "APPROVED")) {
                _context.next = 8;
                break;
              }

              return _context.abrupt("return", resp.data);

            case 8:
              if (!(resp.status === "DECLINED")) {
                _context.next = 12;
                break;
              }

              throw new Error("Declined: ".concat(resp.reason || "No reason supplied."));

            case 12:
              if (!(resp.status === "REDIRECT")) {
                _context.next = 16;
                break;
              }

              return _context.abrupt("return", resp);

            case 16:
              if (!(resp.status === "PENDING")) {
                _context.next = 28;
                break;
              }

              canContinue = true;
              _context.next = 20;
              return execLocal(normalizeLocalView(resp.local));

            case 20:
              _yield$execLocal = _context.sent;
              _yield$execLocal2 = _slicedToArray(_yield$execLocal, 2);
              _yield$execLocal2[0];
              unmount = _yield$execLocal2[1];

              close = function close() {
                try {
                  unmount();
                  canContinue = false;
                } catch (error) {
                  console.error("Frame Close Error", error);
                }
              };

              return _context.abrupt("return", poll(resp.updates, function () {
                return canContinue;
              }).then(function (serviceResponse) {
                close();
                return serviceResponse;
              })["catch"](function (error) {
                console.error(error);
                close();
                throw error;
              }));

            case 28:
              console.error("Auto Decline: Invalid Response", {
                service: service,
                resp: resp
              });
              throw new Error("Auto Decline: Invalid Response");

            case 30:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _execHttpPost.apply(this, arguments);
  }

  var CLOSE_EVENT = "FCL:VIEW:CLOSE";
  var READY_EVENT = "FCL:VIEW:READY";
  var RESPONSE_EVENT = "FCL:VIEW:RESPONSE";

  var _$5 = function _(e) {
    return typeof e === "string" && e.toLowerCase();
  };

  var IGNORE = new Set(["monetizationstart", "monetizationpending", "monetizationprogress", "monetizationstop"]);

  var deprecate = function deprecate(was, want) {
    return console.warn("DEPRECATION NOTICE", "Received ".concat(was, ", please use ").concat(want, " for this and future versions of FCL"));
  };

  var buildMessageHandler = function buildMessageHandler(_ref) {
    var close = _ref.close,
        send = _ref.send,
        onReady = _ref.onReady,
        onResponse = _ref.onResponse,
        onMessage = _ref.onMessage;
    return function (e) {
      try {
        if (_typeof$1(e.data) !== "object") return;
        if (IGNORE.has(e.data.type)) return;
        if (_$5(e.data.type) === _$5(CLOSE_EVENT)) close();
        if (_$5(e.data.type) === _$5(READY_EVENT)) onReady(e, {
          send: send,
          close: close
        });
        if (_$5(e.data.type) === _$5(RESPONSE_EVENT)) onResponse(e, {
          send: send,
          close: close
        });
        onMessage(e, {
          send: send,
          close: close
        }); // Backwards Compatible

        if (_$5(e.data.type) === _$5("FCL:FRAME:READY")) {
          deprecate(e.data.type, READY_EVENT);
          onReady(e, {
            send: send,
            close: close
          });
        }

        if (_$5(e.data.type) === _$5("FCL:FRAME:RESPONSE")) {
          deprecate(e.data.type, RESPONSE_EVENT);
          onResponse(e, {
            send: send,
            close: close
          });
        }

        if (_$5(e.data.type) === _$5("FCL:FRAME:CLOSE")) {
          deprecate(e.data.type, CLOSE_EVENT);
          close();
        } //


        if (_$5(e.data.type) === _$5("FCL::CHALLENGE::RESPONSE")) {
          deprecate(e.data.type, RESPONSE_EVENT);
          onResponse(e, {
            send: send,
            close: close
          });
        }

        if (_$5(e.data.type) === _$5("FCL::AUTHZ_READY")) {
          deprecate(e.data.type, READY_EVENT);
          onReady(e, {
            send: send,
            close: close
          });
        }

        if (_$5(e.data.type) === _$5("FCL::CHALLENGE::CANCEL")) {
          deprecate(e.data.type, CLOSE_EVENT);
          close();
        }

        if (_$5(e.data.type) === _$5("FCL::CANCEL")) {
          deprecate(e.data.type, CLOSE_EVENT);
          close();
        }
      } catch (error) {
        console.error("Frame Callback Error", error);
        close();
      }
    };
  };

  var noop$3 = function noop() {};

  function frame(service) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (service == null) return {
      send: noop$3,
      close: noop$3
    };
    var onClose = opts.onClose || noop$3;
    var onMessage = opts.onMessage || noop$3;
    var onReady = opts.onReady || noop$3;
    var onResponse = opts.onResponse || noop$3;
    var handler = buildMessageHandler({
      close: close,
      send: send,
      onReady: onReady,
      onResponse: onResponse,
      onMessage: onMessage
    });
    window.addEventListener("message", handler);

    var _renderFrame = renderFrame(serviceEndpoint(service)),
        _renderFrame2 = _slicedToArray(_renderFrame, 2),
        $frame = _renderFrame2[0],
        unmount = _renderFrame2[1];

    return {
      send: send,
      close: close
    };

    function close() {
      try {
        window.removeEventListener("message", handler);
        unmount();
        onClose();
      } catch (error) {
        console.error("Frame Close Error", error);
      }
    }

    function send(msg) {
      try {
        $frame.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
      } catch (error) {
        console.error("Frame Send Error", msg, error);
      }
    }
  }

  function execIframeRPC(_ref) {
    var service = _ref.service,
        body = _ref.body,
        config = _ref.config,
        opts = _ref.opts;
    return new Promise(function (resolve, reject) {
      var id = uid();
      var includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
      frame(service, {
        onReady: function onReady(_, _ref2) {
          return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
            var send;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    send = _ref2.send;
                    _context.prev = 1;
                    send({
                      type: "FCL:VIEW:READY:RESPONSE",
                      fclVersion: VERSION,
                      body: body,
                      service: {
                        params: service.params,
                        data: service.data,
                        type: service.type
                      },
                      config: config
                    });
                    send({
                      fclVersion: VERSION,
                      type: "FCL:FRAME:READY:RESPONSE",
                      body: body,
                      service: {
                        params: service.params,
                        data: service.data,
                        type: service.type
                      },
                      config: config,
                      deprecated: {
                        message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
                      }
                    });

                    if (includeOlderJsonRpcCall) {
                      send({
                        jsonrpc: "2.0",
                        id: id,
                        method: "fcl:sign",
                        params: [body, service.params],
                        deprecated: {
                          message: "jsonrpc is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
                        }
                      });
                    }

                    _context.next = 10;
                    break;

                  case 7:
                    _context.prev = 7;
                    _context.t0 = _context["catch"](1);
                    throw _context.t0;

                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[1, 7]]);
          }))();
        },
        onResponse: function onResponse(e, _ref3) {
          var close = _ref3.close;

          try {
            if (_typeof$1(e.data) !== "object") return;
            var resp = normalizePollingResponse(e.data);

            switch (resp.status) {
              case "APPROVED":
                resolve(resp.data);
                close();
                break;

              case "DECLINED":
                reject("Declined: ".concat(resp.reason || "No reason supplied"));
                close();
                break;

              case "REDIRECT":
                resolve(resp);
                close();
                break;

              default:
                reject("Declined: No reason supplied");
                close();
                break;
            }
          } catch (error) {
            console.error("execIframeRPC onResponse error", error);
            throw error;
          }
        },
        onMessage: function onMessage(e, _ref4) {
          var close = _ref4.close;

          try {
            if (_typeof$1(e.data) !== "object") return;
            if (e.data.jsonrpc !== "2.0") return;
            if (e.data.id !== id) return;
            var resp = normalizePollingResponse(e.data.result);

            switch (resp.status) {
              case "APPROVED":
                resolve(resp.data);
                close();
                break;

              case "DECLINED":
                reject("Declined: ".concat(resp.reason || "No reason supplied"));
                close();
                break;

              case "REDIRECT":
                resolve(resp);
                close();
                break;

              default:
                reject("Declined: No reason supplied");
                close();
                break;
            }
          } catch (error) {
            console.error("execIframeRPC onMessage error", error);
            throw error;
          }
        },
        onClose: function onClose() {
          reject("Declined: Externally Halted");
        }
      });
    });
  }

  var noop$2 = function noop() {};

  function pop(service) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (service == null) return {
      send: noop$2,
      close: noop$2
    };
    var onClose = opts.onClose || noop$2;
    var onMessage = opts.onMessage || noop$2;
    var onReady = opts.onReady || noop$2;
    var onResponse = opts.onResponse || noop$2;
    var handler = buildMessageHandler({
      close: close,
      send: send,
      onReady: onReady,
      onResponse: onResponse,
      onMessage: onMessage
    });
    window.addEventListener("message", handler);

    var _renderPop = renderPop(serviceEndpoint(service)),
        _renderPop2 = _slicedToArray(_renderPop, 2),
        $pop = _renderPop2[0],
        unmount = _renderPop2[1];

    var timer = setInterval(function () {
      if ($pop && $pop.closed) {
        close();
      }
    }, 500);
    return {
      send: send,
      close: close
    };

    function close() {
      try {
        window.removeEventListener("message", handler);
        clearInterval(timer);
        unmount();
        onClose();
      } catch (error) {
        console.error("Popup Close Error", error);
      }
    }

    function send(msg) {
      try {
        $pop.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
      } catch (error) {
        console.error("Popup Send Error", msg, error);
      }
    }
  }

  function execPopRPC(_ref) {
    var service = _ref.service,
        body = _ref.body,
        config = _ref.config,
        opts = _ref.opts;
    return new Promise(function (resolve, reject) {
      var id = uid();
      var redir = opts.redir,
          includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
      pop(service, {
        onReady: function onReady(_, _ref2) {
          return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
            var send;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    send = _ref2.send;
                    _context.prev = 1;
                    send({
                      fclVersion: VERSION,
                      type: "FCL:VIEW:READY:RESPONSE",
                      body: body,
                      service: {
                        params: service.params,
                        data: service.data,
                        type: service.type
                      },
                      config: config
                    });
                    send({
                      fclVersion: VERSION,
                      type: "FCL:FRAME:READY:RESPONSE",
                      body: body,
                      service: {
                        params: service.params,
                        data: service.data,
                        type: service.type
                      },
                      config: config,
                      deprecated: {
                        message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
                      }
                    });

                    if (includeOlderJsonRpcCall) {
                      send({
                        jsonrpc: "2.0",
                        id: id,
                        method: "fcl:sign",
                        params: [body, service.params]
                      });
                    }

                    _context.next = 10;
                    break;

                  case 7:
                    _context.prev = 7;
                    _context.t0 = _context["catch"](1);
                    throw _context.t0;

                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[1, 7]]);
          }))();
        },
        onResponse: function onResponse(e, _ref3) {
          var close = _ref3.close;

          try {
            if (_typeof$1(e.data) !== "object") return;
            var resp = normalizePollingResponse(e.data);

            switch (resp.status) {
              case "APPROVED":
                resolve(resp.data);
                !redir && close();
                break;

              case "DECLINED":
                reject("Declined: ".concat(resp.reason || "No reason supplied"));
                close();
                break;

              case "REDIRECT":
                resolve(resp);
                close();
                break;

              default:
                reject("Declined: No reason supplied");
                close();
                break;
            }
          } catch (error) {
            console.error("execPopRPC onResponse error", error);
            throw error;
          }
        },
        onMessage: function onMessage(e, _ref4) {
          var close = _ref4.close;

          try {
            if (_typeof$1(e.data) !== "object") return;
            if (e.data.jsonrpc !== "2.0") return;
            if (e.data.id !== id) return;
            var resp = normalizePollingResponse(e.data.result);

            switch (resp.status) {
              case "APPROVED":
                resolve(resp.data);
                !redir && close();
                break;

              case "DECLINED":
                reject("Declined: ".concat(resp.reason || "No reason supplied"));
                close();
                break;

              case "REDIRECT":
                resolve(resp);
                close();
                break;

              default:
                reject("Declined: No reason supplied");
                close();
                break;
            }
          } catch (error) {
            console.error("execPopRPC onMessage error", error);
            throw error;
          }
        },
        onClose: function onClose() {
          reject("Declined: Externally Halted");
        }
      });
    });
  }

  var noop$1 = function noop() {};

  function tab(service) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (service == null) return {
      send: noop$1,
      close: noop$1
    };
    var onClose = opts.onClose || noop$1;
    var onMessage = opts.onMessage || noop$1;
    var onReady = opts.onReady || noop$1;
    var onResponse = opts.onResponse || noop$1;
    var handler = buildMessageHandler({
      close: close,
      send: send,
      onReady: onReady,
      onResponse: onResponse,
      onMessage: onMessage
    });
    window.addEventListener("message", handler);

    var _renderTab = renderTab(serviceEndpoint(service)),
        _renderTab2 = _slicedToArray(_renderTab, 2),
        $tab = _renderTab2[0],
        unmount = _renderTab2[1];

    var timer = setInterval(function () {
      if ($tab && $tab.closed) {
        close();
      }
    }, 500);
    return {
      send: send,
      close: close
    };

    function close() {
      try {
        window.removeEventListener("message", handler);
        clearInterval(timer);
        unmount();
        onClose();
      } catch (error) {
        console.error("Tab Close Error", error);
      }
    }

    function send(msg) {
      try {
        $tab.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
      } catch (error) {
        console.error("Tab Send Error", msg, error);
      }
    }
  }

  function execTabRPC(_ref) {
    var service = _ref.service,
        body = _ref.body,
        config = _ref.config,
        opts = _ref.opts;
    return new Promise(function (resolve, reject) {
      var id = uid();
      var redir = opts.redir,
          includeOlderJsonRpcCall = opts.includeOlderJsonRpcCall;
      tab(service, {
        onReady: function onReady(_, _ref2) {
          return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
            var send;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    send = _ref2.send;
                    _context.prev = 1;
                    send({
                      fclVersion: VERSION,
                      type: "FCL:VIEW:READY:RESPONSE",
                      body: body,
                      service: {
                        params: service.params,
                        data: service.data,
                        type: service.type
                      },
                      config: config
                    });
                    send({
                      fclVersion: VERSION,
                      type: "FCL:FRAME:READY:RESPONSE",
                      body: body,
                      service: {
                        params: service.params,
                        data: service.data,
                        type: service.type
                      },
                      config: config,
                      deprecated: {
                        message: "FCL:FRAME:READY:RESPONSE is deprecated and replaced with type: FCL:VIEW:READY:RESPONSE"
                      }
                    });

                    if (includeOlderJsonRpcCall) {
                      send({
                        jsonrpc: "2.0",
                        id: id,
                        method: "fcl:sign",
                        params: [body, service.params]
                      });
                    }

                    _context.next = 10;
                    break;

                  case 7:
                    _context.prev = 7;
                    _context.t0 = _context["catch"](1);
                    throw _context.t0;

                  case 10:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[1, 7]]);
          }))();
        },
        onResponse: function onResponse(e, _ref3) {
          var close = _ref3.close;

          try {
            if (_typeof$1(e.data) !== "object") return;
            var resp = normalizePollingResponse(e.data);

            switch (resp.status) {
              case "APPROVED":
                resolve(resp.data);
                !redir && close();
                break;

              case "DECLINED":
                reject("Declined: ".concat(resp.reason || "No reason supplied"));
                close();
                break;

              case "REDIRECT":
                resolve(resp);
                close();
                break;

              default:
                reject("Declined: No reason supplied");
                close();
                break;
            }
          } catch (error) {
            console.error("execPopRPC onResponse error", error);
            throw error;
          }
        },
        onMessage: function onMessage(e, _ref4) {
          var close = _ref4.close;

          try {
            if (_typeof$1(e.data) !== "object") return;
            if (e.data.jsonrpc !== "2.0") return;
            if (e.data.id !== id) return;
            var resp = normalizePollingResponse(e.data.result);

            switch (resp.status) {
              case "APPROVED":
                resolve(resp.data);
                !redir && close();
                break;

              case "DECLINED":
                reject("Declined: ".concat(resp.reason || "No reason supplied"));
                close();
                break;

              case "REDIRECT":
                resolve(resp);
                close();
                break;

              default:
                reject("Declined: No reason supplied");
                close();
                break;
            }
          } catch (error) {
            console.error("execPopRPC onMessage error", error);
            throw error;
          }
        },
        onClose: function onClose() {
          reject("Declined: Externally Halted");
        }
      });
    });
  }

  var noop$4 = function noop() {};

  function extension(service) {
    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (service == null) return {
      send: noop$4,
      close: noop$4
    };
    var onClose = opts.onClose || noop$4;
    var onMessage = opts.onMessage || noop$4;
    var onReady = opts.onReady || noop$4;
    var onResponse = opts.onResponse || noop$4;
    var handler = buildMessageHandler({
      close: close,
      send: send,
      onReady: onReady,
      onResponse: onResponse,
      onMessage: onMessage
    });
    window.addEventListener("message", handler);
    send({
      service: service
    });
    return {
      send: send,
      close: close
    };

    function close() {
      try {
        window.removeEventListener("message", handler);
        onClose();
      } catch (error) {
        console.error("Ext Close Error", error);
      }
    }

    function send(msg) {
      try {
        window && window.postMessage(JSON.parse(JSON.stringify(msg || {})), "*");
      } catch (error) {
        console.error("Ext Send Error", msg, error);
      }
    }
  }

  function execExtRPC(_ref) {
    var service = _ref.service,
        body = _ref.body,
        config = _ref.config;
    _ref.opts;
    return new Promise(function (resolve, reject) {
      extension(service, {
        onReady: function onReady(_, _ref2) {
          return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
            var send;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    send = _ref2.send;
                    _context.prev = 1;
                    send({
                      fclVersion: VERSION,
                      type: "FCL:VIEW:READY:RESPONSE",
                      body: body,
                      service: {
                        params: service.params,
                        data: service.data,
                        type: service.type
                      },
                      config: config
                    });
                    _context.next = 8;
                    break;

                  case 5:
                    _context.prev = 5;
                    _context.t0 = _context["catch"](1);
                    throw _context.t0;

                  case 8:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[1, 5]]);
          }))();
        },
        onResponse: function onResponse(e, _ref3) {
          var close = _ref3.close;

          try {
            if (_typeof$1(e.data) !== "object") return;
            var resp = normalizePollingResponse(e.data);

            switch (resp.status) {
              case "APPROVED":
                resolve(resp.data);
                close();
                break;

              case "DECLINED":
                reject("Declined: ".concat(resp.reason || "No reason supplied"));
                close();
                break;

              case "REDIRECT":
                resolve(resp);
                close();
                break;

              default:
                reject("Declined: No reason supplied");
                close();
                break;
            }
          } catch (error) {
            console.error("execExtRPC onResponse error", error);
            throw error;
          }
        },
        onClose: function onClose() {
          reject("Declined: Externally Halted");
        }
      });
    });
  }

  var CORE_STRATEGIES = {
    "HTTP/RPC": execHttpPost,
    "HTTP/POST": execHttpPost,
    "IFRAME/RPC": execIframeRPC,
    "POP/RPC": execPopRPC,
    "TAB/RPC": execTabRPC,
    "EXT/RPC": execExtRPC
  };
  var supportedPlugins = ["ServicePlugin"];
  var supportedServicePlugins = ["discovery-service"];

  var validateDiscoveryPlugin = function validateDiscoveryPlugin(servicePlugin) {
    var services = servicePlugin.services,
        serviceStrategy = servicePlugin.serviceStrategy;
    invariant$1(Array.isArray(services) && services.length, "Array of Discovery Services is required");

    var _iterator = _createForOfIteratorHelper(services),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var ds = _step.value;
        invariant$1(isRequired(ds.f_type) && ds.f_type === "Service", "Service is required");
        invariant$1(isRequired(ds.type) && ds.type === "authn", "Service must be type authn. Received ".concat(ds.type));
        invariant$1(ds.method in CORE_STRATEGIES || serviceStrategy.method === ds.method, "Service method ".concat(ds.method, " is not supported"));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    invariant$1(isRequired(serviceStrategy), "Service strategy is required");
    invariant$1(isRequired(serviceStrategy.method) && isString(serviceStrategy.method), "Service strategy method is required");
    invariant$1(isRequired(serviceStrategy.exec) && isFunc(serviceStrategy.exec), "Service strategy exec function is required");
    return {
      discoveryServices: services,
      serviceStrategy: serviceStrategy
    };
  };

  var ServiceRegistry = function ServiceRegistry() {
    var services = new Set();
    var strategies = new Map(Object.entries(CORE_STRATEGIES));

    var add = function add(servicePlugin) {
      invariant$1(supportedServicePlugins.includes(servicePlugin.type), "Service Plugin type ".concat(servicePlugin.type, " is not supported"));

      if (servicePlugin.type === "discovery-service") {
        var _validateDiscoveryPlu = validateDiscoveryPlugin(servicePlugin),
            discoveryServices = _validateDiscoveryPlu.discoveryServices,
            serviceStrategy = _validateDiscoveryPlu.serviceStrategy;

        setServices(discoveryServices);

        if (!strategies.has(serviceStrategy.method)) {
          strategies.set(serviceStrategy.method, serviceStrategy.exec);
        } else {
          log({
            title: "Add Service Plugin",
            message: "Service strategy for ".concat(serviceStrategy.method, " already exists"),
            level: LEVELS.warn
          });
        }
      }
    };

    var setServices = function setServices(discoveryServices) {
      return services = new Set(_toConsumableArray(discoveryServices));
    };

    var getServices = function getServices() {
      return _toConsumableArray(services);
    };

    var getStrategy = function getStrategy(method) {
      return strategies.get(method);
    };

    var getStrategies = function getStrategies() {
      return _toConsumableArray(strategies.keys());
    };

    return Object.freeze({
      add: add,
      getServices: getServices,
      getStrategy: getStrategy,
      getStrategies: getStrategies
    });
  };

  var validatePlugins = function validatePlugins(plugins) {
    var pluginsArray;
    invariant$1(plugins, "No plugins supplied");

    if (!Array.isArray(plugins)) {
      pluginsArray = [plugins];
    } else {
      pluginsArray = _toConsumableArray(plugins);
    }

    var _iterator2 = _createForOfIteratorHelper(pluginsArray),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var p = _step2.value;
        invariant$1(isRequired(p.name), "Plugin name is required");
        invariant$1(isRequired(p.f_type), "Plugin f_type is required");
        invariant$1(supportedPlugins.includes(p.f_type), "Plugin type ".concat(p.f_type, " is not supported"));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return pluginsArray;
  };

  var PluginRegistry = function PluginRegistry() {
    var pluginsMap = new Map();

    var getPlugins = function getPlugins() {
      return pluginsMap;
    };

    var add = function add(plugins) {
      var pluginsArray = validatePlugins(plugins);

      var _iterator3 = _createForOfIteratorHelper(pluginsArray),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var p = _step3.value;
          pluginsMap.set(p.name, p);

          if (p.f_type === "ServicePlugin") {
            serviceRegistry.add(p);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    };

    return Object.freeze({
      add: add,
      getPlugins: getPlugins
    });
  };

  var serviceRegistry = ServiceRegistry();
  PluginRegistry();

  var makeDiscoveryServices = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      var _window;

      var extensionServices;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              extensionServices = ((_window = window) === null || _window === void 0 ? void 0 : _window.fcl_extensions) || [];
              return _context.abrupt("return", [].concat(_toConsumableArray(extensionServices), _toConsumableArray(serviceRegistry.getServices())));

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function makeDiscoveryServices() {
      return _ref.apply(this, arguments);
    };
  }();

  function getServices(_x) {
    return _getServices.apply(this, arguments);
  }

  function _getServices() {
    _getServices = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
      var _window, _window$navigator;

      var types, endpoint, include, url;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              types = _ref.types;
              _context.next = 3;
              return config.get("discovery.authn.endpoint");

            case 3:
              endpoint = _context.sent;
              invariant$1(Boolean(endpoint), "\"discovery.authn.endpoint\" in config must be defined.");
              _context.next = 7;
              return config.get("discovery.authn.include", []);

            case 7:
              include = _context.sent;
              url = new URL(endpoint);
              _context.t0 = fetch;
              _context.t1 = url;
              _context.t2 = {
                "Content-Type": "application/json"
              };
              _context.t3 = JSON;
              _context.t4 = types;
              _context.t5 = VERSION;
              _context.t6 = include;
              _context.next = 18;
              return makeDiscoveryServices();

            case 18:
              _context.t7 = _context.sent;
              _context.t8 = serviceRegistry.getStrategies();
              _context.t9 = (_window = window) === null || _window === void 0 ? void 0 : (_window$navigator = _window.navigator) === null || _window$navigator === void 0 ? void 0 : _window$navigator.userAgent;
              _context.t10 = {
                type: _context.t4,
                fclVersion: _context.t5,
                include: _context.t6,
                clientServices: _context.t7,
                supportedStrategies: _context.t8,
                userAgent: _context.t9
              };
              _context.t11 = _context.t3.stringify.call(_context.t3, _context.t10);
              _context.t12 = {
                method: "POST",
                headers: _context.t2,
                body: _context.t11
              };
              return _context.abrupt("return", (0, _context.t0)(_context.t1, _context.t12).then(function (d) {
                return d.json();
              }));

            case 25:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _getServices.apply(this, arguments);
  }

  var _HANDLERS$3;

  var SERVICE_ACTOR_KEYS = {
    AUTHN: "authn",
    RESULTS: "results",
    SNAPSHOT: "SNAPSHOT",
    UPDATED: "UPDATED",
    UPDATE_RESULTS: "UPDATE_RESULTS"
  };

  var warn = function warn(fact, msg) {
    if (fact) {
      console.warn("\n      %cFCL Warning\n      ============================\n      ".concat(msg, "\n      For more info, please see the docs: https://docs.onflow.org/fcl/\n      ============================\n      "), "font-weight:bold;font-family:monospace;");
    }
  };

  var fetchServicesFromDiscovery = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      var services;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.prev = 0;
              _context.next = 3;
              return getServices({
                types: [SERVICE_ACTOR_KEYS.AUTHN]
              });

            case 3:
              services = _context.sent;
              _send(SERVICE_ACTOR_KEYS.AUTHN, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, {
                results: services
              });
              _context.next = 10;
              break;

            case 7:
              _context.prev = 7;
              _context.t0 = _context["catch"](0);
              log({
                title: "".concat(_context.t0.name, " Error fetching Discovery API services."),
                message: _context.t0.message,
                level: LEVELS.error
              });

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[0, 7]]);
    }));

    return function fetchServicesFromDiscovery() {
      return _ref.apply(this, arguments);
    };
  }();

  var HANDLERS$3 = (_HANDLERS$3 = {}, _defineProperty(_HANDLERS$3, INIT, function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ctx) {
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              warn(typeof window === "undefined", '"fcl.discovery" is only available in the browser.'); // If you call this before the window is loaded extensions will not be set yet

              if (document.readyState === 'complete') {
                fetchServicesFromDiscovery();
              } else {
                window.onload = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
                  return regenerator.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          fetchServicesFromDiscovery();

                        case 1:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2);
                }));
              }

            case 2:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x) {
      return _ref2.apply(this, arguments);
    };
  }()), _defineProperty(_HANDLERS$3, SERVICE_ACTOR_KEYS.UPDATE_RESULTS, function (ctx, _letter, data) {
    ctx.merge(data);
    ctx.broadcast(SERVICE_ACTOR_KEYS.UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS$3, SUBSCRIBE, function (ctx, letter) {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, SERVICE_ACTOR_KEYS.UPDATED, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS$3, UNSUBSCRIBE, function (ctx, letter) {
    return ctx.unsubscribe(letter.from);
  }), _defineProperty(_HANDLERS$3, SERVICE_ACTOR_KEYS.SNAPSHOT, function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ctx, letter) {
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", letter.reply(_objectSpread2({}, ctx.all())));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x2, _x3) {
      return _ref4.apply(this, arguments);
    };
  }()), _HANDLERS$3);

  var spawnProviders = function spawnProviders() {
    return spawn(HANDLERS$3, SERVICE_ACTOR_KEYS.AUTHN);
  };

  var authn = {
    subscribe: function subscribe(cb) {
      return subscriber(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders, cb);
    },
    snapshot: function snapshot() {
      return snapshoter(SERVICE_ACTOR_KEYS.AUTHN, spawnProviders);
    },
    update: function update() {
      return fetchServicesFromDiscovery();
    }
  };
  var discovery = {
    authn: authn
  };

  var _HANDLERS$2;

  var NAME = "CURRENT_USER";
  var UPDATED$1 = "CURRENT_USER/UPDATED";
  var SNAPSHOT = "SNAPSHOT";
  var SET_CURRENT_USER = "SET_CURRENT_USER";
  var DEL_CURRENT_USER = "DEL_CURRENT_USER";
  var DATA = "{\n  \"f_type\": \"User\",\n  \"f_vsn\": \"1.0.0\",\n  \"addr\":null,\n  \"cid\":null,\n  \"loggedIn\":null,\n  \"expiresAt\":null,\n  \"services\":[]\n}";

  var getStoredUser = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(storage) {
      var fallback, stored;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              fallback = JSON.parse(DATA);
              _context.next = 3;
              return storage.get(NAME);

            case 3:
              stored = _context.sent;

              if (!(stored != null && fallback["f_vsn"] !== stored["f_vsn"])) {
                _context.next = 7;
                break;
              }

              storage.removeItem(NAME);
              return _context.abrupt("return", fallback);

            case 7:
              return _context.abrupt("return", stored || fallback);

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function getStoredUser(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  (_HANDLERS$2 = {}, _defineProperty(_HANDLERS$2, INIT, function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ctx) {
      var storage, user;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (typeof window === "undefined") {
                console.warn("\n        %cFCL Warning\n        ============================\n        \"currentUser\" is only available in the browser.\n        For more info, please see the docs: https://docs.onflow.org/fcl/\n        ============================\n        ", "font-weight:bold;font-family:monospace;");
              }

              ctx.merge(JSON.parse(DATA));
              _context2.next = 4;
              return config.first(["fcl.storage", "fcl.storage.default"]);

            case 4:
              storage = _context2.sent;

              if (!storage.can) {
                _context2.next = 10;
                break;
              }

              _context2.next = 8;
              return getStoredUser(storage);

            case 8:
              user = _context2.sent;
              if (notExpired(user)) ctx.merge(user);

            case 10:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }()), _defineProperty(_HANDLERS$2, SUBSCRIBE, function (ctx, letter) {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED$1, _objectSpread2({}, ctx.all()));
  }), _defineProperty(_HANDLERS$2, UNSUBSCRIBE, function (ctx, letter) {
    ctx.unsubscribe(letter.from);
  }), _defineProperty(_HANDLERS$2, SNAPSHOT, function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ctx, letter) {
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              letter.reply(_objectSpread2({}, ctx.all()));

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }()), _defineProperty(_HANDLERS$2, SET_CURRENT_USER, function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ctx, letter, data) {
      var storage;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              ctx.merge(data);
              _context4.next = 3;
              return config.first(["fcl.storage", "fcl.storage.default"]);

            case 3:
              storage = _context4.sent;
              if (storage.can) storage.put(NAME, ctx.all());
              ctx.broadcast(UPDATED$1, _objectSpread2({}, ctx.all()));

            case 6:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));

    return function (_x5, _x6, _x7) {
      return _ref4.apply(this, arguments);
    };
  }()), _defineProperty(_HANDLERS$2, DEL_CURRENT_USER, function () {
    var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(ctx, letter) {
      var storage;
      return regenerator.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              ctx.merge(JSON.parse(DATA));
              _context5.next = 3;
              return config.first(["fcl.storage", "fcl.storage.default"]);

            case 3:
              storage = _context5.sent;
              if (storage.can) storage.put(NAME, ctx.all());
              ctx.broadcast(UPDATED$1, _objectSpread2({}, ctx.all()));

            case 6:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));

    return function (_x8, _x9) {
      return _ref5.apply(this, arguments);
    };
  }()), _HANDLERS$2);

  function notExpired(user) {
    return user.expiresAt == null || user.expiresAt === 0 || user.expiresAt > Date.now();
  }
  var USER_SIGNATURE = "USER_SIGNATURE";

  var validateArgs = function validateArgs(args) {
    if (args.appIdentifier) {
      var appIdentifier = args.appIdentifier,
          address = args.address,
          nonce = args.nonce,
          signatures = args.signatures;
      invariant$1(isString(appIdentifier), "verifyAccountProof({ appIdentifier }) -- appIdentifier must be a string");
      invariant$1(isString(address) && sansPrefix(address).length === 16, "verifyAccountProof({ address }) -- address must be a valid address");
      invariant$1(/^[0-9a-f]+$/i.test(nonce), "nonce must be a hex string");
      invariant$1(Array.isArray(signatures) && signatures.every(function (sig, i, arr) {
        return sig.f_type === "CompositeSignature";
      }), "Must include an Array of CompositeSignatures to verify");
      invariant$1(signatures.map(function (cs) {
        return cs.addr;
      }).every(function (addr, i, arr) {
        return addr === arr[0];
      }), "User signatures to be verified must be from a single account address");
      return true;
    } else {
      var message = args.message,
          _address = args.address,
          compSigs = args.compSigs;
      invariant$1(/^[0-9a-f]+$/i.test(message), "Signed message must be a hex string");
      invariant$1(isString(_address) && sansPrefix(_address).length === 16, "verifyUserSignatures({ address }) -- address must be a valid address");
      invariant$1(Array.isArray(compSigs) && compSigs.every(function (sig, i, arr) {
        return sig.f_type === "CompositeSignature";
      }), "Must include an Array of CompositeSignatures to verify");
      invariant$1(compSigs.map(function (cs) {
        return cs.addr;
      }).every(function (addr, i, arr) {
        return addr === arr[0];
      }), "User signatures to be verified must be from a single account address");
      return true;
    }
  };

  var getVerifySignaturesScript = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(sig, opts) {
      var verifyFunction, network, fclCryptoContract;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              verifyFunction = sig === "ACCOUNT_PROOF" ? "verifyAccountProofSignatures" : "verifyUserSignatures";
              _context.next = 3;
              return config.get("flow.network");

            case 3:
              network = _context.sent;

              if (network) {
                _context.next = 9;
                break;
              }

              _context.next = 7;
              return config.get("env");

            case 7:
              network = _context.sent;
              if (network) log.deprecate({
                pkg: "FCL",
                subject: 'Using the "env" configuration key for specifying the flow network',
                message: 'Please use "flow.network" instead.',
                transition: "https://github.com/onflow/flow-js-sdk/blob/master/packages/fcl/TRANSITIONS.md#0001-deprecate-env-config-key"
              });

            case 9:
              invariant$1(opts.fclCryptoContract || network === "testnet" || network === "mainnet", "${verifyFunction}({ fclCryptoContract }) -- config.flow.network must be specified (testnet || mainnet) or contract address provided via opts.fclCryptoContract");

              if (opts.fclCryptoContract) {
                fclCryptoContract = opts.fclCryptoContract;
              } else {
                fclCryptoContract = network === "testnet" ? "0x74daa6f9c7ef24b1" : "0xb4b82a1c9d21d284";
              }

              return _context.abrupt("return", "\n      import FCLCrypto from ".concat(fclCryptoContract, "\n\n      pub fun main(\n          address: Address, \n          message: String, \n          keyIndices: [Int], \n          signatures: [String]\n      ): Bool {\n        return FCLCrypto.").concat(verifyFunction, "(address: address, message: message, keyIndices: keyIndices, signatures: signatures)\n      }\n    "));

            case 12:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function getVerifySignaturesScript(_x, _x2) {
      return _ref.apply(this, arguments);
    };
  }();

  function verifyUserSignatures$1(_x5, _x6) {
    return _verifyUserSignatures.apply(this, arguments);
  }

  function _verifyUserSignatures() {
    _verifyUserSignatures = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(message, compSigs) {
      var opts,
          address,
          signaturesArr,
          keyIndices,
          _iterator2,
          _step2,
          el,
          _args3 = arguments;

      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              opts = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
              address = withPrefix$1(compSigs[0].addr);
              validateArgs({
                message: message,
                address: address,
                compSigs: compSigs
              });
              signaturesArr = [];
              keyIndices = [];
              _iterator2 = _createForOfIteratorHelper(compSigs);

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  el = _step2.value;
                  signaturesArr.push(el.signature);
                  keyIndices.push(el.keyId.toString());
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              _context3.t0 = query;
              _context3.next = 10;
              return getVerifySignaturesScript(USER_SIGNATURE, opts);

            case 10:
              _context3.t1 = _context3.sent;

              _context3.t2 = function args(arg, t) {
                return [arg(address, t.Address), arg(message, t.String), arg(keyIndices, t.Array(t.Int)), arg(signaturesArr, t.Array(t.String))];
              };

              _context3.t3 = {
                cadence: _context3.t1,
                args: _context3.t2
              };
              return _context3.abrupt("return", (0, _context3.t0)(_context3.t3));

            case 14:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));
    return _verifyUserSignatures.apply(this, arguments);
  }
  /**
   * Verify a valid signature/s for an account on Flow.
   *
   * @deprecated since version '1.0.0-alpha.0', use AppUtils.verifyUserSignatures instead
   *
   */

  log.deprecate({
    pkg: "FCL",
    subject: "fcl.verifyUserSignatures()",
    message: "Please use fcl.AppUtils.verifyUserSignatures()",
    callback: function verifyUserSignatures(message, compSigs) {
      return verifyUserSignatures$1(message, compSigs);
    }
  });

  var _HANDLERS$1;

  var RATE$1 = 2500;
  var POLL = "POLL";

  var fetchTxStatus = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(transactionId) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", send([getTransactionStatus(transactionId)]).then(decode$3));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function fetchTxStatus(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var isSealed = function isSealed(tx) {
    return tx.status >= 4;
  };

  var isDiff = function isDiff(cur, next) {
    return JSON.stringify(cur) !== JSON.stringify(next);
  };

  (_HANDLERS$1 = {}, _defineProperty(_HANDLERS$1, INIT, function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ctx) {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              ctx.sendSelf(POLL);

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }()), _defineProperty(_HANDLERS$1, SUBSCRIBE, function (ctx, letter) {
    ctx.subscribe(letter.from);
    ctx.send(letter.from, UPDATED$3, ctx.all());
  }), _defineProperty(_HANDLERS$1, UNSUBSCRIBE, function (ctx, letter) {
    ctx.unsubscribe(letter.from);
  }), _defineProperty(_HANDLERS$1, SNAPSHOT$1, function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ctx, letter) {
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              letter.reply(ctx.all());

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }()), _defineProperty(_HANDLERS$1, POLL, function () {
    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(ctx) {
      var tx;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _context4.prev = 0;
              _context4.next = 3;
              return fetchTxStatus(ctx.self());

            case 3:
              tx = _context4.sent;
              _context4.next = 9;
              break;

            case 6:
              _context4.prev = 6;
              _context4.t0 = _context4["catch"](0);
              return _context4.abrupt("return", ctx.fatalError(_context4.t0));

            case 9:
              if (!isSealed(tx)) setTimeout(function () {
                return ctx.sendSelf(POLL);
              }, RATE$1);
              if (isDiff(ctx.all(), tx)) ctx.broadcast(UPDATED$3, tx);
              ctx.merge(tx);

            case 12:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, null, [[0, 6]]);
    }));

    return function (_x5) {
      return _ref4.apply(this, arguments);
    };
  }()), _HANDLERS$1);

  var _HANDLERS;

  var RATE = 10000;
  var UPDATED = "UPDATED";
  var TICK = "TICK";
  var HIGH_WATER_MARK = "hwm";

  var scheduleTick = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(ctx) {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.t0 = setTimeout;

              _context.t1 = function () {
                return ctx.sendSelf(TICK);
              };

              _context.next = 4;
              return config().get("fcl.eventPollRate", RATE);

            case 4:
              _context.t2 = _context.sent;
              return _context.abrupt("return", (0, _context.t0)(_context.t1, _context.t2));

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function scheduleTick(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  (_HANDLERS = {}, _defineProperty(_HANDLERS, TICK, function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(ctx) {
      var hwm, next, data, _iterator, _step, d;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (ctx.hasSubs()) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return");

            case 2:
              hwm = ctx.get(HIGH_WATER_MARK);

              if (!(hwm == null)) {
                _context2.next = 18;
                break;
              }

              _context2.t0 = ctx;
              _context2.t1 = HIGH_WATER_MARK;
              _context2.next = 8;
              return block();

            case 8:
              _context2.t2 = _context2.sent;

              _context2.t0.put.call(_context2.t0, _context2.t1, _context2.t2);

              _context2.t3 = ctx;
              _context2.t4 = TICK;
              _context2.next = 14;
              return scheduleTick(ctx);

            case 14:
              _context2.t5 = _context2.sent;

              _context2.t3.put.call(_context2.t3, _context2.t4, _context2.t5);

              _context2.next = 34;
              break;

            case 18:
              _context2.next = 20;
              return block();

            case 20:
              next = _context2.sent;
              ctx.put(HIGH_WATER_MARK, next);

              if (!(hwm.height < next.height)) {
                _context2.next = 28;
                break;
              }

              _context2.next = 25;
              return send([getEventsAtBlockHeightRange(ctx.self(), hwm.height + 1, next.height)]).then(decode$3);

            case 25:
              data = _context2.sent;
              _iterator = _createForOfIteratorHelper(data);

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  d = _step.value;
                  ctx.broadcast(UPDATED, d.data);
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }

            case 28:
              _context2.t6 = ctx;
              _context2.t7 = TICK;
              _context2.next = 32;
              return scheduleTick(ctx);

            case 32:
              _context2.t8 = _context2.sent;

              _context2.t6.put.call(_context2.t6, _context2.t7, _context2.t8);

            case 34:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }()), _defineProperty(_HANDLERS, SUBSCRIBE, function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(ctx, letter) {
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (ctx.hasSubs()) {
                _context3.next = 7;
                break;
              }

              _context3.t0 = ctx;
              _context3.t1 = TICK;
              _context3.next = 5;
              return scheduleTick(ctx);

            case 5:
              _context3.t2 = _context3.sent;

              _context3.t0.put.call(_context3.t0, _context3.t1, _context3.t2);

            case 7:
              ctx.subscribe(letter.from);

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    }));

    return function (_x3, _x4) {
      return _ref3.apply(this, arguments);
    };
  }()), _defineProperty(_HANDLERS, UNSUBSCRIBE, function (ctx, letter) {
    ctx.unsubscribe(letter.from);

    if (!ctx.hasSubs()) {
      clearTimeout(ctx.get(TICK));
      ctx["delete"](TICK);
      ctx["delete"](HIGH_WATER_MARK);
    }
  }), _HANDLERS);

  var sha3 = {};
  var sponge = {};
  var permute = {};
  var chi = {};

  var copy$2 = function copy(I, i) {
    return function (O, o) {
      var oi = o * 2;
      var ii = i * 2;
      O[oi] = I[ii];
      O[oi + 1] = I[ii + 1];
    };
  };

  var copy_1 = copy$2;

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _copy = _interopRequireDefault(copy_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var chi = function chi(_ref) {
      var A = _ref.A,
          C = _ref.C;

      for (var y = 0; y < 25; y += 5) {
        for (var x = 0; x < 5; x++) {
          (0, _copy["default"])(A, y + x)(C, x);
        }

        for (var _x = 0; _x < 5; _x++) {
          var xy = (y + _x) * 2;
          var x1 = (_x + 1) % 5 * 2;
          var x2 = (_x + 2) % 5 * 2;
          A[xy] ^= ~C[x1] & C[x2];
          A[xy + 1] ^= ~C[x1 + 1] & C[x2 + 1];
        }
      }
    };

    var _default = chi;
    exports["default"] = _default;
  })(chi);

  var iota = {};
  var roundConstants = {};

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var ROUND_CONSTANTS = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);
    var _default = ROUND_CONSTANTS;
    exports["default"] = _default;
  })(roundConstants);

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _roundConstants = _interopRequireDefault(roundConstants);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var iota = function iota(_ref) {
      var A = _ref.A,
          roundIndex = _ref.roundIndex;
      var i = roundIndex * 2;
      A[0] ^= _roundConstants["default"][i];
      A[1] ^= _roundConstants["default"][i + 1];
    };

    var _default = iota;
    exports["default"] = _default;
  })(iota);

  var rhoPi = {};
  var piShuffles = {};

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var PI_SHUFFLES = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];
    var _default = PI_SHUFFLES;
    exports["default"] = _default;
  })(piShuffles);

  var rhoOffsets = {};

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var RHO_OFFSETS = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];
    var _default = RHO_OFFSETS;
    exports["default"] = _default;
  })(rhoOffsets);

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _piShuffles = _interopRequireDefault(piShuffles);

    var _rhoOffsets = _interopRequireDefault(rhoOffsets);

    var _copy = _interopRequireDefault(copy_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var rhoPi = function rhoPi(_ref) {
      var A = _ref.A,
          C = _ref.C,
          W = _ref.W;
      (0, _copy["default"])(A, 1)(W, 0);
      var H = 0;
      var L = 0;
      var Wi = 0;
      var ri = 32;

      for (var i = 0; i < 24; i++) {
        var j = _piShuffles["default"][i];
        var r = _rhoOffsets["default"][i];
        (0, _copy["default"])(A, j)(C, 0);
        H = W[0];
        L = W[1];
        ri = 32 - r;
        Wi = r < 32 ? 0 : 1;
        W[Wi] = H << r | L >>> ri;
        W[(Wi + 1) % 2] = L << r | H >>> ri;
        (0, _copy["default"])(W, 0)(A, j);
        (0, _copy["default"])(C, 0)(W, 0);
      }
    };

    var _default = rhoPi;
    exports["default"] = _default;
  })(rhoPi);

  var theta = {};

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _copy = _interopRequireDefault(copy_1);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var theta = function theta(_ref) {
      var A = _ref.A,
          C = _ref.C,
          D = _ref.D,
          W = _ref.W;
      var H = 0;
      var L = 0;

      for (var x = 0; x < 5; x++) {
        var x20 = x * 2;
        var x21 = (x + 5) * 2;
        var x22 = (x + 10) * 2;
        var x23 = (x + 15) * 2;
        var x24 = (x + 20) * 2;
        C[x20] = A[x20] ^ A[x21] ^ A[x22] ^ A[x23] ^ A[x24];
        C[x20 + 1] = A[x20 + 1] ^ A[x21 + 1] ^ A[x22 + 1] ^ A[x23 + 1] ^ A[x24 + 1];
      }

      for (var _x = 0; _x < 5; _x++) {
        (0, _copy["default"])(C, (_x + 1) % 5)(W, 0);
        H = W[0];
        L = W[1];
        W[0] = H << 1 | L >>> 31;
        W[1] = L << 1 | H >>> 31;
        D[_x * 2] = C[(_x + 4) % 5 * 2] ^ W[0];
        D[_x * 2 + 1] = C[(_x + 4) % 5 * 2 + 1] ^ W[1];

        for (var y = 0; y < 25; y += 5) {
          A[(y + _x) * 2] ^= D[_x * 2];
          A[(y + _x) * 2 + 1] ^= D[_x * 2 + 1];
        }
      }
    };

    var _default = theta;
    exports["default"] = _default;
  })(theta);

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _chi = _interopRequireDefault(chi);

    var _iota = _interopRequireDefault(iota);

    var _rhoPi = _interopRequireDefault(rhoPi);

    var _theta = _interopRequireDefault(theta);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var permute = function permute() {
      var C = new Uint32Array(10);
      var D = new Uint32Array(10);
      var W = new Uint32Array(2);
      return function (A) {
        for (var roundIndex = 0; roundIndex < 24; roundIndex++) {
          (0, _theta["default"])({
            A: A,
            C: C,
            D: D,
            W: W
          });
          (0, _rhoPi["default"])({
            A: A,
            C: C,
            W: W
          });
          (0, _chi["default"])({
            A: A,
            C: C
          });
          (0, _iota["default"])({
            A: A,
            roundIndex: roundIndex
          });
        }

        C.fill(0);
        D.fill(0);
        W.fill(0);
      };
    };

    var _default = permute;
    exports["default"] = _default;
  })(permute);

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _buffer = buffer$1;

    var _permute = _interopRequireDefault(permute);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var xorWords = function xorWords(I, O) {
      for (var i = 0; i < I.length; i += 8) {
        var o = i / 4;
        O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];
        O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];
      }

      return O;
    };

    var readWords = function readWords(I, O) {
      for (var o = 0; o < O.length; o += 8) {
        var i = o / 4;
        O[o] = I[i + 1];
        O[o + 1] = I[i + 1] >>> 8;
        O[o + 2] = I[i + 1] >>> 16;
        O[o + 3] = I[i + 1] >>> 24;
        O[o + 4] = I[i];
        O[o + 5] = I[i] >>> 8;
        O[o + 6] = I[i] >>> 16;
        O[o + 7] = I[i] >>> 24;
      }

      return O;
    };

    var Sponge = function Sponge(_ref) {
      var _this = this;

      var capacity = _ref.capacity,
          padding = _ref.padding;
      var keccak = (0, _permute["default"])();
      var stateSize = 200;
      var blockSize = capacity / 8;
      var queueSize = stateSize - capacity / 4;
      var queueOffset = 0;
      var state = new Uint32Array(stateSize / 4);

      var queue = _buffer.Buffer.allocUnsafe(queueSize);

      this.absorb = function (buffer) {
        for (var i = 0; i < buffer.length; i++) {
          queue[queueOffset] = buffer[i];
          queueOffset += 1;

          if (queueOffset >= queueSize) {
            xorWords(queue, state);
            keccak(state);
            queueOffset = 0;
          }
        }

        return _this;
      };

      this.squeeze = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var output = {
          buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize),
          padding: options.padding || padding,
          queue: _buffer.Buffer.allocUnsafe(queue.length),
          state: new Uint32Array(state.length)
        };
        queue.copy(output.queue);

        for (var i = 0; i < state.length; i++) {
          output.state[i] = state[i];
        }

        output.queue.fill(0, queueOffset);
        output.queue[queueOffset] |= output.padding;
        output.queue[queueSize - 1] |= 128;
        xorWords(output.queue, output.state);

        for (var offset = 0; offset < output.buffer.length; offset += queueSize) {
          keccak(output.state);
          readWords(output.state, output.buffer.slice(offset, offset + queueSize));
        }

        return output.buffer;
      };

      this.reset = function () {
        queue.fill(0);
        state.fill(0);
        queueOffset = 0;
        return _this;
      };

      return this;
    };

    var _default = Sponge;
    exports["default"] = _default;
  })(sponge);

  (function (exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = exports.SHAKE = exports.SHA3Hash = exports.SHA3 = exports.Keccak = void 0;
    var _buffer = buffer$1;

    var _sponge = _interopRequireDefault(sponge);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    var createHash = function createHash(_ref) {
      var allowedSizes = _ref.allowedSizes,
          defaultSize = _ref.defaultSize,
          padding = _ref.padding;
      return function Hash() {
        var _this = this;

        var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultSize;

        if (!this || this.constructor !== Hash) {
          return new Hash(size);
        }

        if (allowedSizes && !allowedSizes.includes(size)) {
          throw new Error("Unsupported hash length");
        }

        var sponge = new _sponge["default"]({
          capacity: size
        });

        this.update = function (input) {
          var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";

          if (_buffer.Buffer.isBuffer(input)) {
            sponge.absorb(input);
            return _this;
          }

          if (typeof input === "string") {
            return _this.update(_buffer.Buffer.from(input, encoding));
          }

          throw new TypeError("Not a string or buffer");
        };

        this.digest = function () {
          var formatOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "binary";
          var options = typeof formatOrOptions === "string" ? {
            format: formatOrOptions
          } : formatOrOptions;
          var buffer = sponge.squeeze({
            buffer: options.buffer,
            padding: options.padding || padding
          });

          if (options.format && options.format !== "binary") {
            return buffer.toString(options.format);
          }

          return buffer;
        };

        this.reset = function () {
          sponge.reset();
          return _this;
        };

        return this;
      };
    };

    var Keccak = createHash({
      allowedSizes: [224, 256, 384, 512],
      defaultSize: 512,
      padding: 1
    });
    exports.Keccak = Keccak;
    var SHA3 = createHash({
      allowedSizes: [224, 256, 384, 512],
      defaultSize: 512,
      padding: 6
    });
    exports.SHA3 = SHA3;
    var SHAKE = createHash({
      allowedSizes: [128, 256],
      defaultSize: 256,
      padding: 31
    });
    exports.SHAKE = SHAKE;
    var SHA3Hash = Keccak;
    exports.SHA3Hash = SHA3Hash;
    SHA3.SHA3Hash = SHA3Hash;
    var _default = SHA3;
    exports["default"] = _default;
  })(sha3);

  function tryStringify(o) {
    try {
      return JSON.stringify(o);
    } catch (e) {
      return '"[Circular]"';
    }
  }

  var quickFormatUnescaped = format$2;

  function format$2(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;

    if (_typeof$1(f) === 'object' && f !== null) {
      var len = args.length + offset;
      if (len === 1) return f;
      var objects = new Array(len);
      objects[0] = ss(f);

      for (var index = 1; index < len; index++) {
        objects[index] = ss(args[index]);
      }

      return objects.join(' ');
    }

    if (typeof f !== 'string') {
      return f;
    }

    var argLen = args.length;
    if (argLen === 0) return f;
    var str = '';
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;

    for (var i = 0; i < flen;) {
      if (f.charCodeAt(i) === 37 && i + 1 < flen) {
        lastPos = lastPos > -1 ? lastPos : 0;

        switch (f.charCodeAt(i + 1)) {
          case 100: // 'd'

          case 102:
            // 'f'
            if (a >= argLen) break;
            if (args[a] == null) break;
            if (lastPos < i) str += f.slice(lastPos, i);
            str += Number(args[a]);
            lastPos = i + 2;
            i++;
            break;

          case 105:
            // 'i'
            if (a >= argLen) break;
            if (args[a] == null) break;
            if (lastPos < i) str += f.slice(lastPos, i);
            str += Math.floor(Number(args[a]));
            lastPos = i + 2;
            i++;
            break;

          case 79: // 'O'

          case 111: // 'o'

          case 106:
            // 'j'
            if (a >= argLen) break;
            if (args[a] === undefined) break;
            if (lastPos < i) str += f.slice(lastPos, i);

            var type = _typeof$1(args[a]);

            if (type === 'string') {
              str += '\'' + args[a] + '\'';
              lastPos = i + 2;
              i++;
              break;
            }

            if (type === 'function') {
              str += args[a].name || '<anonymous>';
              lastPos = i + 2;
              i++;
              break;
            }

            str += ss(args[a]);
            lastPos = i + 2;
            i++;
            break;

          case 115:
            // 's'
            if (a >= argLen) break;
            if (lastPos < i) str += f.slice(lastPos, i);
            str += String(args[a]);
            lastPos = i + 2;
            i++;
            break;

          case 37:
            // '%'
            if (lastPos < i) str += f.slice(lastPos, i);
            str += '%';
            lastPos = i + 2;
            i++;
            a--;
            break;
        }

        ++a;
      }

      ++i;
    }

    if (lastPos === -1) return f;else if (lastPos < flen) {
      str += f.slice(lastPos);
    }
    return str;
  }

  var format$1 = quickFormatUnescaped;
  var browser$3 = pino;

  var _console = pfGlobalThisOrFallback().console || {};

  var stdSerializers = {
    mapHttpRequest: mock,
    mapHttpResponse: mock,
    wrapRequestSerializer: passthrough,
    wrapResponseSerializer: passthrough,
    wrapErrorSerializer: passthrough,
    req: mock,
    res: mock,
    err: asErrValue
  };

  function pino(opts) {
    opts = opts || {};
    opts.browser = opts.browser || {};
    var transmit = opts.browser.transmit;

    if (transmit && typeof transmit.send !== 'function') {
      throw Error('pino: transmit option must have a send function');
    }

    var proto = opts.browser.write || _console;
    if (opts.browser.write) opts.browser.asObject = true;
    var serializers = opts.serializers || {};
    var serialize = Array.isArray(opts.browser.serialize) ? opts.browser.serialize.filter(function (k) {
      return k !== '!stdSerializers.err';
    }) : opts.browser.serialize === true ? Object.keys(serializers) : false;
    var stdErrSerialize = opts.browser.serialize;
    if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf('!stdSerializers.err') > -1) stdErrSerialize = false;
    var levels = ['error', 'fatal', 'warn', 'info', 'debug', 'trace'];

    if (typeof proto === 'function') {
      proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
    }

    if (opts.enabled === false) opts.level = 'silent';
    var level = opts.level || 'info';
    var logger = Object.create(proto);
    if (!logger.log) logger.log = noop;
    Object.defineProperty(logger, 'levelVal', {
      get: getLevelVal
    });
    Object.defineProperty(logger, 'level', {
      get: getLevel,
      set: setLevel
    });
    var setOpts = {
      transmit: transmit,
      serialize: serialize,
      asObject: opts.browser.asObject,
      levels: levels,
      timestamp: getTimeFunction(opts)
    };
    logger.levels = pino.levels;
    logger.level = level;
    logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
    logger.serializers = serializers;
    logger._serialize = serialize;
    logger._stdErrSerialize = stdErrSerialize;
    logger.child = child;
    if (transmit) logger._logEvent = createLogEventShape();

    function getLevelVal() {
      return this.level === 'silent' ? Infinity : this.levels.values[this.level];
    }

    function getLevel() {
      return this._level;
    }

    function setLevel(level) {
      if (level !== 'silent' && !this.levels.values[level]) {
        throw Error('unknown level ' + level);
      }

      this._level = level;
      set(setOpts, logger, 'error', 'log'); // <-- must stay first

      set(setOpts, logger, 'fatal', 'error');
      set(setOpts, logger, 'warn', 'error');
      set(setOpts, logger, 'info', 'log');
      set(setOpts, logger, 'debug', 'log');
      set(setOpts, logger, 'trace', 'log');
    }

    function child(bindings) {
      if (!bindings) {
        throw new Error('missing bindings for child Pino');
      }

      var bindingsSerializers = bindings.serializers;

      if (serialize && bindingsSerializers) {
        var childSerializers = Object.assign({}, serializers, bindingsSerializers);
        var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
        delete bindings.serializers;
        applySerializers([bindings], childSerialize, childSerializers, this._stdErrSerialize);
      }

      function Child(parent) {
        this._childLevel = (parent._childLevel | 0) + 1;
        this.error = bind(parent, bindings, 'error');
        this.fatal = bind(parent, bindings, 'fatal');
        this.warn = bind(parent, bindings, 'warn');
        this.info = bind(parent, bindings, 'info');
        this.debug = bind(parent, bindings, 'debug');
        this.trace = bind(parent, bindings, 'trace');

        if (childSerializers) {
          this.serializers = childSerializers;
          this._serialize = childSerialize;
        }

        if (transmit) {
          this._logEvent = createLogEventShape([].concat(parent._logEvent.bindings, bindings));
        }
      }

      Child.prototype = this;
      return new Child(this);
    }

    return logger;
  }

  pino.levels = {
    values: {
      fatal: 60,
      error: 50,
      warn: 40,
      info: 30,
      debug: 20,
      trace: 10
    },
    labels: {
      10: 'trace',
      20: 'debug',
      30: 'info',
      40: 'warn',
      50: 'error',
      60: 'fatal'
    }
  };
  pino.stdSerializers = stdSerializers;
  pino.stdTimeFunctions = Object.assign({}, {
    nullTime: nullTime,
    epochTime: epochTime,
    unixTime: unixTime,
    isoTime: isoTime
  });

  function set(opts, logger, level, fallback) {
    var proto = Object.getPrototypeOf(logger);
    logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;
    wrap(opts, logger, level);
  }

  function wrap(opts, logger, level) {
    if (!opts.transmit && logger[level] === noop) return;

    logger[level] = function (write) {
      return function LOG() {
        var ts = opts.timestamp();
        var args = new Array(arguments.length);
        var proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;

        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        if (opts.serialize && !opts.asObject) {
          applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
        }

        if (opts.asObject) write.call(proto, asObject(this, level, args, ts));else write.apply(proto, args);

        if (opts.transmit) {
          var transmitLevel = opts.transmit.level || logger.level;
          var transmitValue = pino.levels.values[transmitLevel];
          var methodValue = pino.levels.values[level];
          if (methodValue < transmitValue) return;
          transmit(this, {
            ts: ts,
            methodLevel: level,
            methodValue: methodValue,
            transmitLevel: transmitLevel,
            transmitValue: pino.levels.values[opts.transmit.level || logger.level],
            send: opts.transmit.send,
            val: logger.levelVal
          }, args);
        }
      };
    }(logger[level]);
  }

  function asObject(logger, level, args, ts) {
    if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
    var argsCloned = args.slice();
    var msg = argsCloned[0];
    var o = {};

    if (ts) {
      o.time = ts;
    }

    o.level = pino.levels.values[level];
    var lvl = (logger._childLevel | 0) + 1;
    if (lvl < 1) lvl = 1; // deliberate, catching objects, arrays

    if (msg !== null && _typeof$1(msg) === 'object') {
      while (lvl-- && _typeof$1(argsCloned[0]) === 'object') {
        Object.assign(o, argsCloned.shift());
      }

      msg = argsCloned.length ? format$1(argsCloned.shift(), argsCloned) : undefined;
    } else if (typeof msg === 'string') msg = format$1(argsCloned.shift(), argsCloned);

    if (msg !== undefined) o.msg = msg;
    return o;
  }

  function applySerializers(args, serialize, serializers, stdErrSerialize) {
    for (var i in args) {
      if (stdErrSerialize && args[i] instanceof Error) {
        args[i] = pino.stdSerializers.err(args[i]);
      } else if (_typeof$1(args[i]) === 'object' && !Array.isArray(args[i])) {
        for (var k in args[i]) {
          if (serialize && serialize.indexOf(k) > -1 && k in serializers) {
            args[i][k] = serializers[k](args[i][k]);
          }
        }
      }
    }
  }

  function bind(parent, bindings, level) {
    return function () {
      var args = new Array(1 + arguments.length);
      args[0] = bindings;

      for (var i = 1; i < args.length; i++) {
        args[i] = arguments[i - 1];
      }

      return parent[level].apply(this, args);
    };
  }

  function transmit(logger, opts, args) {
    var send = opts.send;
    var ts = opts.ts;
    var methodLevel = opts.methodLevel;
    var methodValue = opts.methodValue;
    var val = opts.val;
    var bindings = logger._logEvent.bindings;
    applySerializers(args, logger._serialize || Object.keys(logger.serializers), logger.serializers, logger._stdErrSerialize === undefined ? true : logger._stdErrSerialize);
    logger._logEvent.ts = ts;
    logger._logEvent.messages = args.filter(function (arg) {
      // bindings can only be objects, so reference equality check via indexOf is fine
      return bindings.indexOf(arg) === -1;
    });
    logger._logEvent.level.label = methodLevel;
    logger._logEvent.level.value = methodValue;
    send(methodLevel, logger._logEvent, val);
    logger._logEvent = createLogEventShape(bindings);
  }

  function createLogEventShape(bindings) {
    return {
      ts: 0,
      messages: [],
      bindings: bindings || [],
      level: {
        label: '',
        value: 0
      }
    };
  }

  function asErrValue(err) {
    var obj = {
      type: err.constructor.name,
      msg: err.message,
      stack: err.stack
    };

    for (var key in err) {
      if (obj[key] === undefined) {
        obj[key] = err[key];
      }
    }

    return obj;
  }

  function getTimeFunction(opts) {
    if (typeof opts.timestamp === 'function') {
      return opts.timestamp;
    }

    if (opts.timestamp === false) {
      return nullTime;
    }

    return epochTime;
  }

  function mock() {
    return {};
  }

  function passthrough(a) {
    return a;
  }

  function noop() {}

  function nullTime() {
    return false;
  }

  function epochTime() {
    return Date.now();
  }

  function unixTime() {
    return Math.round(Date.now() / 1000.0);
  }

  function isoTime() {
    return new Date(Date.now()).toISOString();
  } // using Date.now() for testability

  /* eslint-disable */

  /* istanbul ignore next */


  function pfGlobalThisOrFallback() {
    function defd(o) {
      return typeof o !== 'undefined' && o;
    }

    try {
      if (typeof globalThis !== 'undefined') return globalThis;
      Object.defineProperty(Object.prototype, 'globalThis', {
        get: function get() {
          delete Object.prototype.globalThis;
          return this.globalThis = this;
        },
        configurable: true
      });
      return globalThis;
    } catch (e) {
      return defd(self) || defd(window) || defd(this) || {};
    }
  }

  var browser$2 = {};

  /******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");

    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }

    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$1(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$1(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter$1(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  }
  var __createBinding = Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);

    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      };
    }

    Object.defineProperty(o, k2, desc);
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  };
  function __exportStar(m, o) {
    for (var p in m) {
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function next() {
        if (o && i >= o.length) o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;

    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
        ar.push(r.value);
      }
    } catch (error) {
      e = {
        error: error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }

    return ar;
  }
  /** @deprecated */

  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) {
      ar = ar.concat(__read(arguments[i]));
    }

    return ar;
  }
  /** @deprecated */

  function __spreadArrays$1() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
      s += arguments[i].length;
    }

    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
        r[k] = a[j];
      }
    }

    return r;
  }
  function __spreadArray$1(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []),
        i,
        q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i;

    function verb(n) {
      if (g[n]) i[n] = function (v) {
        return new Promise(function (a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }

    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }

    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }

    function fulfill(value) {
      resume("next", value);
    }

    function reject(value) {
      resume("throw", value);
    }

    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function () {
      return this;
    }, i;

    function verb(n, f) {
      i[n] = o[n] ? function (v) {
        return (p = !p) ? {
          value: __await(o[n](v)),
          done: n === "return"
        } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
        i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i);

    function verb(n) {
      i[n] = o[n] && function (v) {
        return new Promise(function (resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }

    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({
          value: v,
          done: d
        });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", {
        value: raw
      });
    } else {
      cooked.raw = raw;
    }

    return cooked;
  }

  var __setModuleDefault = Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  };

  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
      if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }

    __setModuleDefault(result, mod);

    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }
  function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
  }
  function __classPrivateFieldIn(state, receiver) {
    if (receiver === null || _typeof$1(receiver) !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
    return typeof state === "function" ? receiver === state : state.has(receiver);
  }

  var tslib_es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    __extends: __extends,
    get __assign () { return _assign; },
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __metadata: __metadata,
    __awaiter: __awaiter$1,
    __generator: __generator,
    __createBinding: __createBinding,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays$1,
    __spreadArray: __spreadArray$1,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault,
    __classPrivateFieldGet: __classPrivateFieldGet,
    __classPrivateFieldSet: __classPrivateFieldSet,
    __classPrivateFieldIn: __classPrivateFieldIn
  });

  var require$$0$2 = /*@__PURE__*/getAugmentedNamespace(tslib_es6);

  var localStorage$1 = {exports: {}};

  var hasRequiredLocalStorage;

  function requireLocalStorage() {
    if (hasRequiredLocalStorage) return localStorage$1.exports;
    hasRequiredLocalStorage = 1; // http://www.rajdeepd.com/articles/chrome/localstrg/LocalStorageSample.htm
    // NOTE:
    // this varies from actual localStorage in some subtle ways
    // also, there is no persistence
    // TODO persist

    (function () {

      var db;

      function LocalStorage() {}

      db = LocalStorage;

      db.prototype.getItem = function (key) {
        if (this.hasOwnProperty(key)) {
          return String(this[key]);
        }

        return null;
      };

      db.prototype.setItem = function (key, val) {
        this[key] = String(val);
      };

      db.prototype.removeItem = function (key) {
        delete this[key];
      };

      db.prototype.clear = function () {
        var self = this;
        Object.keys(self).forEach(function (key) {
          self[key] = undefined;
          delete self[key];
        });
      };

      db.prototype.key = function (i) {
        i = i || 0;
        return Object.keys(this)[i];
      };

      db.prototype.__defineGetter__('length', function () {
        return Object.keys(this).length;
      });

      if (commonjsGlobal.localStorage) {
        localStorage$1.exports = localStorage;
      } else {
        localStorage$1.exports = new LocalStorage();
      }
    })();

    return localStorage$1.exports;
  }

  var cjs$7 = {};

  var hasRequiredCjs;

  function requireCjs() {
    if (hasRequiredCjs) return cjs$7;
    hasRequiredCjs = 1;

    Object.defineProperty(cjs$7, "__esModule", {
      value: true
    });

    function safeJsonParse(value) {
      if (typeof value !== 'string') {
        throw new Error("Cannot safe json parse value of type ".concat(_typeof$1(value)));
      }

      try {
        return JSON.parse(value);
      } catch (_a) {
        return value;
      }
    }

    cjs$7.safeJsonParse = safeJsonParse;

    function safeJsonStringify(value) {
      return typeof value === 'string' ? value : JSON.stringify(value, function (key, value) {
        return typeof value === 'undefined' ? null : value;
      });
    }

    cjs$7.safeJsonStringify = safeJsonStringify;
    return cjs$7;
  }

  var shared = {};

  var types$2 = {};

  var hasRequiredTypes;

  function requireTypes() {
    if (hasRequiredTypes) return types$2;
    hasRequiredTypes = 1;

    Object.defineProperty(types$2, "__esModule", {
      value: true
    });
    types$2.IKeyValueStorage = void 0;

    var IKeyValueStorage = /*#__PURE__*/_createClass(function IKeyValueStorage() {
      _classCallCheck(this, IKeyValueStorage);
    });

    types$2.IKeyValueStorage = IKeyValueStorage;
    return types$2;
  }

  var utils$4 = {};

  var hasRequiredUtils$1;

  function requireUtils$1() {
    if (hasRequiredUtils$1) return utils$4;
    hasRequiredUtils$1 = 1;

    Object.defineProperty(utils$4, "__esModule", {
      value: true
    });
    utils$4.parseEntry = void 0;
    var safe_json_utils_1 = requireCjs();

    function parseEntry(entry) {
      var _a;

      return [entry[0], safe_json_utils_1.safeJsonParse((_a = entry[1]) !== null && _a !== void 0 ? _a : "")];
    }

    utils$4.parseEntry = parseEntry;
    return utils$4;
  }

  var hasRequiredShared;

  function requireShared() {
    if (hasRequiredShared) return shared;
    hasRequiredShared = 1;

    (function (exports) {

      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      var tslib_1 = require$$0$2;

      tslib_1.__exportStar(requireTypes(), exports);

      tslib_1.__exportStar(requireUtils$1(), exports);
    })(shared);

    return shared;
  }

  Object.defineProperty(browser$2, "__esModule", {
    value: true
  });
  browser$2.KeyValueStorage = void 0;
  var tslib_1 = require$$0$2;

  var localStorage_1 = tslib_1.__importDefault(requireLocalStorage());

  var safe_json_utils_1 = requireCjs();
  var shared_1 = requireShared();

  var KeyValueStorage = /*#__PURE__*/function () {
    function KeyValueStorage() {
      _classCallCheck(this, KeyValueStorage);

      this.localStorage = localStorage_1["default"];
    }

    _createClass(KeyValueStorage, [{
      key: "getKeys",
      value: function getKeys() {
        return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", Object.keys(this.localStorage));

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
      }
    }, {
      key: "getEntries",
      value: function getEntries() {
        return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", Object.entries(this.localStorage).map(shared_1.parseEntry));

                case 1:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
      }
    }, {
      key: "getItem",
      value: function getItem(key) {
        return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee3() {
          var item;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  item = this.localStorage.getItem(key);

                  if (!(item === null)) {
                    _context3.next = 3;
                    break;
                  }

                  return _context3.abrupt("return", undefined);

                case 3:
                  return _context3.abrupt("return", safe_json_utils_1.safeJsonParse(item));

                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));
      }
    }, {
      key: "setItem",
      value: function setItem(key, value) {
        return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee4() {
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  this.localStorage.setItem(key, safe_json_utils_1.safeJsonStringify(value));

                case 1:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this);
        }));
      }
    }, {
      key: "removeItem",
      value: function removeItem(key) {
        return tslib_1.__awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee5() {
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  this.localStorage.removeItem(key);

                case 1:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));
      }
    }]);

    return KeyValueStorage;
  }();

  browser$2.KeyValueStorage = KeyValueStorage;

  var _default = browser$2["default"] = KeyValueStorage;

  var cjs$6 = {};

  var heartbeat$2 = {};

  var events = {exports: {}};

  var R$3 = (typeof Reflect === "undefined" ? "undefined" : _typeof$1(Reflect)) === 'object' ? Reflect : null;
  var ReflectApply = R$3 && typeof R$3.apply === 'function' ? R$3.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;

  if (R$3 && typeof R$3.ownKeys === 'function') {
    ReflectOwnKeys = R$3.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
      return Object.getOwnPropertyNames(target);
    };
  }

  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }

  var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
  };

  function EventEmitter() {
    EventEmitter.init.call(this);
  }

  events.exports = EventEmitter;
  events.exports.once = once; // Backwards-compat with node 0.10.x

  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.

  var defaultMaxListeners = 10;

  function checkListener(listener) {
    if (typeof listener !== 'function') {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof$1(listener));
    }
  }

  Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function get() {
      return defaultMaxListeners;
    },
    set: function set(arg) {
      if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
      }

      defaultMaxListeners = arg;
    }
  });

  EventEmitter.init = function () {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    }

    this._maxListeners = this._maxListeners || undefined;
  }; // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.


  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    }

    this._maxListeners = n;
    return this;
  };

  function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }

  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };

  EventEmitter.prototype.emit = function emit(type) {
    var args = [];

    for (var i = 1; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var doError = type === 'error';
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

    if (doError) {
      var er;
      if (args.length > 0) er = args[0];

      if (er instanceof Error) {
        // Note: The comments on the `throw` lines are intentional, they show
        // up in Node's output if this results in an unhandled exception.
        throw er; // Unhandled 'error' event
      } // At least give some kind of context to the user


      var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
      err.context = er;
      throw err; // Unhandled 'error' event
    }

    var handler = events[type];
    if (handler === undefined) return false;

    if (typeof handler === 'function') {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);

      for (var i = 0; i < len; ++i) {
        ReflectApply(listeners[i], this, args);
      }
    }

    return true;
  };

  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;

    if (events === undefined) {
      events = target._events = Object.create(null);
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener !== undefined) {
        target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object

        events = target._events;
      }

      existing = events[type];
    }

    if (existing === undefined) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      } // Check for listener leak


      m = _getMaxListeners(target);

      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true; // No error code for this since it is a Warning
        // eslint-disable-next-line no-restricted-syntax

        var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
        w.name = 'MaxListenersExceededWarning';
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }

    return target;
  }

  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };

  EventEmitter.prototype.on = EventEmitter.prototype.addListener;

  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };

  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0) return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }

  function _onceWrap(target, type, listener) {
    var state = {
      fired: false,
      wrapFn: undefined,
      target: target,
      type: type,
      listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  }

  EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };

  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  }; // Emits a 'removeListener' event if and only if the listener was removed.


  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;

    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else {
        delete events[type];
        if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
      }
    } else if (typeof list !== 'function') {
      position = -1;

      for (i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }

      if (position < 0) return this;
      if (position === 0) list.shift();else {
        spliceOne(list, position);
      }
      if (list.length === 1) events[type] = list[0];
      if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
    }

    return this;
  };

  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this; // not listening for removeListener, no need to emit

    if (events.removeListener === undefined) {
      if (arguments.length === 0) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      } else if (events[type] !== undefined) {
        if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
      }

      return this;
    } // emit removeListener for all listeners on all events


    if (arguments.length === 0) {
      var keys = Object.keys(events);
      var key;

      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (key === 'removeListener') continue;
        this.removeAllListeners(key);
      }

      this.removeAllListeners('removeListener');
      this._events = Object.create(null);
      this._eventsCount = 0;
      return this;
    }

    listeners = events[type];

    if (typeof listeners === 'function') {
      this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
      // LIFO order
      for (i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(type, listeners[i]);
      }
    }

    return this;
  };

  function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }

  EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };

  EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };

  EventEmitter.listenerCount = function (emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };

  EventEmitter.prototype.listenerCount = listenerCount;

  function listenerCount(type) {
    var events = this._events;

    if (events !== undefined) {
      var evlistener = events[type];

      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener !== undefined) {
        return evlistener.length;
      }
    }

    return 0;
  }

  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };

  function arrayClone(arr, n) {
    var copy = new Array(n);

    for (var i = 0; i < n; ++i) {
      copy[i] = arr[i];
    }

    return copy;
  }

  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++) {
      list[index] = list[index + 1];
    }

    list.pop();
  }

  function unwrapListeners(arr) {
    var ret = new Array(arr.length);

    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }

    return ret;
  }

  function once(emitter, name) {
    return new Promise(function (resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }

      function resolver() {
        if (typeof emitter.removeListener === 'function') {
          emitter.removeListener('error', errorListener);
        }

        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, {
        once: true
      });

      if (name !== 'error') {
        addErrorHandlerIfEventEmitter(emitter, errorListener, {
          once: true
        });
      }
    });
  }

  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') {
      eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
    }
  }

  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === 'function') {
      // EventTarget does not have `error` event semantics like Node
      // EventEmitters, we do not listen for `error` events here.
      emitter.addEventListener(name, function wrapListener(arg) {
        // IE does not have builtin `{ once: true }` support so we
        // have to do it manually.
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }

        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof$1(emitter));
    }
  }

  var cjs$5 = {};

  var utils$3 = {};

  var delay$1 = {};

  Object.defineProperty(delay$1, "__esModule", {
    value: true
  });
  delay$1.delay = void 0;

  function delay(timeout) {
    return new Promise(function (resolve) {
      setTimeout(function () {
        resolve(true);
      }, timeout);
    });
  }

  delay$1.delay = delay;

  var convert = {};

  var constants$2 = {};

  var misc = {};

  Object.defineProperty(misc, "__esModule", {
    value: true
  });
  misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0;
  misc.ONE_HUNDRED = 100;
  misc.ONE_THOUSAND = 1000;

  var time = {};

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  })(time);

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(misc, exports);

    __exportStar(time, exports);
  })(constants$2);

  Object.defineProperty(convert, "__esModule", {
    value: true
  });
  convert.fromMiliseconds = convert.toMiliseconds = void 0;
  var constants_1$1 = constants$2;

  function toMiliseconds(seconds) {
    return seconds * constants_1$1.ONE_THOUSAND;
  }

  convert.toMiliseconds = toMiliseconds;

  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1$1.ONE_THOUSAND);
  }

  convert.fromMiliseconds = fromMiliseconds;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(delay$1, exports);

    __exportStar(convert, exports);
  })(utils$3);

  var watch$1 = {};

  Object.defineProperty(watch$1, "__esModule", {
    value: true
  });
  watch$1.Watch = void 0;

  var Watch = /*#__PURE__*/function () {
    function Watch() {
      _classCallCheck(this, Watch);

      this.timestamps = new Map();
    }

    _createClass(Watch, [{
      key: "start",
      value: function start(label) {
        if (this.timestamps.has(label)) {
          throw new Error("Watch already started for label: ".concat(label));
        }

        this.timestamps.set(label, {
          started: Date.now()
        });
      }
    }, {
      key: "stop",
      value: function stop(label) {
        var timestamp = this.get(label);

        if (typeof timestamp.elapsed !== "undefined") {
          throw new Error("Watch already stopped for label: ".concat(label));
        }

        var elapsed = Date.now() - timestamp.started;
        this.timestamps.set(label, {
          started: timestamp.started,
          elapsed: elapsed
        });
      }
    }, {
      key: "get",
      value: function get(label) {
        var timestamp = this.timestamps.get(label);

        if (typeof timestamp === "undefined") {
          throw new Error("No timestamp found for label: ".concat(label));
        }

        return timestamp;
      }
    }, {
      key: "elapsed",
      value: function elapsed(label) {
        var timestamp = this.get(label);
        var elapsed = timestamp.elapsed || Date.now() - timestamp.started;
        return elapsed;
      }
    }]);

    return Watch;
  }();

  watch$1.Watch = Watch;

  watch$1["default"] = Watch;

  var types$1 = {};

  var watch = {};

  Object.defineProperty(watch, "__esModule", {
    value: true
  });
  watch.IWatch = void 0;

  var IWatch = /*#__PURE__*/_createClass(function IWatch() {
    _classCallCheck(this, IWatch);
  });

  watch.IWatch = IWatch;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(watch, exports);
  })(types$1);

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(utils$3, exports);

    __exportStar(watch$1, exports);

    __exportStar(types$1, exports);

    __exportStar(constants$2, exports);
  })(cjs$5);

  var types = {};

  var heartbeat$1 = {};

  var IEvents$1 = /*#__PURE__*/_createClass(function IEvents() {
    _classCallCheck(this, IEvents);
  });

  var esm$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IEvents: IEvents$1
  });

  var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(esm$1);

  Object.defineProperty(heartbeat$1, "__esModule", {
    value: true
  });
  heartbeat$1.IHeartBeat = void 0;
  var events_1$1 = require$$0$1;

  var IHeartBeat = /*#__PURE__*/function (_events_1$IEvents) {
    _inherits(IHeartBeat, _events_1$IEvents);

    var _super = _createSuper(IHeartBeat);

    function IHeartBeat(opts) {
      _classCallCheck(this, IHeartBeat);

      return _super.call(this);
    }

    return _createClass(IHeartBeat);
  }(events_1$1.IEvents);

  heartbeat$1.IHeartBeat = IHeartBeat;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(heartbeat$1, exports);
  })(types);

  var constants$1 = {};

  var heartbeat = {};

  Object.defineProperty(heartbeat, "__esModule", {
    value: true
  });
  heartbeat.HEARTBEAT_EVENTS = heartbeat.HEARTBEAT_INTERVAL = void 0;
  var time_1$1 = cjs$5;
  heartbeat.HEARTBEAT_INTERVAL = time_1$1.FIVE_SECONDS;
  heartbeat.HEARTBEAT_EVENTS = {
    pulse: "heartbeat_pulse"
  };

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(heartbeat, exports);
  })(constants$1);

  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };

  Object.defineProperty(heartbeat$2, "__esModule", {
    value: true
  });
  heartbeat$2.HeartBeat = void 0;
  var events_1 = events.exports;
  var time_1 = cjs$5;
  var types_1 = types;
  var constants_1 = constants$1;

  var HeartBeat = /*#__PURE__*/function (_types_1$IHeartBeat) {
    _inherits(HeartBeat, _types_1$IHeartBeat);

    var _super = _createSuper(HeartBeat);

    function HeartBeat(opts) {
      var _this;

      _classCallCheck(this, HeartBeat);

      _this = _super.call(this, opts);
      _this.events = new events_1.EventEmitter();
      _this.interval = constants_1.HEARTBEAT_INTERVAL;
      _this.interval = (opts === null || opts === void 0 ? void 0 : opts.interval) || constants_1.HEARTBEAT_INTERVAL;
      return _this;
    }

    _createClass(HeartBeat, [{
      key: "init",
      value: function init() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return this.initialize();

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));
      }
    }, {
      key: "on",
      value: function on(event, listener) {
        this.events.on(event, listener);
      }
    }, {
      key: "once",
      value: function once(event, listener) {
        this.events.once(event, listener);
      }
    }, {
      key: "off",
      value: function off(event, listener) {
        this.events.off(event, listener);
      }
    }, {
      key: "removeListener",
      value: function removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
    }, {
      key: "initialize",
      value: function initialize() {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee2() {
          var _this2 = this;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  setInterval(function () {
                    return _this2.pulse();
                  }, time_1.toMiliseconds(this.interval));

                case 1:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
      }
    }, {
      key: "pulse",
      value: function pulse() {
        this.events.emit(constants_1.HEARTBEAT_EVENTS.pulse);
      }
    }], [{
      key: "init",
      value: function init(opts) {
        return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee3() {
          var heartbeat;
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  heartbeat = new HeartBeat(opts);
                  _context3.next = 3;
                  return heartbeat.init();

                case 3:
                  return _context3.abrupt("return", heartbeat);

                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));
      }
    }]);

    return HeartBeat;
  }(types_1.IHeartBeat);

  heartbeat$2.HeartBeat = HeartBeat;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(heartbeat$2, exports);

    __exportStar(types, exports);

    __exportStar(constants$1, exports);
  })(cjs$6);

  var cjs$4 = {};

  var constants = {};

  var hasRequiredConstants;

  function requireConstants() {
    if (hasRequiredConstants) return constants;
    hasRequiredConstants = 1;

    Object.defineProperty(constants, "__esModule", {
      value: true
    });
    constants.PINO_CUSTOM_CONTEXT_KEY = constants.PINO_LOGGER_DEFAULTS = void 0;
    constants.PINO_LOGGER_DEFAULTS = {
      level: "info"
    };
    constants.PINO_CUSTOM_CONTEXT_KEY = "custom_context";
    return constants;
  }

  var utils$2 = {};

  var hasRequiredUtils;

  function requireUtils() {
    if (hasRequiredUtils) return utils$2;
    hasRequiredUtils = 1;

    Object.defineProperty(utils$2, "__esModule", {
      value: true
    });
    utils$2.generateChildLogger = utils$2.formatChildLoggerContext = utils$2.getLoggerContext = utils$2.setBrowserLoggerContext = utils$2.getBrowserLoggerContext = utils$2.getDefaultLoggerOptions = void 0;
    var constants_1 = requireConstants();

    function getDefaultLoggerOptions(opts) {
      return Object.assign(Object.assign({}, opts), {
        level: (opts === null || opts === void 0 ? void 0 : opts.level) || constants_1.PINO_LOGGER_DEFAULTS.level
      });
    }

    utils$2.getDefaultLoggerOptions = getDefaultLoggerOptions;

    function getBrowserLoggerContext(logger) {
      var customContextKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.PINO_CUSTOM_CONTEXT_KEY;
      return logger[customContextKey] || "";
    }

    utils$2.getBrowserLoggerContext = getBrowserLoggerContext;

    function setBrowserLoggerContext(logger, context) {
      var customContextKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_1.PINO_CUSTOM_CONTEXT_KEY;
      logger[customContextKey] = context;
      return logger;
    }

    utils$2.setBrowserLoggerContext = setBrowserLoggerContext;

    function getLoggerContext(logger) {
      var customContextKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.PINO_CUSTOM_CONTEXT_KEY;
      var context = "";

      if (typeof logger.bindings === "undefined") {
        context = getBrowserLoggerContext(logger, customContextKey);
      } else {
        context = logger.bindings().context || "";
      }

      return context;
    }

    utils$2.getLoggerContext = getLoggerContext;

    function formatChildLoggerContext(logger, childContext) {
      var customContextKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_1.PINO_CUSTOM_CONTEXT_KEY;
      var parentContext = getLoggerContext(logger, customContextKey);
      var context = parentContext.trim() ? "".concat(parentContext, "/").concat(childContext) : childContext;
      return context;
    }

    utils$2.formatChildLoggerContext = formatChildLoggerContext;

    function generateChildLogger(logger, childContext) {
      var customContextKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : constants_1.PINO_CUSTOM_CONTEXT_KEY;
      var context = formatChildLoggerContext(logger, childContext, customContextKey);
      var child = logger.child({
        context: context
      });
      return setBrowserLoggerContext(child, context, customContextKey);
    }

    utils$2.generateChildLogger = generateChildLogger;
    return utils$2;
  }

  (function (exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var tslib_1 = require$$0$2;

    tslib_1.__exportStar(requireConstants(), exports);

    tslib_1.__exportStar(requireUtils(), exports);
  })(cjs$4);

  var m$4 = /*#__PURE__*/function (_c) {
    _inherits(m, _c);

    var _super = _createSuper(m);

    function m(t) {
      var _this;

      _classCallCheck(this, m);

      _this = _super.call(this), _this.opts = t, _this.protocol = "wc", _this.version = 2;
      return _this;
    }

    return _createClass(m);
  }(IEvents$1);

  var g$2 = /*#__PURE__*/function (_c2) {
    _inherits(g, _c2);

    var _super2 = _createSuper(g);

    function g(t, s) {
      var _this2;

      _classCallCheck(this, g);

      _this2 = _super2.call(this), _this2.core = t, _this2.logger = s, _this2.records = new Map();
      return _this2;
    }

    return _createClass(g);
  }(IEvents$1);

  var p$2 = /*#__PURE__*/_createClass(function p(t, s) {
    _classCallCheck(this, p);

    this.logger = t, this.core = s;
  });

  var d$5 = /*#__PURE__*/function (_c3) {
    _inherits(d, _c3);

    var _super3 = _createSuper(d);

    function d(t, s) {
      var _this3;

      _classCallCheck(this, d);

      _this3 = _super3.call(this), _this3.relayer = t, _this3.logger = s;
      return _this3;
    }

    return _createClass(d);
  }(IEvents$1);

  var L$5 = /*#__PURE__*/function (_c4) {
    _inherits(L, _c4);

    var _super4 = _createSuper(L);

    function L(t) {
      _classCallCheck(this, L);

      return _super4.call(this);
    }

    return _createClass(L);
  }(IEvents$1);

  var x$3 = /*#__PURE__*/_createClass(function x(t, s, i, h) {
    _classCallCheck(this, x);

    this.core = t, this.logger = s, this.name = i;
  });

  var b$1 = /*#__PURE__*/function (_c5) {
    _inherits(b, _c5);

    var _super5 = _createSuper(b);

    function b(t, s) {
      var _this4;

      _classCallCheck(this, b);

      _this4 = _super5.call(this), _this4.relayer = t, _this4.logger = s;
      return _this4;
    }

    return _createClass(b);
  }(IEvents$1);

  function r$2() {
    this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
  }

  var f$2 = r$2;
  r$2.EventEmitter = r$2, r$2.prototype._events = void 0, r$2.prototype._maxListeners = void 0, r$2.defaultMaxListeners = 10, r$2.prototype.setMaxListeners = function (e) {
    if (!I$4(e) || e < 0 || isNaN(e)) throw TypeError("n must be a positive number");
    return this._maxListeners = e, this;
  }, r$2.prototype.emit = function (e) {
    var t, s, i, h, n, u;

    if (this._events || (this._events = {}), e === "error" && (!this._events.error || l$1(this._events.error) && !this._events.error.length)) {
      if (t = arguments[1], t instanceof Error) throw t;
      var a = new Error('Uncaught, unspecified "error" event. (' + t + ")");
      throw a.context = t, a;
    }

    if (s = this._events[e], v$2(s)) return !1;
    if (o$2(s)) switch (arguments.length) {
      case 1:
        s.call(this);
        break;

      case 2:
        s.call(this, arguments[1]);
        break;

      case 3:
        s.call(this, arguments[1], arguments[2]);
        break;

      default:
        h = Array.prototype.slice.call(arguments, 1), s.apply(this, h);
    } else if (l$1(s)) for (h = Array.prototype.slice.call(arguments, 1), u = s.slice(), i = u.length, n = 0; n < i; n++) {
      u[n].apply(this, h);
    }
    return !0;
  }, r$2.prototype.addListener = function (e, t) {
    var s;
    if (!o$2(t)) throw TypeError("listener must be a function");
    return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", e, o$2(t.listener) ? t.listener : t), this._events[e] ? l$1(this._events[e]) ? this._events[e].push(t) : this._events[e] = [this._events[e], t] : this._events[e] = t, l$1(this._events[e]) && !this._events[e].warned && (v$2(this._maxListeners) ? s = r$2.defaultMaxListeners : s = this._maxListeners, s && s > 0 && this._events[e].length > s && (this._events[e].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[e].length), typeof console.trace == "function" && console.trace())), this;
  }, r$2.prototype.on = r$2.prototype.addListener, r$2.prototype.once = function (e, t) {
    if (!o$2(t)) throw TypeError("listener must be a function");
    var s = !1;

    function i() {
      this.removeListener(e, i), s || (s = !0, t.apply(this, arguments));
    }

    return i.listener = t, this.on(e, i), this;
  }, r$2.prototype.removeListener = function (e, t) {
    var s, i, h, n;
    if (!o$2(t)) throw TypeError("listener must be a function");
    if (!this._events || !this._events[e]) return this;
    if (s = this._events[e], h = s.length, i = -1, s === t || o$2(s.listener) && s.listener === t) delete this._events[e], this._events.removeListener && this.emit("removeListener", e, t);else if (l$1(s)) {
      for (n = h; n-- > 0;) {
        if (s[n] === t || s[n].listener && s[n].listener === t) {
          i = n;
          break;
        }
      }

      if (i < 0) return this;
      s.length === 1 ? (s.length = 0, delete this._events[e]) : s.splice(i, 1), this._events.removeListener && this.emit("removeListener", e, t);
    }
    return this;
  }, r$2.prototype.removeAllListeners = function (e) {
    var t, s;
    if (!this._events) return this;
    if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[e] && delete this._events[e], this;

    if (arguments.length === 0) {
      for (t in this._events) {
        t !== "removeListener" && this.removeAllListeners(t);
      }

      return this.removeAllListeners("removeListener"), this._events = {}, this;
    }

    if (s = this._events[e], o$2(s)) this.removeListener(e, s);else if (s) for (; s.length;) {
      this.removeListener(e, s[s.length - 1]);
    }
    return delete this._events[e], this;
  }, r$2.prototype.listeners = function (e) {
    var t;
    return !this._events || !this._events[e] ? t = [] : o$2(this._events[e]) ? t = [this._events[e]] : t = this._events[e].slice(), t;
  }, r$2.prototype.listenerCount = function (e) {
    if (this._events) {
      var t = this._events[e];
      if (o$2(t)) return 1;
      if (t) return t.length;
    }

    return 0;
  }, r$2.listenerCount = function (e, t) {
    return e.listenerCount(t);
  };

  function o$2(e) {
    return typeof e == "function";
  }

  function I$4(e) {
    return typeof e == "number";
  }

  function l$1(e) {
    return _typeof$1(e) == "object" && e !== null;
  }

  function v$2(e) {
    return e === void 0;
  }

  var C$4 = /*#__PURE__*/_createClass(function C(t) {
    _classCallCheck(this, C);

    this.opts = t, this.protocol = "wc", this.version = 2;
  });

  /*#__PURE__*/(function (_f$EventEmitter) {
    _inherits(M, _f$EventEmitter);

    var _super7 = _createSuper(M);

    function M() {
      _classCallCheck(this, M);

      return _super7.call(this);
    }

    return _createClass(M);
  })(f$2.EventEmitter);

  var k$4 = /*#__PURE__*/_createClass(function k(t) {
    _classCallCheck(this, k);

    this.client = t;
  });

  var T$6 = /*#__PURE__*/function (_c6) {
    _inherits(T, _c6);

    var _super8 = _createSuper(T);

    function T(t, s) {
      var _this5;

      _classCallCheck(this, T);

      _this5 = _super8.call(this), _this5.core = t, _this5.logger = s;
      return _this5;
    }

    return _createClass(T);
  }(IEvents$1);

  function safeJsonParse$1(value) {
    if (typeof value !== "string") {
      throw new Error("Cannot safe json parse value of type ".concat(_typeof$1(value)));
    }

    try {
      return JSON.parse(value);
    } catch (_a) {
      return value;
    }
  }
  function safeJsonStringify$1(value) {
    return typeof value === "string" ? value : JSON.stringify(value);
  }

  var ed25519 = {};

  var random = {};

  var system = {};

  var browser$1 = {};

  // MIT License. See LICENSE file for details.


  Object.defineProperty(browser$1, "__esModule", {
    value: true
  });
  var QUOTA = 65536;

  var BrowserRandomSource =
  /** @class */
  function () {
    function BrowserRandomSource() {
      this.isAvailable = false;
      this.isInstantiated = false;
      var browserCrypto = typeof self !== 'undefined' ? self.crypto || self.msCrypto // IE11 has msCrypto
      : null;

      if (browserCrypto && browserCrypto.getRandomValues) {
        this._crypto = browserCrypto;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }

    BrowserRandomSource.prototype.randomBytes = function (length) {
      if (!this.isAvailable || !this._crypto) {
        throw new Error("Browser random byte generator is not available.");
      }

      var out = new Uint8Array(length);

      for (var i = 0; i < out.length; i += QUOTA) {
        this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
      }

      return out;
    };

    return BrowserRandomSource;
  }();

  browser$1.BrowserRandomSource = BrowserRandomSource;

  function commonjsRequire(path) {
  	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
  }

  var node = {};

  var wipe$1 = {};

  // MIT License. See LICENSE file for details.


  Object.defineProperty(wipe$1, "__esModule", {
    value: true
  });
  /**
   * Sets all values in the given array to zero and returns it.
   *
   * The fact that it sets bytes to zero can be relied on.
   *
   * There is no guarantee that this function makes data disappear from memory,
   * as runtime implementation can, for example, have copying garbage collector
   * that will make copies of sensitive data before we wipe it. Or that an
   * operating system will write our data to swap or sleep image. Another thing
   * is that an optimizing compiler can remove calls to this function or make it
   * no-op. There's nothing we can do with it, so we just do our best and hope
   * that everything will be okay and good will triumph over evil.
   */

  function wipe(array) {
    // Right now it's similar to array.fill(0). If it turns
    // out that runtimes optimize this call away, maybe
    // we can try something else.
    for (var i = 0; i < array.length; i++) {
      array[i] = 0;
    }

    return array;
  }

  wipe$1.wipe = wipe;

  var _nodeResolve_empty = {};

  var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _nodeResolve_empty
  });

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

  // MIT License. See LICENSE file for details.


  Object.defineProperty(node, "__esModule", {
    value: true
  });
  var wipe_1$3 = wipe$1;

  var NodeRandomSource =
  /** @class */
  function () {
    function NodeRandomSource() {
      this.isAvailable = false;
      this.isInstantiated = false;

      if (typeof commonjsRequire !== "undefined") {
        var nodeCrypto = require$$1;

        if (nodeCrypto && nodeCrypto.randomBytes) {
          this._crypto = nodeCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
    }

    NodeRandomSource.prototype.randomBytes = function (length) {
      if (!this.isAvailable || !this._crypto) {
        throw new Error("Node.js random byte generator is not available.");
      } // Get random bytes (result is Buffer).


      var buffer = this._crypto.randomBytes(length); // Make sure we got the length that we requested.


      if (buffer.length !== length) {
        throw new Error("NodeRandomSource: got fewer bytes than requested");
      } // Allocate output array.


      var out = new Uint8Array(length); // Copy bytes from buffer to output.

      for (var i = 0; i < out.length; i++) {
        out[i] = buffer[i];
      } // Cleanup.


      wipe_1$3.wipe(buffer);
      return out;
    };

    return NodeRandomSource;
  }();

  node.NodeRandomSource = NodeRandomSource;

  // MIT License. See LICENSE file for details.


  Object.defineProperty(system, "__esModule", {
    value: true
  });
  var browser_1 = browser$1;
  var node_1 = node;

  var SystemRandomSource =
  /** @class */
  function () {
    function SystemRandomSource() {
      this.isAvailable = false;
      this.name = ""; // Try browser.

      this._source = new browser_1.BrowserRandomSource();

      if (this._source.isAvailable) {
        this.isAvailable = true;
        this.name = "Browser";
        return;
      } // If no browser source, try Node.


      this._source = new node_1.NodeRandomSource();

      if (this._source.isAvailable) {
        this.isAvailable = true;
        this.name = "Node";
        return;
      } // No sources, we're out of options.

    }

    SystemRandomSource.prototype.randomBytes = function (length) {
      if (!this.isAvailable) {
        throw new Error("System random byte generator is not available.");
      }

      return this._source.randomBytes(length);
    };

    return SystemRandomSource;
  }();

  system.SystemRandomSource = SystemRandomSource;

  var binary = {};

  var int = {};

  (function (exports) {
    // MIT License. See LICENSE file for details.

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Package int provides helper functions for integerss.
     */
    // Shim using 16-bit pieces.

    function imulShim(a, b) {
      var ah = a >>> 16 & 0xffff,
          al = a & 0xffff;
      var bh = b >>> 16 & 0xffff,
          bl = b & 0xffff;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    /** 32-bit integer multiplication.  */
    // Use system Math.imul if available, otherwise use our shim.


    exports.mul = Math.imul || imulShim;
    /** 32-bit integer addition.  */

    function add(a, b) {
      return a + b | 0;
    }

    exports.add = add;
    /**  32-bit integer subtraction.  */

    function sub(a, b) {
      return a - b | 0;
    }

    exports.sub = sub;
    /** 32-bit integer left rotation */

    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }

    exports.rotl = rotl;
    /** 32-bit integer left rotation */

    function rotr(x, n) {
      return x << 32 - n | x >>> n;
    }

    exports.rotr = rotr;

    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    /**
     * Returns true if the argument is an integer number.
     *
     * In ES2015, Number.isInteger.
     */


    exports.isInteger = Number.isInteger || isIntegerShim;
    /**
     *  Math.pow(2, 53) - 1
     *
     *  In ES2015 Number.MAX_SAFE_INTEGER.
     */

    exports.MAX_SAFE_INTEGER = 9007199254740991;
    /**
     * Returns true if the argument is a safe integer number
     * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)
     *
     * In ES2015, Number.isSafeInteger.
     */

    exports.isSafeInteger = function (n) {
      return exports.isInteger(n) && n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER;
    };
  })(int);

  // MIT License. See LICENSE file for details.


  Object.defineProperty(binary, "__esModule", {
    value: true
  });
  /**
   * Package binary provides functions for encoding and decoding numbers in byte arrays.
   */

  var int_1 = int; // TODO(dchest): add asserts for correct value ranges and array offsets.

  /**
   * Reads 2 bytes from array starting at offset as big-endian
   * signed 16-bit integer and returns it.
   */

  function readInt16BE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
  }

  binary.readInt16BE = readInt16BE;
  /**
   * Reads 2 bytes from array starting at offset as big-endian
   * unsigned 16-bit integer and returns it.
   */

  function readUint16BE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
  }

  binary.readUint16BE = readUint16BE;
  /**
   * Reads 2 bytes from array starting at offset as little-endian
   * signed 16-bit integer and returns it.
   */

  function readInt16LE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
  }

  binary.readInt16LE = readInt16LE;
  /**
   * Reads 2 bytes from array starting at offset as little-endian
   * unsigned 16-bit integer and returns it.
   */

  function readUint16LE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    return (array[offset + 1] << 8 | array[offset]) >>> 0;
  }

  binary.readUint16LE = readUint16LE;
  /**
   * Writes 2-byte big-endian representation of 16-bit unsigned
   * value to byte array starting at offset.
   *
   * If byte array is not given, creates a new 2-byte one.
   *
   * Returns the output byte array.
   */

  function writeUint16BE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(2);
    }

    if (offset === void 0) {
      offset = 0;
    }

    out[offset + 0] = value >>> 8;
    out[offset + 1] = value >>> 0;
    return out;
  }

  binary.writeUint16BE = writeUint16BE;
  binary.writeInt16BE = writeUint16BE;
  /**
   * Writes 2-byte little-endian representation of 16-bit unsigned
   * value to array starting at offset.
   *
   * If byte array is not given, creates a new 2-byte one.
   *
   * Returns the output byte array.
   */

  function writeUint16LE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(2);
    }

    if (offset === void 0) {
      offset = 0;
    }

    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    return out;
  }

  binary.writeUint16LE = writeUint16LE;
  binary.writeInt16LE = writeUint16LE;
  /**
   * Reads 4 bytes from array starting at offset as big-endian
   * signed 32-bit integer and returns it.
   */

  function readInt32BE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
  }

  binary.readInt32BE = readInt32BE;
  /**
   * Reads 4 bytes from array starting at offset as big-endian
   * unsigned 32-bit integer and returns it.
   */

  function readUint32BE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
  }

  binary.readUint32BE = readUint32BE;
  /**
   * Reads 4 bytes from array starting at offset as little-endian
   * signed 32-bit integer and returns it.
   */

  function readInt32LE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
  }

  binary.readInt32LE = readInt32LE;
  /**
   * Reads 4 bytes from array starting at offset as little-endian
   * unsigned 32-bit integer and returns it.
   */

  function readUint32LE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
  }

  binary.readUint32LE = readUint32LE;
  /**
   * Writes 4-byte big-endian representation of 32-bit unsigned
   * value to byte array starting at offset.
   *
   * If byte array is not given, creates a new 4-byte one.
   *
   * Returns the output byte array.
   */

  function writeUint32BE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(4);
    }

    if (offset === void 0) {
      offset = 0;
    }

    out[offset + 0] = value >>> 24;
    out[offset + 1] = value >>> 16;
    out[offset + 2] = value >>> 8;
    out[offset + 3] = value >>> 0;
    return out;
  }

  binary.writeUint32BE = writeUint32BE;
  binary.writeInt32BE = writeUint32BE;
  /**
   * Writes 4-byte little-endian representation of 32-bit unsigned
   * value to array starting at offset.
   *
   * If byte array is not given, creates a new 4-byte one.
   *
   * Returns the output byte array.
   */

  function writeUint32LE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(4);
    }

    if (offset === void 0) {
      offset = 0;
    }

    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    out[offset + 2] = value >>> 16;
    out[offset + 3] = value >>> 24;
    return out;
  }

  binary.writeUint32LE = writeUint32LE;
  binary.writeInt32LE = writeUint32LE;
  /**
   * Reads 8 bytes from array starting at offset as big-endian
   * signed 64-bit integer and returns it.
   *
   * IMPORTANT: due to JavaScript limitation, supports exact
   * numbers in range -9007199254740991 to 9007199254740991.
   * If the number stored in the byte array is outside this range,
   * the result is not exact.
   */

  function readInt64BE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var hi = readInt32BE(array, offset);
    var lo = readInt32BE(array, offset + 4);
    return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;
  }

  binary.readInt64BE = readInt64BE;
  /**
   * Reads 8 bytes from array starting at offset as big-endian
   * unsigned 64-bit integer and returns it.
   *
   * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
   */

  function readUint64BE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var hi = readUint32BE(array, offset);
    var lo = readUint32BE(array, offset + 4);
    return hi * 0x100000000 + lo;
  }

  binary.readUint64BE = readUint64BE;
  /**
   * Reads 8 bytes from array starting at offset as little-endian
   * signed 64-bit integer and returns it.
   *
   * IMPORTANT: due to JavaScript limitation, supports exact
   * numbers in range -9007199254740991 to 9007199254740991.
   * If the number stored in the byte array is outside this range,
   * the result is not exact.
   */

  function readInt64LE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var lo = readInt32LE(array, offset);
    var hi = readInt32LE(array, offset + 4);
    return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;
  }

  binary.readInt64LE = readInt64LE;
  /**
   * Reads 8 bytes from array starting at offset as little-endian
   * unsigned 64-bit integer and returns it.
   *
   * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
   */

  function readUint64LE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var lo = readUint32LE(array, offset);
    var hi = readUint32LE(array, offset + 4);
    return hi * 0x100000000 + lo;
  }

  binary.readUint64LE = readUint64LE;
  /**
   * Writes 8-byte big-endian representation of 64-bit unsigned
   * value to byte array starting at offset.
   *
   * Due to JavaScript limitation, supports values up to 2^53-1.
   *
   * If byte array is not given, creates a new 8-byte one.
   *
   * Returns the output byte array.
   */

  function writeUint64BE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(8);
    }

    if (offset === void 0) {
      offset = 0;
    }

    writeUint32BE(value / 0x100000000 >>> 0, out, offset);
    writeUint32BE(value >>> 0, out, offset + 4);
    return out;
  }

  binary.writeUint64BE = writeUint64BE;
  binary.writeInt64BE = writeUint64BE;
  /**
   * Writes 8-byte little-endian representation of 64-bit unsigned
   * value to byte array starting at offset.
   *
   * Due to JavaScript limitation, supports values up to 2^53-1.
   *
   * If byte array is not given, creates a new 8-byte one.
   *
   * Returns the output byte array.
   */

  function writeUint64LE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(8);
    }

    if (offset === void 0) {
      offset = 0;
    }

    writeUint32LE(value >>> 0, out, offset);
    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);
    return out;
  }

  binary.writeUint64LE = writeUint64LE;
  binary.writeInt64LE = writeUint64LE;
  /**
   * Reads bytes from array starting at offset as big-endian
   * unsigned bitLen-bit integer and returns it.
   *
   * Supports bit lengths divisible by 8, up to 48.
   */

  function readUintBE(bitLength, array, offset) {
    if (offset === void 0) {
      offset = 0;
    } // TODO(dchest): implement support for bitLengths non-divisible by 8


    if (bitLength % 8 !== 0) {
      throw new Error("readUintBE supports only bitLengths divisible by 8");
    }

    if (bitLength / 8 > array.length - offset) {
      throw new Error("readUintBE: array is too short for the given bitLength");
    }

    var result = 0;
    var mul = 1;

    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
      result += array[i] * mul;
      mul *= 256;
    }

    return result;
  }

  binary.readUintBE = readUintBE;
  /**
   * Reads bytes from array starting at offset as little-endian
   * unsigned bitLen-bit integer and returns it.
   *
   * Supports bit lengths divisible by 8, up to 48.
   */

  function readUintLE(bitLength, array, offset) {
    if (offset === void 0) {
      offset = 0;
    } // TODO(dchest): implement support for bitLengths non-divisible by 8


    if (bitLength % 8 !== 0) {
      throw new Error("readUintLE supports only bitLengths divisible by 8");
    }

    if (bitLength / 8 > array.length - offset) {
      throw new Error("readUintLE: array is too short for the given bitLength");
    }

    var result = 0;
    var mul = 1;

    for (var i = offset; i < offset + bitLength / 8; i++) {
      result += array[i] * mul;
      mul *= 256;
    }

    return result;
  }

  binary.readUintLE = readUintLE;
  /**
   * Writes a big-endian representation of bitLen-bit unsigned
   * value to array starting at offset.
   *
   * Supports bit lengths divisible by 8, up to 48.
   *
   * If byte array is not given, creates a new one.
   *
   * Returns the output byte array.
   */

  function writeUintBE(bitLength, value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(bitLength / 8);
    }

    if (offset === void 0) {
      offset = 0;
    } // TODO(dchest): implement support for bitLengths non-divisible by 8


    if (bitLength % 8 !== 0) {
      throw new Error("writeUintBE supports only bitLengths divisible by 8");
    }

    if (!int_1.isSafeInteger(value)) {
      throw new Error("writeUintBE value must be an integer");
    }

    var div = 1;

    for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
      out[i] = value / div & 0xff;
      div *= 256;
    }

    return out;
  }

  binary.writeUintBE = writeUintBE;
  /**
   * Writes a little-endian representation of bitLen-bit unsigned
   * value to array starting at offset.
   *
   * Supports bit lengths divisible by 8, up to 48.
   *
   * If byte array is not given, creates a new one.
   *
   * Returns the output byte array.
   */

  function writeUintLE(bitLength, value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(bitLength / 8);
    }

    if (offset === void 0) {
      offset = 0;
    } // TODO(dchest): implement support for bitLengths non-divisible by 8


    if (bitLength % 8 !== 0) {
      throw new Error("writeUintLE supports only bitLengths divisible by 8");
    }

    if (!int_1.isSafeInteger(value)) {
      throw new Error("writeUintLE value must be an integer");
    }

    var div = 1;

    for (var i = offset; i < offset + bitLength / 8; i++) {
      out[i] = value / div & 0xff;
      div *= 256;
    }

    return out;
  }

  binary.writeUintLE = writeUintLE;
  /**
   * Reads 4 bytes from array starting at offset as big-endian
   * 32-bit floating-point number and returns it.
   */

  function readFloat32BE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset);
  }

  binary.readFloat32BE = readFloat32BE;
  /**
   * Reads 4 bytes from array starting at offset as little-endian
   * 32-bit floating-point number and returns it.
   */

  function readFloat32LE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset, true);
  }

  binary.readFloat32LE = readFloat32LE;
  /**
   * Reads 8 bytes from array starting at offset as big-endian
   * 64-bit floating-point number ("double") and returns it.
   */

  function readFloat64BE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset);
  }

  binary.readFloat64BE = readFloat64BE;
  /**
   * Reads 8 bytes from array starting at offset as little-endian
   * 64-bit floating-point number ("double") and returns it.
   */

  function readFloat64LE(array, offset) {
    if (offset === void 0) {
      offset = 0;
    }

    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset, true);
  }

  binary.readFloat64LE = readFloat64LE;
  /**
   * Writes 4-byte big-endian floating-point representation of value
   * to byte array starting at offset.
   *
   * If byte array is not given, creates a new 4-byte one.
   *
   * Returns the output byte array.
   */

  function writeFloat32BE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(4);
    }

    if (offset === void 0) {
      offset = 0;
    }

    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value);
    return out;
  }

  binary.writeFloat32BE = writeFloat32BE;
  /**
   * Writes 4-byte little-endian floating-point representation of value
   * to byte array starting at offset.
   *
   * If byte array is not given, creates a new 4-byte one.
   *
   * Returns the output byte array.
   */

  function writeFloat32LE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(4);
    }

    if (offset === void 0) {
      offset = 0;
    }

    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value, true);
    return out;
  }

  binary.writeFloat32LE = writeFloat32LE;
  /**
   * Writes 8-byte big-endian floating-point representation of value
   * to byte array starting at offset.
   *
   * If byte array is not given, creates a new 8-byte one.
   *
   * Returns the output byte array.
   */

  function writeFloat64BE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(8);
    }

    if (offset === void 0) {
      offset = 0;
    }

    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value);
    return out;
  }

  binary.writeFloat64BE = writeFloat64BE;
  /**
   * Writes 8-byte little-endian floating-point representation of value
   * to byte array starting at offset.
   *
   * If byte array is not given, creates a new 8-byte one.
   *
   * Returns the output byte array.
   */

  function writeFloat64LE(value, out, offset) {
    if (out === void 0) {
      out = new Uint8Array(8);
    }

    if (offset === void 0) {
      offset = 0;
    }

    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value, true);
    return out;
  }

  binary.writeFloat64LE = writeFloat64LE;

  (function (exports) {
    // MIT License. See LICENSE file for details.

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var system_1 = system;
    var binary_1 = binary;
    var wipe_1 = wipe$1;
    exports.defaultRandomSource = new system_1.SystemRandomSource();

    function randomBytes(length, prng) {
      if (prng === void 0) {
        prng = exports.defaultRandomSource;
      }

      return prng.randomBytes(length);
    }

    exports.randomBytes = randomBytes;
    /**
     * Returns a uniformly random unsigned 32-bit integer.
     */

    function randomUint32(prng) {
      if (prng === void 0) {
        prng = exports.defaultRandomSource;
      } // Generate 4-byte random buffer.


      var buf = randomBytes(4, prng); // Convert bytes from buffer into a 32-bit integer.
      // It's not important which byte order to use, since
      // the result is random.

      var result = binary_1.readUint32LE(buf); // Clean the buffer.

      wipe_1.wipe(buf);
      return result;
    }

    exports.randomUint32 = randomUint32;
    /** 62 alphanumeric characters for default charset of randomString() */

    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    /**
     * Returns a uniform random string of the given length
     * with characters from the given charset.
     *
     * Charset must not have more than 256 characters.
     *
     * Default charset generates case-sensitive alphanumeric
     * strings (0-9, A-Z, a-z).
     */

    function randomString(length, charset, prng) {
      if (charset === void 0) {
        charset = ALPHANUMERIC;
      }

      if (prng === void 0) {
        prng = exports.defaultRandomSource;
      }

      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }

      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }

      var out = '';
      var charsLen = charset.length;
      var maxByte = 256 - 256 % charsLen;

      while (length > 0) {
        var buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);

        for (var i = 0; i < buf.length && length > 0; i++) {
          var randomByte = buf[i];

          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length--;
          }
        }

        wipe_1.wipe(buf);
      }

      return out;
    }

    exports.randomString = randomString;
    /**
     * Returns uniform random string containing at least the given
     * number of bits of entropy.
     *
     * For example, randomStringForEntropy(128) will return a 22-character
     * alphanumeric string, while randomStringForEntropy(128, "0123456789")
     * will return a 39-character numeric string, both will contain at
     * least 128 bits of entropy.
     *
     * Default charset generates case-sensitive alphanumeric
     * strings (0-9, A-Z, a-z).
     */

    function randomStringForEntropy(bits, charset, prng) {
      if (charset === void 0) {
        charset = ALPHANUMERIC;
      }

      if (prng === void 0) {
        prng = exports.defaultRandomSource;
      }

      var length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length, charset, prng);
    }

    exports.randomStringForEntropy = randomStringForEntropy;
  })(random);

  var sha512$1 = {};

  (function (exports) {
    // MIT License. See LICENSE file for details.

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var binary_1 = binary;
    var wipe_1 = wipe$1;
    exports.DIGEST_LENGTH = 64;
    exports.BLOCK_SIZE = 128;
    /**
     * SHA-2-512 cryptographic hash algorithm.
     */

    var SHA512 =
    /** @class */
    function () {
      function SHA512() {
        /** Length of hash output */
        this.digestLength = exports.DIGEST_LENGTH;
        /** Block size */

        this.blockSize = exports.BLOCK_SIZE; // Note: Int32Array is used instead of Uint32Array for performance reasons.

        this._stateHi = new Int32Array(8); // hash state, high bytes

        this._stateLo = new Int32Array(8); // hash state, low bytes

        this._tempHi = new Int32Array(16); // temporary state, high bytes

        this._tempLo = new Int32Array(16); // temporary state, low bytes

        this._buffer = new Uint8Array(256); // buffer for data to hash

        this._bufferLength = 0; // number of bytes in buffer

        this._bytesHashed = 0; // number of total bytes hashed

        this._finished = false; // indicates whether the hash was finalized

        this.reset();
      }

      SHA512.prototype._initState = function () {
        this._stateHi[0] = 0x6a09e667;
        this._stateHi[1] = 0xbb67ae85;
        this._stateHi[2] = 0x3c6ef372;
        this._stateHi[3] = 0xa54ff53a;
        this._stateHi[4] = 0x510e527f;
        this._stateHi[5] = 0x9b05688c;
        this._stateHi[6] = 0x1f83d9ab;
        this._stateHi[7] = 0x5be0cd19;
        this._stateLo[0] = 0xf3bcc908;
        this._stateLo[1] = 0x84caa73b;
        this._stateLo[2] = 0xfe94f82b;
        this._stateLo[3] = 0x5f1d36f1;
        this._stateLo[4] = 0xade682d1;
        this._stateLo[5] = 0x2b3e6c1f;
        this._stateLo[6] = 0xfb41bd6b;
        this._stateLo[7] = 0x137e2179;
      };
      /**
       * Resets hash state making it possible
       * to re-use this instance to hash other data.
       */


      SHA512.prototype.reset = function () {
        this._initState();

        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      /**
       * Cleans internal buffers and resets hash state.
       */


      SHA512.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._tempHi);
        wipe_1.wipe(this._tempLo);
        this.reset();
      };
      /**
       * Updates hash state with the given data.
       *
       * Throws error when trying to update already finalized hash:
       * instance must be reset to update it again.
       */


      SHA512.prototype.update = function (data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }

        if (this._finished) {
          throw new Error("SHA512: can't update because hash was finished.");
        }

        var dataPos = 0;
        this._bytesHashed += dataLength;

        if (this._bufferLength > 0) {
          while (this._bufferLength < exports.BLOCK_SIZE && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }

          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }

        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }

        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }

        return this;
      };
      /**
       * Finalizes hash state and puts hash into out.
       * If hash was already finalized, puts the same value.
       */


      SHA512.prototype.finish = function (out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 0x20000000 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 128 < 112 ? 128 : 256;
          this._buffer[left] = 0x80;

          for (var i = left + 1; i < padLength - 8; i++) {
            this._buffer[i] = 0;
          }

          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
          this._finished = true;
        }

        for (var i = 0; i < this.digestLength / 8; i++) {
          binary_1.writeUint32BE(this._stateHi[i], out, i * 8);
          binary_1.writeUint32BE(this._stateLo[i], out, i * 8 + 4);
        }

        return this;
      };
      /**
       * Returns the final hash digest.
       */


      SHA512.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      /**
       * Function useful for HMAC/PBKDF2 optimization. Returns hash state to be
       * used with restoreState(). Only chain value is saved, not buffers or
       * other state variables.
       */


      SHA512.prototype.saveState = function () {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }

        return {
          stateHi: new Int32Array(this._stateHi),
          stateLo: new Int32Array(this._stateLo),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      /**
       * Function useful for HMAC/PBKDF2 optimization. Restores state saved by
       * saveState() and sets bytesHashed to the given value.
       */


      SHA512.prototype.restoreState = function (savedState) {
        this._stateHi.set(savedState.stateHi);

        this._stateLo.set(savedState.stateLo);

        this._bufferLength = savedState.bufferLength;

        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }

        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      /**
       * Cleans state returned by saveState().
       */


      SHA512.prototype.cleanSavedState = function (savedState) {
        wipe_1.wipe(savedState.stateHi);
        wipe_1.wipe(savedState.stateLo);

        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }

        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };

      return SHA512;
    }();

    exports.SHA512 = SHA512; // Constants

    var K = new Int32Array([0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817]);

    function hashBlocks(wh, wl, hh, hl, m, pos, len) {
      var ah0 = hh[0],
          ah1 = hh[1],
          ah2 = hh[2],
          ah3 = hh[3],
          ah4 = hh[4],
          ah5 = hh[5],
          ah6 = hh[6],
          ah7 = hh[7],
          al0 = hl[0],
          al1 = hl[1],
          al2 = hl[2],
          al3 = hl[3],
          al4 = hl[4],
          al5 = hl[5],
          al6 = hl[6],
          al7 = hl[7];
      var h, l;
      var th, tl;
      var a, b, c, d;

      while (len >= 128) {
        for (var i = 0; i < 16; i++) {
          var j = 8 * i + pos;
          wh[i] = binary_1.readUint32BE(m, j);
          wl[i] = binary_1.readUint32BE(m, j + 4);
        }

        for (var i = 0; i < 80; i++) {
          var bh0 = ah0;
          var bh1 = ah1;
          var bh2 = ah2;
          var bh3 = ah3;
          var bh4 = ah4;
          var bh5 = ah5;
          var bh6 = ah6;
          var bh7 = ah7;
          var bl0 = al0;
          var bl1 = al1;
          var bl2 = al2;
          var bl3 = al3;
          var bl4 = al4;
          var bl5 = al5;
          var bl6 = al6;
          var bl7 = al7; // add

          h = ah7;
          l = al7;
          a = l & 0xffff;
          b = l >>> 16;
          c = h & 0xffff;
          d = h >>> 16; // Sigma1

          h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
          l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // Ch

          h = ah4 & ah5 ^ ~ah4 & ah6;
          l = al4 & al5 ^ ~al4 & al6;
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // K

          h = K[i * 2];
          l = K[i * 2 + 1];
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // w

          h = wh[i % 16];
          l = wl[i % 16];
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          th = c & 0xffff | d << 16;
          tl = a & 0xffff | b << 16; // add

          h = th;
          l = tl;
          a = l & 0xffff;
          b = l >>> 16;
          c = h & 0xffff;
          d = h >>> 16; // Sigma0

          h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
          l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16; // Maj

          h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
          l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh7 = c & 0xffff | d << 16;
          bl7 = a & 0xffff | b << 16; // add

          h = bh3;
          l = bl3;
          a = l & 0xffff;
          b = l >>> 16;
          c = h & 0xffff;
          d = h >>> 16;
          h = th;
          l = tl;
          a += l & 0xffff;
          b += l >>> 16;
          c += h & 0xffff;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          bh3 = c & 0xffff | d << 16;
          bl3 = a & 0xffff | b << 16;
          ah1 = bh0;
          ah2 = bh1;
          ah3 = bh2;
          ah4 = bh3;
          ah5 = bh4;
          ah6 = bh5;
          ah7 = bh6;
          ah0 = bh7;
          al1 = bl0;
          al2 = bl1;
          al3 = bl2;
          al4 = bl3;
          al5 = bl4;
          al6 = bl5;
          al7 = bl6;
          al0 = bl7;

          if (i % 16 === 15) {
            for (var j = 0; j < 16; j++) {
              // add
              h = wh[j];
              l = wl[j];
              a = l & 0xffff;
              b = l >>> 16;
              c = h & 0xffff;
              d = h >>> 16;
              h = wh[(j + 9) % 16];
              l = wl[(j + 9) % 16];
              a += l & 0xffff;
              b += l >>> 16;
              c += h & 0xffff;
              d += h >>> 16; // sigma0

              th = wh[(j + 1) % 16];
              tl = wl[(j + 1) % 16];
              h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
              l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
              a += l & 0xffff;
              b += l >>> 16;
              c += h & 0xffff;
              d += h >>> 16; // sigma1

              th = wh[(j + 14) % 16];
              tl = wl[(j + 14) % 16];
              h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
              l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
              a += l & 0xffff;
              b += l >>> 16;
              c += h & 0xffff;
              d += h >>> 16;
              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;
              wh[j] = c & 0xffff | d << 16;
              wl[j] = a & 0xffff | b << 16;
            }
          }
        } // add


        h = ah0;
        l = al0;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = c & 0xffff | d << 16;
        hl[0] = al0 = a & 0xffff | b << 16;
        h = ah1;
        l = al1;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = c & 0xffff | d << 16;
        hl[1] = al1 = a & 0xffff | b << 16;
        h = ah2;
        l = al2;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = c & 0xffff | d << 16;
        hl[2] = al2 = a & 0xffff | b << 16;
        h = ah3;
        l = al3;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = c & 0xffff | d << 16;
        hl[3] = al3 = a & 0xffff | b << 16;
        h = ah4;
        l = al4;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = c & 0xffff | d << 16;
        hl[4] = al4 = a & 0xffff | b << 16;
        h = ah5;
        l = al5;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = c & 0xffff | d << 16;
        hl[5] = al5 = a & 0xffff | b << 16;
        h = ah6;
        l = al6;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = c & 0xffff | d << 16;
        hl[6] = al6 = a & 0xffff | b << 16;
        h = ah7;
        l = al7;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = c & 0xffff | d << 16;
        hl[7] = al7 = a & 0xffff | b << 16;
        pos += 128;
        len -= 128;
      }

      return pos;
    }

    function hash(data) {
      var h = new SHA512();
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }

    exports.hash = hash;
  })(sha512$1);

  (function (exports) {
    // MIT License. See LICENSE file for details.

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Package ed25519 implements Ed25519 public-key signature algorithm.
     */

    var random_1 = random;
    var sha512_1 = sha512$1;
    var wipe_1 = wipe$1;
    exports.SIGNATURE_LENGTH = 64;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 64;
    exports.SEED_LENGTH = 32; // Returns new zero-filled 16-element GF (Float64Array).
    // If passed an array of numbers, prefills the returned
    // array with them.
    //
    // We use Float64Array, because we need 48-bit numbers
    // for this implementation.

    function gf(init) {
      var r = new Float64Array(16);

      if (init) {
        for (var i = 0; i < init.length; i++) {
          r[i] = init[i];
        }
      }

      return r;
    } // Base point.


    var _9 = new Uint8Array(32);

    _9[0] = 9;
    var gf0 = gf();
    var gf1 = gf([1]);
    var D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]);
    var D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]);
    var X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]);
    var Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]);
    var I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

    function set25519(r, a) {
      for (var i = 0; i < 16; i++) {
        r[i] = a[i] | 0;
      }
    }

    function car25519(o) {
      var c = 1;

      for (var i = 0; i < 16; i++) {
        var v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }

      o[0] += c - 1 + 37 * (c - 1);
    }

    function sel25519(p, q, b) {
      var c = ~(b - 1);

      for (var i = 0; i < 16; i++) {
        var t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }

    function pack25519(o, n) {
      var m = gf();
      var t = gf();

      for (var i = 0; i < 16; i++) {
        t[i] = n[i];
      }

      car25519(t);
      car25519(t);
      car25519(t);

      for (var j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;

        for (var i = 1; i < 15; i++) {
          m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 0xffff;
        }

        m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
        var b = m[15] >> 16 & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
      }

      for (var i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
      }
    }

    function verify32(x, y) {
      var d = 0;

      for (var i = 0; i < 32; i++) {
        d |= x[i] ^ y[i];
      }

      return (1 & d - 1 >>> 8) - 1;
    }

    function neq25519(a, b) {
      var c = new Uint8Array(32);
      var d = new Uint8Array(32);
      pack25519(c, a);
      pack25519(d, b);
      return verify32(c, d);
    }

    function par25519(a) {
      var d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }

    function unpack25519(o, n) {
      for (var i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }

      o[15] &= 0x7fff;
    }

    function add(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
      }
    }

    function sub(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
      }
    }

    function mul(o, a, b) {
      var v,
          c,
          t0 = 0,
          t1 = 0,
          t2 = 0,
          t3 = 0,
          t4 = 0,
          t5 = 0,
          t6 = 0,
          t7 = 0,
          t8 = 0,
          t9 = 0,
          t10 = 0,
          t11 = 0,
          t12 = 0,
          t13 = 0,
          t14 = 0,
          t15 = 0,
          t16 = 0,
          t17 = 0,
          t18 = 0,
          t19 = 0,
          t20 = 0,
          t21 = 0,
          t22 = 0,
          t23 = 0,
          t24 = 0,
          t25 = 0,
          t26 = 0,
          t27 = 0,
          t28 = 0,
          t29 = 0,
          t30 = 0,
          b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3],
          b4 = b[4],
          b5 = b[5],
          b6 = b[6],
          b7 = b[7],
          b8 = b[8],
          b9 = b[9],
          b10 = b[10],
          b11 = b[11],
          b12 = b[12],
          b13 = b[13],
          b14 = b[14],
          b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30; // t15 left as is
      // first car

      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1); // second car

      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }

    function square(o, a) {
      mul(o, a, a);
    }

    function inv25519(o, i) {
      var c = gf();
      var a;

      for (a = 0; a < 16; a++) {
        c[a] = i[a];
      }

      for (a = 253; a >= 0; a--) {
        square(c, c);

        if (a !== 2 && a !== 4) {
          mul(c, c, i);
        }
      }

      for (a = 0; a < 16; a++) {
        o[a] = c[a];
      }
    }

    function pow2523(o, i) {
      var c = gf();
      var a;

      for (a = 0; a < 16; a++) {
        c[a] = i[a];
      }

      for (a = 250; a >= 0; a--) {
        square(c, c);

        if (a !== 1) {
          mul(c, c, i);
        }
      }

      for (a = 0; a < 16; a++) {
        o[a] = c[a];
      }
    }

    function edadd(p, q) {
      var a = gf(),
          b = gf(),
          c = gf(),
          d = gf(),
          e = gf(),
          f = gf(),
          g = gf(),
          h = gf(),
          t = gf();
      sub(a, p[1], p[0]);
      sub(t, q[1], q[0]);
      mul(a, a, t);
      add(b, p[0], p[1]);
      add(t, q[0], q[1]);
      mul(b, b, t);
      mul(c, p[3], q[3]);
      mul(c, c, D2);
      mul(d, p[2], q[2]);
      add(d, d, d);
      sub(e, b, a);
      sub(f, d, c);
      add(g, d, c);
      add(h, b, a);
      mul(p[0], e, f);
      mul(p[1], h, g);
      mul(p[2], g, f);
      mul(p[3], e, h);
    }

    function cswap(p, q, b) {
      for (var i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }

    function pack(r, p) {
      var tx = gf(),
          ty = gf(),
          zi = gf();
      inv25519(zi, p[2]);
      mul(tx, p[0], zi);
      mul(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }

    function scalarmult(p, q, s) {
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);

      for (var i = 255; i >= 0; --i) {
        var b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        edadd(q, p);
        edadd(p, p);
        cswap(p, q, b);
      }
    }

    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      mul(q[3], X, Y);
      scalarmult(p, q, s);
    } // Generates key pair from secret 32-byte seed.


    function generateKeyPairFromSeed(seed) {
      if (seed.length !== exports.SEED_LENGTH) {
        throw new Error("ed25519: seed must be " + exports.SEED_LENGTH + " bytes");
      }

      var d = sha512_1.hash(seed);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var publicKey = new Uint8Array(32);
      var p = [gf(), gf(), gf(), gf()];
      scalarbase(p, d);
      pack(publicKey, p);
      var secretKey = new Uint8Array(64);
      secretKey.set(seed);
      secretKey.set(publicKey, 32);
      return {
        publicKey: publicKey,
        secretKey: secretKey
      };
    }

    exports.generateKeyPairFromSeed = generateKeyPairFromSeed;

    function generateKeyPair(prng) {
      var seed = random_1.randomBytes(32, prng);
      var result = generateKeyPairFromSeed(seed);
      wipe_1.wipe(seed);
      return result;
    }

    exports.generateKeyPair = generateKeyPair;

    function extractPublicKeyFromSecretKey(secretKey) {
      if (secretKey.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error("ed25519: secret key must be " + exports.SECRET_KEY_LENGTH + " bytes");
      }

      return new Uint8Array(secretKey.subarray(32));
    }

    exports.extractPublicKeyFromSecretKey = extractPublicKeyFromSecretKey;
    var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

    function modL(r, x) {
      var carry;
      var i;
      var j;
      var k;

      for (i = 63; i >= 32; --i) {
        carry = 0;

        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = Math.floor((x[j] + 128) / 256);
          x[j] -= carry * 256;
        }

        x[j] += carry;
        x[i] = 0;
      }

      carry = 0;

      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }

      for (j = 0; j < 32; j++) {
        x[j] -= carry * L[j];
      }

      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }

    function reduce(r) {
      var x = new Float64Array(64);

      for (var i = 0; i < 64; i++) {
        x[i] = r[i];
      }

      for (var i = 0; i < 64; i++) {
        r[i] = 0;
      }

      modL(r, x);
    } // Returns 64-byte signature of the message under the 64-byte secret key.


    function sign(secretKey, message) {
      var x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var d = sha512_1.hash(secretKey.subarray(0, 32));
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var signature = new Uint8Array(64);
      signature.set(d.subarray(32), 32);
      var hs = new sha512_1.SHA512();
      hs.update(signature.subarray(32));
      hs.update(message);
      var r = hs.digest();
      hs.clean();
      reduce(r);
      scalarbase(p, r);
      pack(signature, p);
      hs.reset();
      hs.update(signature.subarray(0, 32));
      hs.update(secretKey.subarray(32));
      hs.update(message);
      var h = hs.digest();
      reduce(h);

      for (var i = 0; i < 32; i++) {
        x[i] = r[i];
      }

      for (var i = 0; i < 32; i++) {
        for (var j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }

      modL(signature.subarray(32), x);
      return signature;
    }

    exports.sign = sign;

    function unpackneg(r, p) {
      var t = gf(),
          chk = gf(),
          num = gf(),
          den = gf(),
          den2 = gf(),
          den4 = gf(),
          den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      square(num, r[1]);
      mul(den, num, D);
      sub(num, num, r[2]);
      add(den, r[2], den);
      square(den2, den);
      square(den4, den2);
      mul(den6, den4, den2);
      mul(t, den6, num);
      mul(t, t, den);
      pow2523(t, t);
      mul(t, t, num);
      mul(t, t, den);
      mul(t, t, den);
      mul(r[0], t, den);
      square(chk, r[0]);
      mul(chk, chk, den);

      if (neq25519(chk, num)) {
        mul(r[0], r[0], I);
      }

      square(chk, r[0]);
      mul(chk, chk, den);

      if (neq25519(chk, num)) {
        return -1;
      }

      if (par25519(r[0]) === p[31] >> 7) {
        sub(r[0], gf0, r[0]);
      }

      mul(r[3], r[0], r[1]);
      return 0;
    }

    function verify(publicKey, message, signature) {
      var t = new Uint8Array(32);
      var p = [gf(), gf(), gf(), gf()];
      var q = [gf(), gf(), gf(), gf()];

      if (signature.length !== exports.SIGNATURE_LENGTH) {
        throw new Error("ed25519: signature must be " + exports.SIGNATURE_LENGTH + " bytes");
      }

      if (unpackneg(q, publicKey)) {
        return false;
      }

      var hs = new sha512_1.SHA512();
      hs.update(signature.subarray(0, 32));
      hs.update(publicKey);
      hs.update(message);
      var h = hs.digest();
      reduce(h);
      scalarmult(p, q, h);
      scalarbase(q, signature.subarray(32));
      edadd(p, q);
      pack(t, p);

      if (verify32(signature, t)) {
        return false;
      }

      return true;
    }

    exports.verify = verify;
    /**
     * Convert Ed25519 public key to X25519 public key.
     *
     * Throws if given an invalid public key.
     */

    function convertPublicKeyToX25519(publicKey) {
      var q = [gf(), gf(), gf(), gf()];

      if (unpackneg(q, publicKey)) {
        throw new Error("Ed25519: invalid public key");
      } // Formula: montgomeryX = (edwardsY + 1)*inverse(1 - edwardsY) mod p


      var a = gf();
      var b = gf();
      var y = q[1];
      add(a, gf1, y);
      sub(b, gf1, y);
      inv25519(b, b);
      mul(a, a, b);
      var z = new Uint8Array(32);
      pack25519(z, a);
      return z;
    }

    exports.convertPublicKeyToX25519 = convertPublicKeyToX25519;
    /**
     *  Convert Ed25519 secret (private) key to X25519 secret key.
     */

    function convertSecretKeyToX25519(secretKey) {
      var d = sha512_1.hash(secretKey.subarray(0, 32));
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var o = new Uint8Array(d.subarray(0, 32));
      wipe_1.wipe(d);
      return o;
    }

    exports.convertSecretKeyToX25519 = convertSecretKeyToX25519;
  })(ed25519);

  var JWT_IRIDIUM_ALG = "EdDSA";
  var JWT_IRIDIUM_TYP = "JWT";
  var JWT_DELIMITER = ".";
  var JWT_ENCODING = "base64url";
  var JSON_ENCODING = "utf8";
  var DATA_ENCODING = "utf8";
  var DID_DELIMITER = ":";
  var DID_PREFIX = "did";
  var DID_METHOD = "key";
  var MULTICODEC_ED25519_ENCODING = "base58btc";
  var MULTICODEC_ED25519_BASE = "z";
  var MULTICODEC_ED25519_HEADER = "K36";
  var KEY_PAIR_SEED_LENGTH = 32;

  function allocUnsafe$1() {
    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
      return globalThis.Buffer.allocUnsafe(size);
    }

    return new Uint8Array(size);
  }

  function concat(arrays, length) {
    if (!length) {
      length = arrays.reduce(function (acc, curr) {
        return acc + curr.length;
      }, 0);
    }

    var output = allocUnsafe$1(length);
    var offset = 0;

    var _iterator = _createForOfIteratorHelper(arrays),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var arr = _step.value;
        output.set(arr, offset);
        offset += arr.length;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return output;
  }

  function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
      throw new TypeError('Alphabet too long');
    }

    var BASE_MAP = new Uint8Array(256);

    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }

    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);

      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + ' is ambiguous');
      }

      BASE_MAP[xc] = i;
    }

    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);

    function encode(source) {
      if (source instanceof Uint8Array) ;else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }

      if (!(source instanceof Uint8Array)) {
        throw new TypeError('Expected Uint8Array');
      }

      if (source.length === 0) {
        return '';
      }

      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;

      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }

      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);

      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i = 0;

        for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }

        if (carry !== 0) {
          throw new Error('Non-zero carry');
        }

        length = i;
        pbegin++;
      }

      var it2 = size - length;

      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }

      var str = LEADER.repeat(zeroes);

      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }

      return str;
    }

    function decodeUnsafe(source) {
      if (typeof source !== 'string') {
        throw new TypeError('Expected String');
      }

      if (source.length === 0) {
        return new Uint8Array();
      }

      var psz = 0;

      if (source[psz] === ' ') {
        return;
      }

      var zeroes = 0;
      var length = 0;

      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }

      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);

      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];

        if (carry === 255) {
          return;
        }

        var i = 0;

        for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }

        if (carry !== 0) {
          throw new Error('Non-zero carry');
        }

        length = i;
        psz++;
      }

      if (source[psz] === ' ') {
        return;
      }

      var it4 = size - length;

      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }

      var vch = new Uint8Array(zeroes + (size - it4));
      var j = zeroes;

      while (it4 !== size) {
        vch[j++] = b256[it4++];
      }

      return vch;
    }

    function decode(string) {
      var buffer = decodeUnsafe(string);

      if (buffer) {
        return buffer;
      }

      throw new Error("Non-".concat(name, " character"));
    }

    return {
      encode: encode,
      decodeUnsafe: decodeUnsafe,
      decode: decode
    };
  }

  var src = base;
  var _brrp__multiformats_scope_baseX = src;

  var coerce = function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') return o;
    if (o instanceof ArrayBuffer) return new Uint8Array(o);

    if (ArrayBuffer.isView(o)) {
      return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }

    throw new Error('Unknown type, must be binary type');
  };

  var fromString$2 = function fromString(str) {
    return new TextEncoder().encode(str);
  };

  var toString$2 = function toString(b) {
    return new TextDecoder().decode(b);
  };

  var Encoder = /*#__PURE__*/function () {
    function Encoder(name, prefix, baseEncode) {
      _classCallCheck(this, Encoder);

      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
    }

    _createClass(Encoder, [{
      key: "encode",
      value: function encode(bytes) {
        if (bytes instanceof Uint8Array) {
          return "".concat(this.prefix).concat(this.baseEncode(bytes));
        } else {
          throw Error('Unknown type, must be binary type');
        }
      }
    }]);

    return Encoder;
  }();

  var Decoder = /*#__PURE__*/function () {
    function Decoder(name, prefix, baseDecode) {
      _classCallCheck(this, Decoder);

      this.name = name;
      this.prefix = prefix;

      if (prefix.codePointAt(0) === undefined) {
        throw new Error('Invalid prefix character');
      }

      this.prefixCodePoint = prefix.codePointAt(0);
      this.baseDecode = baseDecode;
    }

    _createClass(Decoder, [{
      key: "decode",
      value: function decode(text) {
        if (typeof text === 'string') {
          if (text.codePointAt(0) !== this.prefixCodePoint) {
            throw Error("Unable to decode multibase string ".concat(JSON.stringify(text), ", ").concat(this.name, " decoder only supports inputs prefixed with ").concat(this.prefix));
          }

          return this.baseDecode(text.slice(this.prefix.length));
        } else {
          throw Error('Can only multibase decode strings');
        }
      }
    }, {
      key: "or",
      value: function or(decoder) {
        return _or(this, decoder);
      }
    }]);

    return Decoder;
  }();

  var ComposedDecoder = /*#__PURE__*/function () {
    function ComposedDecoder(decoders) {
      _classCallCheck(this, ComposedDecoder);

      this.decoders = decoders;
    }

    _createClass(ComposedDecoder, [{
      key: "or",
      value: function or(decoder) {
        return _or(this, decoder);
      }
    }, {
      key: "decode",
      value: function decode(input) {
        var prefix = input[0];
        var decoder = this.decoders[prefix];

        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(input), ", only inputs prefixed with ").concat(Object.keys(this.decoders), " are supported"));
        }
      }
    }]);

    return ComposedDecoder;
  }();

  var _or = function _or(left, right) {
    return new ComposedDecoder(_objectSpread2(_objectSpread2({}, left.decoders || _defineProperty({}, left.prefix, left)), right.decoders || _defineProperty({}, right.prefix, right)));
  };
  var Codec = /*#__PURE__*/function () {
    function Codec(name, prefix, baseEncode, baseDecode) {
      _classCallCheck(this, Codec);

      this.name = name;
      this.prefix = prefix;
      this.baseEncode = baseEncode;
      this.baseDecode = baseDecode;
      this.encoder = new Encoder(name, prefix, baseEncode);
      this.decoder = new Decoder(name, prefix, baseDecode);
    }

    _createClass(Codec, [{
      key: "encode",
      value: function encode(input) {
        return this.encoder.encode(input);
      }
    }, {
      key: "decode",
      value: function decode(input) {
        return this.decoder.decode(input);
      }
    }]);

    return Codec;
  }();
  var from$2 = function from(_ref3) {
    var name = _ref3.name,
        prefix = _ref3.prefix,
        encode = _ref3.encode,
        decode = _ref3.decode;
    return new Codec(name, prefix, encode, decode);
  };
  var baseX = function baseX(_ref4) {
    var prefix = _ref4.prefix,
        name = _ref4.name,
        alphabet = _ref4.alphabet;

    var _basex = _brrp__multiformats_scope_baseX(alphabet, name),
        encode = _basex.encode,
        _decode = _basex.decode;

    return from$2({
      prefix: prefix,
      name: name,
      encode: encode,
      decode: function decode(text) {
        return coerce(_decode(text));
      }
    });
  };

  var _decode2 = function decode(string, alphabet, bitsPerChar, name) {
    var codes = {};

    for (var i = 0; i < alphabet.length; ++i) {
      codes[alphabet[i]] = i;
    }

    var end = string.length;

    while (string[end - 1] === '=') {
      --end;
    }

    var out = new Uint8Array(end * bitsPerChar / 8 | 0);
    var bits = 0;
    var buffer = 0;
    var written = 0;

    for (var _i = 0; _i < end; ++_i) {
      var value = codes[string[_i]];

      if (value === undefined) {
        throw new SyntaxError("Non-".concat(name, " character"));
      }

      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;

      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }

    if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
      throw new SyntaxError('Unexpected end of data');
    }

    return out;
  };

  var _encode = function encode(data, alphabet, bitsPerChar) {
    var pad = alphabet[alphabet.length - 1] === '=';
    var mask = (1 << bitsPerChar) - 1;
    var out = '';
    var bits = 0;
    var buffer = 0;

    for (var i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;

      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet[mask & buffer >> bits];
      }
    }

    if (bits) {
      out += alphabet[mask & buffer << bitsPerChar - bits];
    }

    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += '=';
      }
    }

    return out;
  };

  var rfc4648 = function rfc4648(_ref5) {
    var name = _ref5.name,
        prefix = _ref5.prefix,
        bitsPerChar = _ref5.bitsPerChar,
        alphabet = _ref5.alphabet;
    return from$2({
      prefix: prefix,
      name: name,
      encode: function encode(input) {
        return _encode(input, alphabet, bitsPerChar);
      },
      decode: function decode(input) {
        return _decode2(input, alphabet, bitsPerChar, name);
      }
    });
  };

  var identity$2 = from$2({
    prefix: '\0',
    name: 'identity',
    encode: function encode(buf) {
      return toString$2(buf);
    },
    decode: function decode(str) {
      return fromString$2(str);
    }
  });

  var identityBase = /*#__PURE__*/Object.freeze({
    __proto__: null,
    identity: identity$2
  });

  var base2 = rfc4648({
    prefix: '0',
    name: 'base2',
    alphabet: '01',
    bitsPerChar: 1
  });

  var base2$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base2: base2
  });

  var base8 = rfc4648({
    prefix: '7',
    name: 'base8',
    alphabet: '01234567',
    bitsPerChar: 3
  });

  var base8$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base8: base8
  });

  var base10 = baseX({
    prefix: '9',
    name: 'base10',
    alphabet: '0123456789'
  });

  var base10$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base10: base10
  });

  var base16 = rfc4648({
    prefix: 'f',
    name: 'base16',
    alphabet: '0123456789abcdef',
    bitsPerChar: 4
  });
  var base16upper = rfc4648({
    prefix: 'F',
    name: 'base16upper',
    alphabet: '0123456789ABCDEF',
    bitsPerChar: 4
  });

  var base16$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base16: base16,
    base16upper: base16upper
  });

  var base32 = rfc4648({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
  });
  var base32upper = rfc4648({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
  });
  var base32pad = rfc4648({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
  });
  var base32padupper = rfc4648({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
  });
  var base32hex = rfc4648({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
  });
  var base32hexupper = rfc4648({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
  });
  var base32hexpad = rfc4648({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
  });
  var base32hexpadupper = rfc4648({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
  });
  var base32z = rfc4648({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
  });

  var base32$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base32: base32,
    base32upper: base32upper,
    base32pad: base32pad,
    base32padupper: base32padupper,
    base32hex: base32hex,
    base32hexupper: base32hexupper,
    base32hexpad: base32hexpad,
    base32hexpadupper: base32hexpadupper,
    base32z: base32z
  });

  var base36 = baseX({
    prefix: 'k',
    name: 'base36',
    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
  });
  var base36upper = baseX({
    prefix: 'K',
    name: 'base36upper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  });

  var base36$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base36: base36,
    base36upper: base36upper
  });

  var base58btc = baseX({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
  });
  var base58flickr = baseX({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
  });

  var base58 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base58btc: base58btc,
    base58flickr: base58flickr
  });

  var base64 = rfc4648({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
  });
  var base64pad = rfc4648({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
  });
  var base64url = rfc4648({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
  });
  var base64urlpad = rfc4648({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
  });

  var base64$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base64: base64,
    base64pad: base64pad,
    base64url: base64url,
    base64urlpad: base64urlpad
  });

  var alphabet = Array.from("\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42");
  var alphabetBytesToChars = alphabet.reduce(function (p, c, i) {
    p[i] = c;
    return p;
  }, []);
  var alphabetCharsToBytes = alphabet.reduce(function (p, c, i) {
    p[c.codePointAt(0)] = i;
    return p;
  }, []);

  function encode$2(data) {
    return data.reduce(function (p, c) {
      p += alphabetBytesToChars[c];
      return p;
    }, '');
  }

  function decode$2(str) {
    var byts = [];

    var _iterator = _createForOfIteratorHelper(str),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _char = _step.value;

        var byt = alphabetCharsToBytes[_char.codePointAt(0)];

        if (byt === undefined) {
          throw new Error("Non-base256emoji character: ".concat(_char));
        }

        byts.push(byt);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return new Uint8Array(byts);
  }

  var base256emoji = from$2({
    prefix: "\uD83D\uDE80",
    name: 'base256emoji',
    encode: encode$2,
    decode: decode$2
  });

  var base256emoji$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base256emoji: base256emoji
  });

  var encode_1 = encode$1;
  var MSB = 128,
      REST = 127,
      MSBALL = ~REST,
      INT = Math.pow(2, 31);

  function encode$1(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;

    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }

    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }

    out[offset] = num | 0;
    encode$1.bytes = offset - oldOffset + 1;
    return out;
  }

  var decode$1 = read;
  var MSB$1 = 128,
      REST$1 = 127;

  function read(buf, offset) {
    var res = 0,
        offset = offset || 0,
        shift = 0,
        counter = offset,
        b,
        l = buf.length;

    do {
      if (counter >= l) {
        read.bytes = 0;
        throw new RangeError('Could not decode varint');
      }

      b = buf[counter++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);

    read.bytes = counter - offset;
    return res;
  }

  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);

  var length = function length(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };

  var varint = {
    encode: encode_1,
    decode: decode$1,
    encodingLength: length
  };
  var _brrp_varint = varint;

  var encodeTo = function encodeTo(_int, target) {
    var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    _brrp_varint.encode(_int, target, offset);
    return target;
  };
  var encodingLength = function encodingLength(_int2) {
    return _brrp_varint.encodingLength(_int2);
  };

  var create = function create(code, digest) {
    var size = digest.byteLength;
    var sizeOffset = encodingLength(code);
    var digestOffset = sizeOffset + encodingLength(size);
    var bytes = new Uint8Array(digestOffset + size);
    encodeTo(code, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
  };
  var Digest = /*#__PURE__*/_createClass(function Digest(code, size, digest, bytes) {
    _classCallCheck(this, Digest);

    this.code = code;
    this.size = size;
    this.digest = digest;
    this.bytes = bytes;
  });

  var from$1 = function from(_ref) {
    var name = _ref.name,
        code = _ref.code,
        encode = _ref.encode;
    return new Hasher(name, code, encode);
  };
  var Hasher = /*#__PURE__*/function () {
    function Hasher(name, code, encode) {
      _classCallCheck(this, Hasher);

      this.name = name;
      this.code = code;
      this.encode = encode;
    }

    _createClass(Hasher, [{
      key: "digest",
      value: function digest(input) {
        var _this = this;

        if (input instanceof Uint8Array) {
          var result = this.encode(input);
          return result instanceof Uint8Array ? create(this.code, result) : result.then(function (digest) {
            return create(_this.code, digest);
          });
        } else {
          throw Error('Unknown type, must be binary type');
        }
      }
    }]);

    return Hasher;
  }();

  var sha = function sha(name) {
    return /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(data) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = Uint8Array;
                _context.next = 3;
                return crypto.subtle.digest(name, data);

              case 3:
                _context.t1 = _context.sent;
                return _context.abrupt("return", new _context.t0(_context.t1));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }();
  };

  var sha256$1 = from$1({
    name: 'sha2-256',
    code: 18,
    encode: sha('SHA-256')
  });
  var sha512 = from$1({
    name: 'sha2-512',
    code: 19,
    encode: sha('SHA-512')
  });

  var sha2 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    sha256: sha256$1,
    sha512: sha512
  });

  var code = 0;
  var name = 'identity';
  var encode = coerce;

  var digest = function digest(input) {
    return create(code, encode(input));
  };

  var identity = {
    code: code,
    name: name,
    encode: encode,
    digest: digest
  };

  var identity$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    identity: identity
  });

  new TextEncoder();
  new TextDecoder();

  var bases = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, identityBase), base2$1), base8$1), base10$1), base16$1), base32$1), base36$1), base58), base64$1), base256emoji$1);

  _objectSpread2(_objectSpread2({}, sha2), identity$1);

  function createCodec(name, prefix, encode, decode) {
    return {
      name: name,
      prefix: prefix,
      encoder: {
        name: name,
        prefix: prefix,
        encode: encode
      },
      decoder: {
        decode: decode
      }
    };
  }

  var string = createCodec('utf8', 'u', function (buf) {
    var decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
  }, function (str) {
    var encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
  });
  var ascii = createCodec('ascii', 'a', function (buf) {
    var string = 'a';

    for (var i = 0; i < buf.length; i++) {
      string += String.fromCharCode(buf[i]);
    }

    return string;
  }, function (str) {
    str = str.substring(1);
    var buf = allocUnsafe$1(str.length);

    for (var i = 0; i < str.length; i++) {
      buf[i] = str.charCodeAt(i);
    }

    return buf;
  });

  var BASES = _objectSpread2({
    utf8: string,
    'utf-8': string,
    hex: bases.base16,
    latin1: ascii,
    ascii: ascii,
    binary: ascii
  }, bases);

  function toString$1(array) {
    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';
    var base = BASES[encoding];

    if (!base) {
      throw new Error("Unsupported encoding \"".concat(encoding, "\""));
    }

    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
    }

    return base.encoder.encode(array).substring(1);
  }

  function fromString$1(string) {
    var encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'utf8';
    var base = BASES[encoding];

    if (!base) {
      throw new Error("Unsupported encoding \"".concat(encoding, "\""));
    }

    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
      return globalThis.Buffer.from(string, 'utf8');
    }

    return base.decoder.decode("".concat(base.prefix).concat(string));
  }

  function encodeJSON(val) {
    return toString$1(fromString$1(safeJsonStringify$1(val), JSON_ENCODING), JWT_ENCODING);
  }
  function encodeIss(publicKey) {
    var header = fromString$1(MULTICODEC_ED25519_HEADER, MULTICODEC_ED25519_ENCODING);
    var multicodec = MULTICODEC_ED25519_BASE + toString$1(concat([header, publicKey]), MULTICODEC_ED25519_ENCODING);
    return [DID_PREFIX, DID_METHOD, multicodec].join(DID_DELIMITER);
  }
  function encodeSig(bytes) {
    return toString$1(bytes, JWT_ENCODING);
  }
  function encodeData(params) {
    return fromString$1([encodeJSON(params.header), encodeJSON(params.payload)].join(JWT_DELIMITER), DATA_ENCODING);
  }
  function encodeJWT(params) {
    return [encodeJSON(params.header), encodeJSON(params.payload), encodeSig(params.signature)].join(JWT_DELIMITER);
  }

  function generateKeyPair() {
    var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : random.randomBytes(KEY_PAIR_SEED_LENGTH);
    return ed25519.generateKeyPairFromSeed(seed);
  }
  function signJWT(_x, _x2, _x3, _x4) {
    return _signJWT.apply(this, arguments);
  }

  function _signJWT() {
    _signJWT = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(sub, aud, ttl, keyPair) {
      var iat,
          header,
          iss,
          exp,
          payload,
          data,
          signature,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              iat = _args.length > 4 && _args[4] !== undefined ? _args[4] : cjs$5.fromMiliseconds(Date.now());
              header = {
                alg: JWT_IRIDIUM_ALG,
                typ: JWT_IRIDIUM_TYP
              };
              iss = encodeIss(keyPair.publicKey);
              exp = iat + ttl;
              payload = {
                iss: iss,
                sub: sub,
                aud: aud,
                iat: iat,
                exp: exp
              };
              data = encodeData({
                header: header,
                payload: payload
              });
              signature = ed25519.sign(keyPair.secretKey, data);
              return _context.abrupt("return", encodeJWT({
                header: header,
                payload: payload,
                signature: signature
              }));

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _signJWT.apply(this, arguments);
  }

  var chacha20poly1305 = {};

  var chacha = {};

  // MIT License. See LICENSE file for details.


  Object.defineProperty(chacha, "__esModule", {
    value: true
  });
  /**
   * Package chacha implements ChaCha stream cipher.
   */

  var binary_1 = binary;
  var wipe_1$2 = wipe$1; // Number of ChaCha rounds (ChaCha20).

  var ROUNDS = 20; // Applies the ChaCha core function to 16-byte input,
  // 32-byte key key, and puts the result into 64-byte array out.

  function core(out, input, key) {
    var j0 = 0x61707865; // "expa"  -- ChaCha's "sigma" constant

    var j1 = 0x3320646E; // "nd 3"     for 32-byte keys

    var j2 = 0x79622D32; // "2-by"

    var j3 = 0x6B206574; // "te k"

    var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
    var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
    var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
    var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
    var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
    var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
    var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
    var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
    var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
    var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
    var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
    var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
    var x0 = j0;
    var x1 = j1;
    var x2 = j2;
    var x3 = j3;
    var x4 = j4;
    var x5 = j5;
    var x6 = j6;
    var x7 = j7;
    var x8 = j8;
    var x9 = j9;
    var x10 = j10;
    var x11 = j11;
    var x12 = j12;
    var x13 = j13;
    var x14 = j14;
    var x15 = j15;

    for (var i = 0; i < ROUNDS; i += 2) {
      x0 = x0 + x4 | 0;
      x12 ^= x0;
      x12 = x12 >>> 32 - 16 | x12 << 16;
      x8 = x8 + x12 | 0;
      x4 ^= x8;
      x4 = x4 >>> 32 - 12 | x4 << 12;
      x1 = x1 + x5 | 0;
      x13 ^= x1;
      x13 = x13 >>> 32 - 16 | x13 << 16;
      x9 = x9 + x13 | 0;
      x5 ^= x9;
      x5 = x5 >>> 32 - 12 | x5 << 12;
      x2 = x2 + x6 | 0;
      x14 ^= x2;
      x14 = x14 >>> 32 - 16 | x14 << 16;
      x10 = x10 + x14 | 0;
      x6 ^= x10;
      x6 = x6 >>> 32 - 12 | x6 << 12;
      x3 = x3 + x7 | 0;
      x15 ^= x3;
      x15 = x15 >>> 32 - 16 | x15 << 16;
      x11 = x11 + x15 | 0;
      x7 ^= x11;
      x7 = x7 >>> 32 - 12 | x7 << 12;
      x2 = x2 + x6 | 0;
      x14 ^= x2;
      x14 = x14 >>> 32 - 8 | x14 << 8;
      x10 = x10 + x14 | 0;
      x6 ^= x10;
      x6 = x6 >>> 32 - 7 | x6 << 7;
      x3 = x3 + x7 | 0;
      x15 ^= x3;
      x15 = x15 >>> 32 - 8 | x15 << 8;
      x11 = x11 + x15 | 0;
      x7 ^= x11;
      x7 = x7 >>> 32 - 7 | x7 << 7;
      x1 = x1 + x5 | 0;
      x13 ^= x1;
      x13 = x13 >>> 32 - 8 | x13 << 8;
      x9 = x9 + x13 | 0;
      x5 ^= x9;
      x5 = x5 >>> 32 - 7 | x5 << 7;
      x0 = x0 + x4 | 0;
      x12 ^= x0;
      x12 = x12 >>> 32 - 8 | x12 << 8;
      x8 = x8 + x12 | 0;
      x4 ^= x8;
      x4 = x4 >>> 32 - 7 | x4 << 7;
      x0 = x0 + x5 | 0;
      x15 ^= x0;
      x15 = x15 >>> 32 - 16 | x15 << 16;
      x10 = x10 + x15 | 0;
      x5 ^= x10;
      x5 = x5 >>> 32 - 12 | x5 << 12;
      x1 = x1 + x6 | 0;
      x12 ^= x1;
      x12 = x12 >>> 32 - 16 | x12 << 16;
      x11 = x11 + x12 | 0;
      x6 ^= x11;
      x6 = x6 >>> 32 - 12 | x6 << 12;
      x2 = x2 + x7 | 0;
      x13 ^= x2;
      x13 = x13 >>> 32 - 16 | x13 << 16;
      x8 = x8 + x13 | 0;
      x7 ^= x8;
      x7 = x7 >>> 32 - 12 | x7 << 12;
      x3 = x3 + x4 | 0;
      x14 ^= x3;
      x14 = x14 >>> 32 - 16 | x14 << 16;
      x9 = x9 + x14 | 0;
      x4 ^= x9;
      x4 = x4 >>> 32 - 12 | x4 << 12;
      x2 = x2 + x7 | 0;
      x13 ^= x2;
      x13 = x13 >>> 32 - 8 | x13 << 8;
      x8 = x8 + x13 | 0;
      x7 ^= x8;
      x7 = x7 >>> 32 - 7 | x7 << 7;
      x3 = x3 + x4 | 0;
      x14 ^= x3;
      x14 = x14 >>> 32 - 8 | x14 << 8;
      x9 = x9 + x14 | 0;
      x4 ^= x9;
      x4 = x4 >>> 32 - 7 | x4 << 7;
      x1 = x1 + x6 | 0;
      x12 ^= x1;
      x12 = x12 >>> 32 - 8 | x12 << 8;
      x11 = x11 + x12 | 0;
      x6 ^= x11;
      x6 = x6 >>> 32 - 7 | x6 << 7;
      x0 = x0 + x5 | 0;
      x15 ^= x0;
      x15 = x15 >>> 32 - 8 | x15 << 8;
      x10 = x10 + x15 | 0;
      x5 ^= x10;
      x5 = x5 >>> 32 - 7 | x5 << 7;
    }

    binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
    binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
    binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
    binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
    binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
    binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
    binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
    binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
    binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
    binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
    binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
    binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
    binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
    binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
    binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
    binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
  }
  /**
   * Encrypt src with ChaCha20 stream generated for the given 32-byte key and
   * 8-byte (as in original implementation) or 12-byte (as in RFC7539) nonce and
   * write the result into dst and return it.
   *
   * dst and src may be the same, but otherwise must not overlap.
   *
   * If nonce is 12 bytes, users should not encrypt more than 256 GiB with the
   * same key and nonce, otherwise the stream will repeat. The function will
   * throw error if counter overflows to prevent this.
   *
   * If nonce is 8 bytes, the output is practically unlimited (2^70 bytes, which
   * is more than a million petabytes). However, it is not recommended to
   * generate 8-byte nonces randomly, as the chance of collision is high.
   *
   * Never use the same key and nonce to encrypt more than one message.
   *
   * If nonceInplaceCounterLength is not 0, the nonce is assumed to be a 16-byte
   * array with stream counter in first nonceInplaceCounterLength bytes and nonce
   * in the last remaining bytes. The counter will be incremented inplace for
   * each ChaCha block. This is useful if you need to encrypt one stream of data
   * in chunks.
   */


  function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) {
      nonceInplaceCounterLength = 0;
    } // We only support 256-bit keys.


    if (key.length !== 32) {
      throw new Error("ChaCha: key size must be 32 bytes");
    }

    if (dst.length < src.length) {
      throw new Error("ChaCha: destination is shorter than source");
    }

    var nc;
    var counterLength;

    if (nonceInplaceCounterLength === 0) {
      if (nonce.length !== 8 && nonce.length !== 12) {
        throw new Error("ChaCha nonce must be 8 or 12 bytes");
      }

      nc = new Uint8Array(16); // First counterLength bytes of nc are counter, starting with zero.

      counterLength = nc.length - nonce.length; // Last bytes of nc after counterLength are nonce, set them.

      nc.set(nonce, counterLength);
    } else {
      if (nonce.length !== 16) {
        throw new Error("ChaCha nonce with counter must be 16 bytes");
      } // This will update passed nonce with counter inplace.


      nc = nonce;
      counterLength = nonceInplaceCounterLength;
    } // Allocate temporary space for ChaCha block.


    var block = new Uint8Array(64);

    for (var i = 0; i < src.length; i += 64) {
      // Generate a block.
      core(block, nc, key); // XOR block bytes with src into dst.

      for (var j = i; j < i + 64 && j < src.length; j++) {
        dst[j] = src[j] ^ block[j - i];
      } // Increment counter.


      incrementCounter(nc, 0, counterLength);
    } // Cleanup temporary space.


    wipe_1$2.wipe(block);

    if (nonceInplaceCounterLength === 0) {
      // Cleanup counter.
      wipe_1$2.wipe(nc);
    }

    return dst;
  }

  chacha.streamXOR = streamXOR;
  /**
   * Generate ChaCha20 stream for the given 32-byte key and 8-byte or 12-byte
   * nonce and write it into dst and return it.
   *
   * Never use the same key and nonce to generate more than one stream.
   *
   * If nonceInplaceCounterLength is not 0, it behaves the same with respect to
   * the nonce as described in the streamXOR documentation.
   *
   * stream is like streamXOR with all-zero src.
   */

  function stream(key, nonce, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) {
      nonceInplaceCounterLength = 0;
    }

    wipe_1$2.wipe(dst);
    return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
  }

  chacha.stream = stream;

  function incrementCounter(counter, pos, len) {
    var carry = 1;

    while (len--) {
      carry = carry + (counter[pos] & 0xff) | 0;
      counter[pos] = carry & 0xff;
      carry >>>= 8;
      pos++;
    }

    if (carry > 0) {
      throw new Error("ChaCha: counter overflow");
    }
  }

  var poly1305 = {};

  var constantTime = {};

  // MIT License. See LICENSE file for details.


  Object.defineProperty(constantTime, "__esModule", {
    value: true
  });
  /**
   * Package constant-time provides functions for performing algorithmically constant-time operations.
   */

  /**
   * NOTE! Due to the inability to guarantee real constant time evaluation of
   * anything in JavaScript VM, this is module is the best effort.
   */

  /**
   * Returns resultIfOne if subject is 1, or resultIfZero if subject is 0.
   *
   * Supports only 32-bit integers, so resultIfOne or resultIfZero are not
   * integers, they'll be converted to them with bitwise operations.
   */

  function select(subject, resultIfOne, resultIfZero) {
    return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
  }

  constantTime.select = select;
  /**
   * Returns 1 if a <= b, or 0 if not.
   * Arguments must be positive 32-bit integers less than or equal to 2^31 - 1.
   */

  function lessOrEqual(a, b) {
    return (a | 0) - (b | 0) - 1 >>> 31 & 1;
  }

  constantTime.lessOrEqual = lessOrEqual;
  /**
   * Returns 1 if a and b are of equal length and their contents
   * are equal, or 0 otherwise.
   *
   * Note that unlike in equal(), zero-length inputs are considered
   * the same, so this function will return 1.
   */

  function compare(a, b) {
    if (a.length !== b.length) {
      return 0;
    }

    var result = 0;

    for (var i = 0; i < a.length; i++) {
      result |= a[i] ^ b[i];
    }

    return 1 & result - 1 >>> 8;
  }

  constantTime.compare = compare;
  /**
   * Returns true if a and b are of equal non-zero length,
   * and their contents are equal, or false otherwise.
   *
   * Note that unlike in compare() zero-length inputs are considered
   * _not_ equal, so this function will return false.
   */

  function equal(a, b) {
    if (a.length === 0 || b.length === 0) {
      return false;
    }

    return compare(a, b) !== 0;
  }

  constantTime.equal = equal;

  (function (exports) {
    // MIT License. See LICENSE file for details.

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Package poly1305 implements Poly1305 one-time message authentication algorithm.
     */

    var constant_time_1 = constantTime;
    var wipe_1 = wipe$1;
    exports.DIGEST_LENGTH = 16; // Port of Andrew Moon's Poly1305-donna-16. Public domain.
    // https://github.com/floodyberry/poly1305-donna

    /**
     * Poly1305 computes 16-byte authenticator of message using
     * a one-time 32-byte key.
     *
     * Important: key should be used for only one message,
     * it should never repeat.
     */

    var Poly1305 =
    /** @class */
    function () {
      function Poly1305(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 0x1fff;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
        this._r[5] = t4 >>> 1 & 0x1ffe;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
        this._r[9] = t7 >>> 5 & 0x007f;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
      }

      Poly1305.prototype._blocks = function (m, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0],
            h1 = this._h[1],
            h2 = this._h[2],
            h3 = this._h[3],
            h4 = this._h[4],
            h5 = this._h[5],
            h6 = this._h[6],
            h7 = this._h[7],
            h8 = this._h[8],
            h9 = this._h[9];
        var r0 = this._r[0],
            r1 = this._r[1],
            r2 = this._r[2],
            r3 = this._r[3],
            r4 = this._r[4],
            r5 = this._r[5],
            r6 = this._r[6],
            r7 = this._r[7],
            r8 = this._r[8],
            r9 = this._r[9];

        while (bytes >= 16) {
          var t0 = m[mpos + 0] | m[mpos + 1] << 8;
          h0 += t0 & 0x1fff;
          var t1 = m[mpos + 2] | m[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;
          var t2 = m[mpos + 4] | m[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;
          var t3 = m[mpos + 6] | m[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;
          var t4 = m[mpos + 8] | m[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;
          h5 += t4 >>> 1 & 0x1fff;
          var t5 = m[mpos + 10] | m[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;
          var t6 = m[mpos + 12] | m[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;
          var t7 = m[mpos + 14] | m[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;
          h9 += t7 >>> 5 | hibit;
          var c = 0;
          var d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 0x1fff;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 0x1fff;
          var d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 0x1fff;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 0x1fff;
          var d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 0x1fff;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 0x1fff;
          var d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 0x1fff;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 0x1fff;
          var d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 0x1fff;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 0x1fff;
          var d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 0x1fff;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 0x1fff;
          var d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 0x1fff;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 0x1fff;
          var d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 0x1fff;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 0x1fff;
          var d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 0x1fff;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 0x1fff;
          var d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 0x1fff;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 0x1fff;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 0x1fff;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }

        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };

      Poly1305.prototype.finish = function (mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }

        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;

        if (this._leftover) {
          i = this._leftover;
          this._buffer[i++] = 1;

          for (; i < 16; i++) {
            this._buffer[i] = 0;
          }

          this._fin = 1;

          this._blocks(this._buffer, 0, 16);
        }

        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;

        for (i = 2; i < 10; i++) {
          this._h[i] += c;
          c = this._h[i] >>> 13;
          this._h[i] &= 0x1fff;
        }

        this._h[0] += c * 5;
        c = this._h[0] >>> 13;
        this._h[0] &= 0x1fff;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;

        for (i = 1; i < 10; i++) {
          g[i] = this._h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 0x1fff;
        }

        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;

        for (i = 0; i < 10; i++) {
          g[i] &= mask;
        }

        mask = ~mask;

        for (i = 0; i < 10; i++) {
          this._h[i] = this._h[i] & mask | g[i];
        }

        this._h[0] = (this._h[0] | this._h[1] << 13) & 0xffff;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 0xffff;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 0xffff;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 0xffff;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 0xffff;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 0xffff;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 0xffff;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 0xffff;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 0xffff;

        for (i = 1; i < 8; i++) {
          f = (this._h[i] + this._pad[i] | 0) + (f >>> 16) | 0;
          this._h[i] = f & 0xffff;
        }

        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };

      Poly1305.prototype.update = function (m) {
        var mpos = 0;
        var bytes = m.length;
        var want;

        if (this._leftover) {
          want = 16 - this._leftover;

          if (want > bytes) {
            want = bytes;
          }

          for (var i = 0; i < want; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }

          bytes -= want;
          mpos += want;
          this._leftover += want;

          if (this._leftover < 16) {
            return this;
          }

          this._blocks(this._buffer, 0, 16);

          this._leftover = 0;
        }

        if (bytes >= 16) {
          want = bytes - bytes % 16;

          this._blocks(m, mpos, want);

          mpos += want;
          bytes -= want;
        }

        if (bytes) {
          for (var i = 0; i < bytes; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }

          this._leftover += bytes;
        }

        return this;
      };

      Poly1305.prototype.digest = function () {
        // TODO(dchest): it behaves differently than other hashes/HMAC,
        // because it throws when finished — others just return saved result.
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }

        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };

      Poly1305.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true; // mark as finished even if not

        return this;
      };

      return Poly1305;
    }();

    exports.Poly1305 = Poly1305;
    /**
     * Returns 16-byte authenticator of data using a one-time 32-byte key.
     *
     * Important: key should be used for only one message, it should never repeat.
     */

    function oneTimeAuth(key, data) {
      var h = new Poly1305(key);
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }

    exports.oneTimeAuth = oneTimeAuth;
    /**
     * Returns true if two authenticators are 16-byte long and equal.
     * Uses contant-time comparison to avoid leaking timing information.
     */

    function equal(a, b) {
      if (a.length !== exports.DIGEST_LENGTH || b.length !== exports.DIGEST_LENGTH) {
        return false;
      }

      return constant_time_1.equal(a, b);
    }

    exports.equal = equal;
  })(poly1305);

  (function (exports) {
    // MIT License. See LICENSE file for details.

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var chacha_1 = chacha;
    var poly1305_1 = poly1305;
    var wipe_1 = wipe$1;
    var binary_1 = binary;
    var constant_time_1 = constantTime;
    exports.KEY_LENGTH = 32;
    exports.NONCE_LENGTH = 12;
    exports.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    /**
     * ChaCha20-Poly1305 Authenticated Encryption with Associated Data.
     *
     * Defined in RFC7539.
     */

    var ChaCha20Poly1305 =
    /** @class */
    function () {
      /**
       * Creates a new instance with the given 32-byte key.
       */
      function ChaCha20Poly1305(key) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;

        if (key.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        } // Copy key.


        this._key = new Uint8Array(key);
      }
      /**
       * Encrypts and authenticates plaintext, authenticates associated data,
       * and returns sealed ciphertext, which includes authentication tag.
       *
       * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
       * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
       * and nonce.
       *
       * If dst is given (it must be the size of plaintext + the size of tag
       * length) the result will be put into it. Dst and plaintext must not
       * overlap.
       */


      ChaCha20Poly1305.prototype.seal = function (nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        } // Allocate space for counter, and set nonce as last bytes of it.


        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length); // Generate authentication key by taking first 32-bytes of stream.
        // We pass full counter, which has 12-byte nonce and 4-byte block counter,
        // and it will get incremented after generating the block, which is
        // exactly what we need: we only use the first 32 bytes of 64-byte
        // ChaCha block and discard the next 32 bytes.

        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4); // Allocate space for sealed ciphertext.

        var resultLength = plaintext.length + this.tagLength;
        var result;

        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }

          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        } // Encrypt plaintext.


        chacha_1.streamXOR(this._key, counter, plaintext, result, 4); // Authenticate.
        // XXX: can "simplify" here: pass full result (which is already padded
        // due to zeroes prepared for tag), and ciphertext length instead of
        // subarray of result.

        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData); // Cleanup.


        wipe_1.wipe(counter);
        return result;
      };
      /**
       * Authenticates sealed ciphertext (which includes authentication tag) and
       * associated data, decrypts ciphertext and returns decrypted plaintext.
       *
       * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
       * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
       * and nonce.
       *
       * If authentication fails, it returns null.
       *
       * If dst is given (it must be of ciphertext length minus tag length),
       * the result will be put into it. Dst and plaintext must not overlap.
       */


      ChaCha20Poly1305.prototype.open = function (nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        } // Sealed ciphertext should at least contain tag.


        if (sealed.length < this.tagLength) {
          // TODO(dchest): should we throw here instead?
          return null;
        } // Allocate space for counter, and set nonce as last bytes of it.


        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length); // Generate authentication key by taking first 32-bytes of stream.

        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4); // Authenticate.
        // XXX: can simplify and avoid allocation: since authenticate()
        // already allocates tag (from Poly1305.digest(), it can return)
        // it instead of copying to calculatedTag. But then in seal()
        // we'll need to copy it.

        var calculatedTag = new Uint8Array(this.tagLength);

        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData); // Constant-time compare tags and return null if they differ.


        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        } // Allocate space for decrypted plaintext.


        var resultLength = sealed.length - this.tagLength;
        var result;

        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }

          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        } // Decrypt.


        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4); // Cleanup.

        wipe_1.wipe(counter);
        return result;
      };

      ChaCha20Poly1305.prototype.clean = function () {
        wipe_1.wipe(this._key);
        return this;
      };

      ChaCha20Poly1305.prototype._authenticate = function (tagOut, authKey, ciphertext, associatedData) {
        // Initialize Poly1305 with authKey.
        var h = new poly1305_1.Poly1305(authKey); // Authenticate padded associated data.

        if (associatedData) {
          h.update(associatedData);

          if (associatedData.length % 16 > 0) {
            h.update(ZEROS.subarray(associatedData.length % 16));
          }
        } // Authenticate padded ciphertext.


        h.update(ciphertext);

        if (ciphertext.length % 16 > 0) {
          h.update(ZEROS.subarray(ciphertext.length % 16));
        } // Authenticate length of associated data.
        // XXX: can avoid allocation here?


        var length = new Uint8Array(8);

        if (associatedData) {
          binary_1.writeUint64LE(associatedData.length, length);
        }

        h.update(length); // Authenticate length of ciphertext.

        binary_1.writeUint64LE(ciphertext.length, length);
        h.update(length); // Get tag and copy it into tagOut.

        var tag = h.digest();

        for (var i = 0; i < tag.length; i++) {
          tagOut[i] = tag[i];
        } // Cleanup.


        h.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length);
      };

      return ChaCha20Poly1305;
    }();

    exports.ChaCha20Poly1305 = ChaCha20Poly1305;
  })(chacha20poly1305);

  var hkdf = {};

  var hmac$1 = {};

  var hash = {};

  // MIT License. See LICENSE file for details.


  Object.defineProperty(hash, "__esModule", {
    value: true
  });

  function isSerializableHash(h) {
    return typeof h.saveState !== "undefined" && typeof h.restoreState !== "undefined" && typeof h.cleanSavedState !== "undefined";
  }

  hash.isSerializableHash = isSerializableHash; // TODO(dchest): figure out the standardized interface for XOF such as

  // MIT License. See LICENSE file for details.


  Object.defineProperty(hmac$1, "__esModule", {
    value: true
  });
  /**
   * Package hmac implements HMAC algorithm.
   */

  var hash_1 = hash;
  var constant_time_1 = constantTime;
  var wipe_1$1 = wipe$1;
  /**
   *  HMAC implements hash-based message authentication algorithm.
   */

  var HMAC =
  /** @class */
  function () {
    /**
     * Constructs a new HMAC with the given Hash and secret key.
     */
    function HMAC(hash, key) {
      this._finished = false; // true if HMAC was finalized
      // Initialize inner and outer hashes.

      this._inner = new hash();
      this._outer = new hash(); // Set block and digest sizes for this HMAC
      // instance to values from the hash.

      this.blockSize = this._outer.blockSize;
      this.digestLength = this._outer.digestLength; // Pad temporary stores a key (or its hash) padded with zeroes.

      var pad = new Uint8Array(this.blockSize);

      if (key.length > this.blockSize) {
        // If key is bigger than hash block size, it must be
        // hashed and this hash is used as a key instead.
        this._inner.update(key).finish(pad).clean();
      } else {
        // Otherwise, copy the key into pad.
        pad.set(key);
      } // Now two different keys are derived from padded key
      // by xoring a different byte value to each.
      // To make inner hash key, xor byte 0x36 into pad.


      for (var i = 0; i < pad.length; i++) {
        pad[i] ^= 0x36;
      } // Update inner hash with the result.


      this._inner.update(pad); // To make outer hash key, xor byte 0x5c into pad.
      // But since we already xored 0x36 there, we must
      // first undo this by xoring it again.


      for (var i = 0; i < pad.length; i++) {
        pad[i] ^= 0x36 ^ 0x5c;
      } // Update outer hash with the result.


      this._outer.update(pad); // Save states of both hashes, so that we can quickly restore
      // them later in reset() without the need to remember the actual
      // key and perform this initialization again.


      if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
        this._innerKeyedState = this._inner.saveState();
        this._outerKeyedState = this._outer.saveState();
      } // Clean pad.


      wipe_1$1.wipe(pad);
    }
    /**
     * Returns HMAC state to the state initialized with key
     * to make it possible to run HMAC over the other data with the same
     * key without creating a new instance.
     */


    HMAC.prototype.reset = function () {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      } // Restore keyed states of inner and outer hashes.


      this._inner.restoreState(this._innerKeyedState);

      this._outer.restoreState(this._outerKeyedState);

      this._finished = false;
      return this;
    };
    /**
     * Cleans HMAC state.
     */


    HMAC.prototype.clean = function () {
      if (hash_1.isSerializableHash(this._inner)) {
        this._inner.cleanSavedState(this._innerKeyedState);
      }

      if (hash_1.isSerializableHash(this._outer)) {
        this._outer.cleanSavedState(this._outerKeyedState);
      }

      this._inner.clean();

      this._outer.clean();
    };
    /**
     * Updates state with provided data.
     */


    HMAC.prototype.update = function (data) {
      this._inner.update(data);

      return this;
    };
    /**
     * Finalizes HMAC and puts the result in out.
     */


    HMAC.prototype.finish = function (out) {
      if (this._finished) {
        // If HMAC was finalized, outer hash is also finalized,
        // so it produces the same digest it produced when it
        // was finalized.
        this._outer.finish(out);

        return this;
      } // Finalize inner hash and store the result temporarily.


      this._inner.finish(out); // Update outer hash with digest of inner hash and and finalize it.


      this._outer.update(out.subarray(0, this.digestLength)).finish(out);

      this._finished = true;
      return this;
    };
    /**
     * Returns the computed message authentication code.
     */


    HMAC.prototype.digest = function () {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    /**
     * Saves HMAC state.
     * This function is needed for PBKDF2 optimization.
     */


    HMAC.prototype.saveState = function () {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      }

      return this._inner.saveState();
    };

    HMAC.prototype.restoreState = function (savedState) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      }

      this._inner.restoreState(savedState);

      this._outer.restoreState(this._outerKeyedState);

      this._finished = false;
      return this;
    };

    HMAC.prototype.cleanSavedState = function (savedState) {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      }

      this._inner.cleanSavedState(savedState);
    };

    return HMAC;
  }();

  hmac$1.HMAC = HMAC;
  /**
   * Returns HMAC using the given hash constructor for the key over data.
   */

  function hmac(hash, key, data) {
    var h = new HMAC(hash, key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
  }

  hmac$1.hmac = hmac;
  /**
   * Returns true if two HMAC digests are equal.
   * Uses constant-time comparison to avoid leaking timing information.
   *
   * Example:
   *
   *    const receivedDigest = ...
   *    const realDigest = hmac(SHA256, key, data);
   *    if (!equal(receivedDigest, realDigest)) {
   *        throw new Error("Authentication error");
   *    }
   */

  hmac$1.equal = constant_time_1.equal;

  // MIT License. See LICENSE file for details.


  Object.defineProperty(hkdf, "__esModule", {
    value: true
  });
  var hmac_1 = hmac$1;
  var wipe_1 = wipe$1;
  /**
   * HMAC-based Extract-and-Expand Key Derivation Function.
   *
   * Implements HKDF from RFC5869.
   *
   * Expands the given master key with salt and info into
   * a limited stream of key material.
   */

  var HKDF =
  /** @class */
  function () {
    /**
     * Create a new HKDF instance for the given hash function
     * with the master key, optional salt, and info.
     *
     * - Master key is a high-entropy secret key (not a password).
     * - Salt is a non-secret random value.
     * - Info is application- and/or context-specific information.
     */
    function HKDF(hash, key, salt, info) {
      if (salt === void 0) {
        salt = new Uint8Array(0);
      }

      this._counter = new Uint8Array(1); // starts with zero

      this._hash = hash;
      this._info = info; // HKDF-Extract uses salt as HMAC key, and key as data.

      var okm = hmac_1.hmac(this._hash, salt, key); // Initialize HMAC for expanding with extracted key.

      this._hmac = new hmac_1.HMAC(hash, okm); // Allocate buffer.

      this._buffer = new Uint8Array(this._hmac.digestLength);
      this._bufpos = this._buffer.length;
    } // Fill buffer with new block of HKDF-Extract output.


    HKDF.prototype._fillBuffer = function () {
      // Increment counter.
      this._counter[0]++;
      var ctr = this._counter[0]; // Check if counter overflowed.

      if (ctr === 0) {
        throw new Error("hkdf: cannot expand more");
      } // Prepare HMAC instance for new data with old key.


      this._hmac.reset(); // Hash in previous output if it was generated
      // (i.e. counter is greater than 1).


      if (ctr > 1) {
        this._hmac.update(this._buffer);
      } // Hash in info if it exists.


      if (this._info) {
        this._hmac.update(this._info);
      } // Hash in the counter.


      this._hmac.update(this._counter); // Output result to buffer and clean HMAC instance.


      this._hmac.finish(this._buffer); // Reset buffer position.


      this._bufpos = 0;
    };
    /**
     * Expand returns next key material of the given length.
     *
     * It throws if expansion limit is reached (which is
     * 254 digests of the underlying HMAC function).
     */


    HKDF.prototype.expand = function (length) {
      var out = new Uint8Array(length);

      for (var i = 0; i < out.length; i++) {
        if (this._bufpos === this._buffer.length) {
          this._fillBuffer();
        }

        out[i] = this._buffer[this._bufpos++];
      }

      return out;
    };

    HKDF.prototype.clean = function () {
      this._hmac.clean();

      wipe_1.wipe(this._buffer);
      wipe_1.wipe(this._counter);
      this._bufpos = 0;
    };

    return HKDF;
  }();

  var HKDF_1 = hkdf.HKDF = HKDF; // TODO(dchest): maybe implement deriveKey?

  var sha256 = {};

  (function (exports) {
    // MIT License. See LICENSE file for details.

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var binary_1 = binary;
    var wipe_1 = wipe$1;
    exports.DIGEST_LENGTH = 32;
    exports.BLOCK_SIZE = 64;
    /**
     * SHA2-256 cryptographic hash algorithm.
     */

    var SHA256 =
    /** @class */
    function () {
      function SHA256() {
        /** Length of hash output */
        this.digestLength = exports.DIGEST_LENGTH;
        /** Block size */

        this.blockSize = exports.BLOCK_SIZE; // Note: Int32Array is used instead of Uint32Array for performance reasons.

        this._state = new Int32Array(8); // hash state

        this._temp = new Int32Array(64); // temporary state

        this._buffer = new Uint8Array(128); // buffer for data to hash

        this._bufferLength = 0; // number of bytes in buffer

        this._bytesHashed = 0; // number of total bytes hashed

        this._finished = false; // indicates whether the hash was finalized

        this.reset();
      }

      SHA256.prototype._initState = function () {
        this._state[0] = 0x6a09e667;
        this._state[1] = 0xbb67ae85;
        this._state[2] = 0x3c6ef372;
        this._state[3] = 0xa54ff53a;
        this._state[4] = 0x510e527f;
        this._state[5] = 0x9b05688c;
        this._state[6] = 0x1f83d9ab;
        this._state[7] = 0x5be0cd19;
      };
      /**
       * Resets hash state making it possible
       * to re-use this instance to hash other data.
       */


      SHA256.prototype.reset = function () {
        this._initState();

        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      /**
       * Cleans internal buffers and resets hash state.
       */


      SHA256.prototype.clean = function () {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
      };
      /**
       * Updates hash state with the given data.
       *
       * Throws error when trying to update already finalized hash:
       * instance must be reset to update it again.
       */


      SHA256.prototype.update = function (data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }

        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }

        var dataPos = 0;
        this._bytesHashed += dataLength;

        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }

          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }

        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }

        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }

        return this;
      };
      /**
       * Finalizes hash state and puts hash into out.
       * If hash was already finalized, puts the same value.
       */


      SHA256.prototype.finish = function (out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 0x20000000 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 0x80;

          for (var i = left + 1; i < padLength - 8; i++) {
            this._buffer[i] = 0;
          }

          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }

        for (var i = 0; i < this.digestLength / 4; i++) {
          binary_1.writeUint32BE(this._state[i], out, i * 4);
        }

        return this;
      };
      /**
       * Returns the final hash digest.
       */


      SHA256.prototype.digest = function () {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      /**
       * Function useful for HMAC/PBKDF2 optimization.
       * Returns hash state to be used with restoreState().
       * Only chain value is saved, not buffers or other
       * state variables.
       */


      SHA256.prototype.saveState = function () {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }

        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      /**
       * Function useful for HMAC/PBKDF2 optimization.
       * Restores state saved by saveState() and sets bytesHashed
       * to the given value.
       */


      SHA256.prototype.restoreState = function (savedState) {
        this._state.set(savedState.state);

        this._bufferLength = savedState.bufferLength;

        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }

        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      /**
       * Cleans state returned by saveState().
       */


      SHA256.prototype.cleanSavedState = function (savedState) {
        wipe_1.wipe(savedState.state);

        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }

        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };

      return SHA256;
    }();

    exports.SHA256 = SHA256; // Constants

    var K = new Int32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);

    function hashBlocks(w, v, p, pos, len) {
      while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];

        for (var i = 0; i < 16; i++) {
          var j = pos + i * 4;
          w[i] = binary_1.readUint32BE(p, j);
        }

        for (var i = 16; i < 64; i++) {
          var u = w[i - 2];
          var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i - 15];
          var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }

        for (var i = 0; i < 64; i++) {
          var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
          var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }

        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
      }

      return pos;
    }

    function hash(data) {
      var h = new SHA256();
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }

    exports.hash = hash;
  })(sha256);

  var x25519 = {};

  (function (exports) {
    // MIT License. See LICENSE file for details.

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    /**
     * Package x25519 implements X25519 key agreement.
     */

    var random_1 = random;
    var wipe_1 = wipe$1;
    exports.PUBLIC_KEY_LENGTH = 32;
    exports.SECRET_KEY_LENGTH = 32;
    exports.SHARED_KEY_LENGTH = 32; // Returns new zero-filled 16-element GF (Float64Array).
    // If passed an array of numbers, prefills the returned
    // array with them.
    //
    // We use Float64Array, because we need 48-bit numbers
    // for this implementation.

    function gf(init) {
      var r = new Float64Array(16);

      if (init) {
        for (var i = 0; i < init.length; i++) {
          r[i] = init[i];
        }
      }

      return r;
    } // Base point.


    var _9 = new Uint8Array(32);

    _9[0] = 9;

    var _121665 = gf([0xdb41, 1]);

    function car25519(o) {
      var c = 1;

      for (var i = 0; i < 16; i++) {
        var v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }

      o[0] += c - 1 + 37 * (c - 1);
    }

    function sel25519(p, q, b) {
      var c = ~(b - 1);

      for (var i = 0; i < 16; i++) {
        var t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }

    function pack25519(o, n) {
      var m = gf();
      var t = gf();

      for (var i = 0; i < 16; i++) {
        t[i] = n[i];
      }

      car25519(t);
      car25519(t);
      car25519(t);

      for (var j = 0; j < 2; j++) {
        m[0] = t[0] - 0xffed;

        for (var i = 1; i < 15; i++) {
          m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 0xffff;
        }

        m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
        var b = m[15] >> 16 & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
      }

      for (var i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
      }
    }

    function unpack25519(o, n) {
      for (var i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }

      o[15] &= 0x7fff;
    }

    function add(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
      }
    }

    function sub(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
      }
    }

    function mul(o, a, b) {
      var v,
          c,
          t0 = 0,
          t1 = 0,
          t2 = 0,
          t3 = 0,
          t4 = 0,
          t5 = 0,
          t6 = 0,
          t7 = 0,
          t8 = 0,
          t9 = 0,
          t10 = 0,
          t11 = 0,
          t12 = 0,
          t13 = 0,
          t14 = 0,
          t15 = 0,
          t16 = 0,
          t17 = 0,
          t18 = 0,
          t19 = 0,
          t20 = 0,
          t21 = 0,
          t22 = 0,
          t23 = 0,
          t24 = 0,
          t25 = 0,
          t26 = 0,
          t27 = 0,
          t28 = 0,
          t29 = 0,
          t30 = 0,
          b0 = b[0],
          b1 = b[1],
          b2 = b[2],
          b3 = b[3],
          b4 = b[4],
          b5 = b[5],
          b6 = b[6],
          b7 = b[7],
          b8 = b[8],
          b9 = b[9],
          b10 = b[10],
          b11 = b[11],
          b12 = b[12],
          b13 = b[13],
          b14 = b[14],
          b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30; // t15 left as is
      // first car

      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1); // second car

      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }

    function square(o, a) {
      mul(o, a, a);
    }

    function inv25519(o, inp) {
      var c = gf();

      for (var i = 0; i < 16; i++) {
        c[i] = inp[i];
      }

      for (var i = 253; i >= 0; i--) {
        square(c, c);

        if (i !== 2 && i !== 4) {
          mul(c, c, inp);
        }
      }

      for (var i = 0; i < 16; i++) {
        o[i] = c[i];
      }
    }

    function scalarMult(n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80);
      var a = gf(),
          b = gf(),
          c = gf(),
          d = gf(),
          e = gf(),
          f = gf();

      for (var i = 0; i < 31; i++) {
        z[i] = n[i];
      }

      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);

      for (var i = 0; i < 16; i++) {
        b[i] = x[i];
      }

      a[0] = d[0] = 1;

      for (var i = 254; i >= 0; --i) {
        var r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }

      for (var i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }

      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      var q = new Uint8Array(32);
      pack25519(q, x16);
      return q;
    }

    exports.scalarMult = scalarMult;

    function scalarMultBase(n) {
      return scalarMult(n, _9);
    }

    exports.scalarMultBase = scalarMultBase;

    function generateKeyPairFromSeed(seed) {
      if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error("x25519: seed must be " + exports.SECRET_KEY_LENGTH + " bytes");
      }

      var secretKey = new Uint8Array(seed);
      var publicKey = scalarMultBase(secretKey);
      return {
        publicKey: publicKey,
        secretKey: secretKey
      };
    }

    exports.generateKeyPairFromSeed = generateKeyPairFromSeed;

    function generateKeyPair(prng) {
      var seed = random_1.randomBytes(32, prng);
      var result = generateKeyPairFromSeed(seed);
      wipe_1.wipe(seed);
      return result;
    }

    exports.generateKeyPair = generateKeyPair;
    /**
     * Returns a shared key between our secret key and a peer's public key.
     *
     * Throws an error if the given keys are of wrong length.
     *
     * If rejectZero is true throws if the calculated shared key is all-zero.
     * From RFC 7748:
     *
     * > Protocol designers using Diffie-Hellman over the curves defined in
     * > this document must not assume "contributory behavior".  Specially,
     * > contributory behavior means that both parties' private keys
     * > contribute to the resulting shared key.  Since curve25519 and
     * > curve448 have cofactors of 8 and 4 (respectively), an input point of
     * > small order will eliminate any contribution from the other party's
     * > private key.  This situation can be detected by checking for the all-
     * > zero output, which implementations MAY do, as specified in Section 6.
     * > However, a large number of existing implementations do not do this.
     *
     * IMPORTANT: the returned key is a raw result of scalar multiplication.
     * To use it as a key material, hash it with a cryptographic hash function.
     */

    function sharedKey(mySecretKey, theirPublicKey, rejectZero) {
      if (rejectZero === void 0) {
        rejectZero = false;
      }

      if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }

      if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }

      var result = scalarMult(mySecretKey, theirPublicKey);

      if (rejectZero) {
        var zeros = 0;

        for (var i = 0; i < result.length; i++) {
          zeros |= result[i];
        }

        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }

      return result;
    }

    exports.sharedKey = sharedKey;
  })(x25519);

  var __spreadArray = undefined && undefined.__spreadArray || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };

  var BrowserInfo$1 =
  /** @class */
  function () {
    function BrowserInfo(name, version, os) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.type = 'browser';
    }

    return BrowserInfo;
  }();

  var NodeInfo$1 =
  /** @class */
  function () {
    function NodeInfo(version) {
      this.version = version;
      this.type = 'node';
      this.name = 'node';
      this.os = process.platform;
    }

    return NodeInfo;
  }();

  var SearchBotDeviceInfo$1 =
  /** @class */
  function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.bot = bot;
      this.type = 'bot-device';
    }

    return SearchBotDeviceInfo;
  }();

  var BotInfo$1 =
  /** @class */
  function () {
    function BotInfo() {
      this.type = 'bot';
      this.bot = true; // NOTE: deprecated test name instead

      this.name = 'bot';
      this.version = null;
      this.os = null;
    }

    return BotInfo;
  }();

  var ReactNativeInfo$1 =
  /** @class */
  function () {
    function ReactNativeInfo() {
      this.type = 'react-native';
      this.name = 'react-native';
      this.version = null;
      this.os = null;
    }

    return ReactNativeInfo;
  }();

  var SEARCHBOX_UA_REGEX$1 = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
  var SEARCHBOT_OS_REGEX$1 = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
  var REQUIRED_VERSION_PARTS$1 = 3;
  var userAgentRules$1 = [['aol', /AOLShield\/([0-9\._]+)/], ['edge', /Edge\/([0-9\._]+)/], ['edge-ios', /EdgiOS\/([0-9\._]+)/], ['yandexbrowser', /YaBrowser\/([0-9\._]+)/], ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/], ['samsung', /SamsungBrowser\/([0-9\.]+)/], ['silk', /\bSilk\/([0-9._-]+)\b/], ['miui', /MiuiBrowser\/([0-9\.]+)$/], ['beaker', /BeakerBrowser\/([0-9\.]+)/], ['edge-chromium', /EdgA?\/([0-9\.]+)/], ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/], ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/], ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/], ['fxios', /FxiOS\/([0-9\.]+)/], ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/], ['opera', /Opera\/([0-9\.]+)(?:\s|$)/], ['opera', /OPR\/([0-9\.]+)(:?\s|$)/], ['pie', /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/], ['pie', /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/], ['netfront', /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/], ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ['ie', /MSIE\s(7\.0)/], ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/], ['android', /Android\s([0-9\.]+)/], ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/], ['safari', /Version\/([0-9\._]+).*Safari/], ['facebook', /FB[AS]V\/([0-9\.]+)/], ['instagram', /Instagram\s([0-9\.]+)/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ['curl', /^curl\/([0-9\.]+)$/], ['searchbot', SEARCHBOX_UA_REGEX$1]];
  var operatingSystemRules$1 = [['iOS', /iP(hone|od|ad)/], ['Android OS', /Android/], ['BlackBerry OS', /BlackBerry|BB10/], ['Windows Mobile', /IEMobile/], ['Amazon OS', /Kindle/], ['Windows 3.11', /Win16/], ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/], ['Windows 98', /(Windows 98)|(Win98)/], ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/], ['Windows XP', /(Windows NT 5.1)|(Windows XP)/], ['Windows Server 2003', /(Windows NT 5.2)/], ['Windows Vista', /(Windows NT 6.0)/], ['Windows 7', /(Windows NT 6.1)/], ['Windows 8', /(Windows NT 6.2)/], ['Windows 8.1', /(Windows NT 6.3)/], ['Windows 10', /(Windows NT 10.0)/], ['Windows ME', /Windows ME/], ['Windows CE', /Windows CE|WinCE|Microsoft Pocket Internet Explorer/], ['Open BSD', /OpenBSD/], ['Sun OS', /SunOS/], ['Chrome OS', /CrOS/], ['Linux', /(Linux)|(X11)/], ['Mac OS', /(Mac_PowerPC)|(Macintosh)/], ['QNX', /QNX/], ['BeOS', /BeOS/], ['OS/2', /OS\/2/]];
  function detect$1(userAgent) {
    if (!!userAgent) {
      return parseUserAgent$1(userAgent);
    }

    if (typeof document === 'undefined' && typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
      return new ReactNativeInfo$1();
    }

    if (typeof navigator !== 'undefined') {
      return parseUserAgent$1(navigator.userAgent);
    }

    return getNodeVersion$1();
  }

  function matchUserAgent$1(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return ua !== '' && userAgentRules$1.reduce(function (matched, _a) {
      var browser = _a[0],
          regex = _a[1];

      if (matched) {
        return matched;
      }

      var uaMatch = regex.exec(ua);
      return !!uaMatch && [browser, uaMatch];
    }, false);
  }
  function parseUserAgent$1(ua) {
    var matchedRule = matchUserAgent$1(ua);

    if (!matchedRule) {
      return null;
    }

    var name = matchedRule[0],
        match = matchedRule[1];

    if (name === 'searchbot') {
      return new BotInfo$1();
    } // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)


    var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);

    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS$1) {
        versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts$1(REQUIRED_VERSION_PARTS$1 - versionParts.length), true);
      }
    } else {
      versionParts = [];
    }

    var version = versionParts.join('.');
    var os = detectOS$2(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX$1.exec(ua);

    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo$1(name, version, os, searchBotMatch[1]);
    }

    return new BrowserInfo$1(name, version, os);
  }
  function detectOS$2(ua) {
    for (var ii = 0, count = operatingSystemRules$1.length; ii < count; ii++) {
      var _a = operatingSystemRules$1[ii],
          os = _a[0],
          regex = _a[1];
      var match = regex.exec(ua);

      if (match) {
        return os;
      }
    }

    return null;
  }
  function getNodeVersion$1() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo$1(process.version.slice(1)) : null;
  }

  function createVersionParts$1(count) {
    var output = [];

    for (var ii = 0; ii < count; ii++) {
      output.push('0');
    }

    return output;
  }

  var cjs$3 = {};

  Object.defineProperty(cjs$3, "__esModule", {
    value: true
  });
  var getLocalStorage_1 = cjs$3.getLocalStorage = getLocalStorageOrThrow_1 = cjs$3.getLocalStorageOrThrow = getCrypto_1 = cjs$3.getCrypto = getCryptoOrThrow_1 = cjs$3.getCryptoOrThrow = getLocation_1 = cjs$3.getLocation = getLocationOrThrow_1 = cjs$3.getLocationOrThrow = getNavigator_1 = cjs$3.getNavigator = getNavigatorOrThrow_1 = cjs$3.getNavigatorOrThrow = getDocument_1 = cjs$3.getDocument = getDocumentOrThrow_1 = cjs$3.getDocumentOrThrow = getFromWindowOrThrow_1 = cjs$3.getFromWindowOrThrow = getFromWindow_1 = cjs$3.getFromWindow = void 0;

  function getFromWindow$1(name) {
    var res = undefined;

    if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
      res = window[name];
    }

    return res;
  }

  var getFromWindow_1 = cjs$3.getFromWindow = getFromWindow$1;

  function getFromWindowOrThrow$1(name) {
    var res = getFromWindow$1(name);

    if (!res) {
      throw new Error("".concat(name, " is not defined in Window"));
    }

    return res;
  }

  var getFromWindowOrThrow_1 = cjs$3.getFromWindowOrThrow = getFromWindowOrThrow$1;

  function getDocumentOrThrow$1() {
    return getFromWindowOrThrow$1("document");
  }

  var getDocumentOrThrow_1 = cjs$3.getDocumentOrThrow = getDocumentOrThrow$1;

  function getDocument$1() {
    return getFromWindow$1("document");
  }

  var getDocument_1 = cjs$3.getDocument = getDocument$1;

  function getNavigatorOrThrow$1() {
    return getFromWindowOrThrow$1("navigator");
  }

  var getNavigatorOrThrow_1 = cjs$3.getNavigatorOrThrow = getNavigatorOrThrow$1;

  function getNavigator$1() {
    return getFromWindow$1("navigator");
  }

  var getNavigator_1 = cjs$3.getNavigator = getNavigator$1;

  function getLocationOrThrow$1() {
    return getFromWindowOrThrow$1("location");
  }

  var getLocationOrThrow_1 = cjs$3.getLocationOrThrow = getLocationOrThrow$1;

  function getLocation$1() {
    return getFromWindow$1("location");
  }

  var getLocation_1 = cjs$3.getLocation = getLocation$1;

  function getCryptoOrThrow$1() {
    return getFromWindowOrThrow$1("crypto");
  }

  var getCryptoOrThrow_1 = cjs$3.getCryptoOrThrow = getCryptoOrThrow$1;

  function getCrypto$1() {
    return getFromWindow$1("crypto");
  }

  var getCrypto_1 = cjs$3.getCrypto = getCrypto$1;

  function getLocalStorageOrThrow$1() {
    return getFromWindowOrThrow$1("localStorage");
  }

  var getLocalStorageOrThrow_1 = cjs$3.getLocalStorageOrThrow = getLocalStorageOrThrow$1;

  function getLocalStorage$1() {
    return getFromWindow$1("localStorage");
  }

  getLocalStorage_1 = cjs$3.getLocalStorage = getLocalStorage$1;

  var cjs$2 = {};

  Object.defineProperty(cjs$2, "__esModule", {
    value: true
  });
  var getWindowMetadata_1 = cjs$2.getWindowMetadata = void 0;
  var window_getters_1 = cjs$3;

  function getWindowMetadata() {
    var doc;
    var loc;

    try {
      doc = window_getters_1.getDocumentOrThrow();
      loc = window_getters_1.getLocationOrThrow();
    } catch (e) {
      return null;
    }

    function getIcons() {
      var links = doc.getElementsByTagName("link");
      var icons = [];

      for (var i = 0; i < links.length; i++) {
        var link = links[i];
        var rel = link.getAttribute("rel");

        if (rel) {
          if (rel.toLowerCase().indexOf("icon") > -1) {
            var href = link.getAttribute("href");

            if (href) {
              if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                var absoluteHref = loc.protocol + "//" + loc.host;

                if (href.indexOf("/") === 0) {
                  absoluteHref += href;
                } else {
                  var path = loc.pathname.split("/");
                  path.pop();
                  var finalPath = path.join("/");
                  absoluteHref += finalPath + "/" + href;
                }

                icons.push(absoluteHref);
              } else if (href.indexOf("//") === 0) {
                var absoluteUrl = loc.protocol + href;
                icons.push(absoluteUrl);
              } else {
                icons.push(href);
              }
            }
          }
        }
      }

      return icons;
    }

    function getWindowMetadataOfAny() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var metaTags = doc.getElementsByTagName("meta");

      var _loop = function _loop(i) {
        var tag = metaTags[i];
        var attributes = ["itemprop", "property", "name"].map(function (target) {
          return tag.getAttribute(target);
        }).filter(function (attr) {
          if (attr) {
            return args.includes(attr);
          }

          return false;
        });

        if (attributes.length && attributes) {
          var content = tag.getAttribute("content");

          if (content) {
            return {
              v: content
            };
          }
        }
      };

      for (var i = 0; i < metaTags.length; i++) {
        var _ret = _loop(i);

        if (_typeof$1(_ret) === "object") return _ret.v;
      }

      return "";
    }

    function getName() {
      var name = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");

      if (!name) {
        name = doc.title;
      }

      return name;
    }

    function getDescription() {
      var description = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
      return description;
    }

    var name = getName();
    var description = getDescription();
    var url = loc.origin;
    var icons = getIcons();
    var meta = {
      description: description,
      url: url,
      icons: icons,
      name: name
    };
    return meta;
  }

  getWindowMetadata_1 = cjs$2.getWindowMetadata = getWindowMetadata;

  var queryString = {};

  var strictUriEncode = function strictUriEncode(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function (x) {
      return "%".concat(x.charCodeAt(0).toString(16).toUpperCase());
    });
  };

  var token = '%[a-f0-9]{2}';
  var singleMatcher = new RegExp(token, 'gi');
  var multiMatcher = new RegExp('(' + token + ')+', 'gi');

  function decodeComponents(components, split) {
    try {
      // Try to decode the entire string first
      return decodeURIComponent(components.join(''));
    } catch (err) {// Do nothing
    }

    if (components.length === 1) {
      return components;
    }

    split = split || 1; // Split the array in 2 parts

    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }

  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher);

      for (var i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join('');
        tokens = input.match(singleMatcher);
      }

      return input;
    }
  }

  function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
      '%FE%FF': "\uFFFD\uFFFD",
      '%FF%FE': "\uFFFD\uFFFD"
    };
    var match = multiMatcher.exec(input);

    while (match) {
      try {
        // Decode as big chunks as possible
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);

        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }

      match = multiMatcher.exec(input);
    } // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else


    replaceMap['%C2'] = "\uFFFD";
    var entries = Object.keys(replaceMap);

    for (var i = 0; i < entries.length; i++) {
      // Replace all decoded components
      var key = entries[i];
      input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }

    return input;
  }

  var decodeUriComponent = function decodeUriComponent(encodedURI) {
    if (typeof encodedURI !== 'string') {
      throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + _typeof$1(encodedURI) + '`');
    }

    try {
      encodedURI = encodedURI.replace(/\+/g, ' '); // Try the built in decoder first

      return decodeURIComponent(encodedURI);
    } catch (err) {
      // Fallback to a more advanced decoder
      return customDecodeURIComponent(encodedURI);
    }
  };

  var splitOnFirst = function splitOnFirst(string, separator) {
    if (!(typeof string === 'string' && typeof separator === 'string')) {
      throw new TypeError('Expected the arguments to be of type `string`');
    }

    if (separator === '') {
      return [string];
    }

    var separatorIndex = string.indexOf(separator);

    if (separatorIndex === -1) {
      return [string];
    }

    return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
  };

  var filterObj = function filterObj(obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = obj[key];

      if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
        ret[key] = val;
      }
    }

    return ret;
  };

  (function (exports) {

    var strictUriEncode$1 = strictUriEncode;
    var decodeComponent = decodeUriComponent;
    var splitOnFirst$1 = splitOnFirst;
    var filterObject = filterObj;

    var isNullOrUndefined = function isNullOrUndefined(value) {
      return value === null || value === undefined;
    };

    var encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case 'index':
          return function (key) {
            return function (result, value) {
              var index = result.length;

              if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                return result;
              }

              if (value === null) {
                return [].concat(_toConsumableArray(result), [[encode(key, options), '[', index, ']'].join('')]);
              }

              return [].concat(_toConsumableArray(result), [[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')]);
            };
          };

        case 'bracket':
          return function (key) {
            return function (result, value) {
              if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                return result;
              }

              if (value === null) {
                return [].concat(_toConsumableArray(result), [[encode(key, options), '[]'].join('')]);
              }

              return [].concat(_toConsumableArray(result), [[encode(key, options), '[]=', encode(value, options)].join('')]);
            };
          };

        case 'colon-list-separator':
          return function (key) {
            return function (result, value) {
              if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                return result;
              }

              if (value === null) {
                return [].concat(_toConsumableArray(result), [[encode(key, options), ':list='].join('')]);
              }

              return [].concat(_toConsumableArray(result), [[encode(key, options), ':list=', encode(value, options)].join('')]);
            };
          };

        case 'comma':
        case 'separator':
        case 'bracket-separator':
          {
            var keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
            return function (key) {
              return function (result, value) {
                if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                  return result;
                } // Translate null to an empty string so that it doesn't serialize as 'null'


                value = value === null ? '' : value;

                if (result.length === 0) {
                  return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
                }

                return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
              };
            };
          }

        default:
          return function (key) {
            return function (result, value) {
              if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                return result;
              }

              if (value === null) {
                return [].concat(_toConsumableArray(result), [encode(key, options)]);
              }

              return [].concat(_toConsumableArray(result), [[encode(key, options), '=', encode(value, options)].join('')]);
            };
          };
      }
    }

    function parserForArrayFormat(options) {
      var result;

      switch (options.arrayFormat) {
        case 'index':
          return function (key, value, accumulator) {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, '');

            if (!result) {
              accumulator[key] = value;
              return;
            }

            if (accumulator[key] === undefined) {
              accumulator[key] = {};
            }

            accumulator[key][result[1]] = value;
          };

        case 'bracket':
          return function (key, value, accumulator) {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, '');

            if (!result) {
              accumulator[key] = value;
              return;
            }

            if (accumulator[key] === undefined) {
              accumulator[key] = [value];
              return;
            }

            accumulator[key] = [].concat(accumulator[key], value);
          };

        case 'colon-list-separator':
          return function (key, value, accumulator) {
            result = /(:list)$/.exec(key);
            key = key.replace(/:list$/, '');

            if (!result) {
              accumulator[key] = value;
              return;
            }

            if (accumulator[key] === undefined) {
              accumulator[key] = [value];
              return;
            }

            accumulator[key] = [].concat(accumulator[key], value);
          };

        case 'comma':
        case 'separator':
          return function (key, value, accumulator) {
            var isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
            var isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
            value = isEncodedArray ? decode(value, options) : value;
            var newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(function (item) {
              return decode(item, options);
            }) : value === null ? value : decode(value, options);
            accumulator[key] = newValue;
          };

        case 'bracket-separator':
          return function (key, value, accumulator) {
            var isArray = /(\[\])$/.test(key);
            key = key.replace(/\[\]$/, '');

            if (!isArray) {
              accumulator[key] = value ? decode(value, options) : value;
              return;
            }

            var arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(function (item) {
              return decode(item, options);
            });

            if (accumulator[key] === undefined) {
              accumulator[key] = arrayValue;
              return;
            }

            accumulator[key] = [].concat(accumulator[key], arrayValue);
          };

        default:
          return function (key, value, accumulator) {
            if (accumulator[key] === undefined) {
              accumulator[key] = value;
              return;
            }

            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }

    function validateArrayFormatSeparator(value) {
      if (typeof value !== 'string' || value.length !== 1) {
        throw new TypeError('arrayFormatSeparator must be single character string');
      }
    }

    function encode(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
      }

      return value;
    }

    function decode(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }

      return value;
    }

    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }

      if (_typeof$1(input) === 'object') {
        return keysSorter(Object.keys(input)).sort(function (a, b) {
          return Number(a) - Number(b);
        }).map(function (key) {
          return input[key];
        });
      }

      return input;
    }

    function removeHash(input) {
      var hashStart = input.indexOf('#');

      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }

      return input;
    }

    function getHash(url) {
      var hash = '';
      var hashStart = url.indexOf('#');

      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }

      return hash;
    }

    function extract(input) {
      input = removeHash(input);
      var queryStart = input.indexOf('?');

      if (queryStart === -1) {
        return '';
      }

      return input.slice(queryStart + 1);
    }

    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
        value = value.toLowerCase() === 'true';
      }

      return value;
    }

    function parse(query, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ',',
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      var formatter = parserForArrayFormat(options); // Create an object with no prototype

      var ret = Object.create(null);

      if (typeof query !== 'string') {
        return ret;
      }

      query = query.trim().replace(/^[?#&]/, '');

      if (!query) {
        return ret;
      }

      var _iterator = _createForOfIteratorHelper(query.split('&')),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var param = _step.value;

          if (param === '') {
            continue;
          }

          var _splitOnFirst = splitOnFirst$1(options.decode ? param.replace(/\+/g, ' ') : param, '='),
              _splitOnFirst2 = _slicedToArray(_splitOnFirst, 2),
              _key = _splitOnFirst2[0],
              _value = _splitOnFirst2[1]; // Missing `=` should be `null`:
          // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters


          _value = _value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? _value : decode(_value, options);
          formatter(decode(_key, options), _value, ret);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      for (var _i = 0, _Object$keys = Object.keys(ret); _i < _Object$keys.length; _i++) {
        var key = _Object$keys[_i];
        var value = ret[key];

        if (_typeof$1(value) === 'object' && value !== null) {
          for (var _i2 = 0, _Object$keys2 = Object.keys(value); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            value[k] = parseValue(value[k], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }

      if (options.sort === false) {
        return ret;
      }

      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce(function (result, key) {
        var value = ret[key];

        if (Boolean(value) && _typeof$1(value) === 'object' && !Array.isArray(value)) {
          // Sort object keys, not values
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }

        return result;
      }, Object.create(null));
    }

    exports.extract = extract;
    exports.parse = parse;

    exports.stringify = function (object, options) {
      if (!object) {
        return '';
      }

      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ','
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);

      var shouldFilter = function shouldFilter(key) {
        return options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
      };

      var formatter = encoderForArrayFormat(options);
      var objectCopy = {};

      for (var _i3 = 0, _Object$keys3 = Object.keys(object); _i3 < _Object$keys3.length; _i3++) {
        var key = _Object$keys3[_i3];

        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }

      var keys = Object.keys(objectCopy);

      if (options.sort !== false) {
        keys.sort(options.sort);
      }

      return keys.map(function (key) {
        var value = object[key];

        if (value === undefined) {
          return '';
        }

        if (value === null) {
          return encode(key, options);
        }

        if (Array.isArray(value)) {
          if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
            return encode(key, options) + '[]';
          }

          return value.reduce(formatter(key), []).join('&');
        }

        return encode(key, options) + '=' + encode(value, options);
      }).filter(function (x) {
        return x.length > 0;
      }).join('&');
    };

    exports.parseUrl = function (url, options) {
      options = Object.assign({
        decode: true
      }, options);

      var _splitOnFirst3 = splitOnFirst$1(url, '#'),
          _splitOnFirst4 = _slicedToArray(_splitOnFirst3, 2),
          url_ = _splitOnFirst4[0],
          hash = _splitOnFirst4[1];

      return Object.assign({
        url: url_.split('?')[0] || '',
        query: parse(extract(url), options)
      }, options && options.parseFragmentIdentifier && hash ? {
        fragmentIdentifier: decode(hash, options)
      } : {});
    };

    exports.stringifyUrl = function (object, options) {
      options = Object.assign(_defineProperty({
        encode: true,
        strict: true
      }, encodeFragmentIdentifier, true), options);
      var url = removeHash(object.url).split('?')[0] || '';
      var queryFromUrl = exports.extract(object.url);
      var parsedQueryFromUrl = exports.parse(queryFromUrl, {
        sort: false
      });
      var query = Object.assign(parsedQueryFromUrl, object.query);
      var queryString = exports.stringify(query, options);

      if (queryString) {
        queryString = "?".concat(queryString);
      }

      var hash = getHash(object.url);

      if (object.fragmentIdentifier) {
        hash = "#".concat(options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier);
      }

      return "".concat(url).concat(queryString).concat(hash);
    };

    exports.pick = function (input, filter, options) {
      options = Object.assign(_defineProperty({
        parseFragmentIdentifier: true
      }, encodeFragmentIdentifier, false), options);

      var _exports$parseUrl = exports.parseUrl(input, options),
          url = _exports$parseUrl.url,
          query = _exports$parseUrl.query,
          fragmentIdentifier = _exports$parseUrl.fragmentIdentifier;

      return exports.stringifyUrl({
        url: url,
        query: filterObject(query, filter),
        fragmentIdentifier: fragmentIdentifier
      }, options);
    };

    exports.exclude = function (input, filter, options) {
      var exclusionFilter = Array.isArray(filter) ? function (key) {
        return !filter.includes(key);
      } : function (key, value) {
        return !filter(key, value);
      };
      return exports.pick(input, exclusionFilter, options);
    };
  })(queryString);

  var RELAY_JSONRPC = {
    waku: {
      publish: "waku_publish",
      subscribe: "waku_subscribe",
      subscription: "waku_subscription",
      unsubscribe: "waku_unsubscribe"
    },
    irn: {
      publish: "irn_publish",
      subscribe: "irn_subscribe",
      subscription: "irn_subscription",
      unsubscribe: "irn_unsubscribe"
    },
    iridium: {
      publish: "iridium_publish",
      subscribe: "iridium_subscribe",
      subscription: "iridium_subscription",
      unsubscribe: "iridium_unsubscribe"
    }
  };

  var k$3 = "base10",
      a$2 = "base16",
      R$2 = "base64pad",
      C$3 = "utf8",
      L$4 = 0,
      O$2 = 1,
      un = 0,
      Ee$1 = 1,
      F$3 = 12,
      H$4 = 32;

  function dn() {
    var e = x25519.generateKeyPair();
    return {
      privateKey: toString$1(e.secretKey, a$2),
      publicKey: toString$1(e.publicKey, a$2)
    };
  }

  function ln() {
    var e = random.randomBytes(H$4);
    return toString$1(e, a$2);
  }

  function fn(e, n) {
    var t = x25519.sharedKey(fromString$1(e, a$2), fromString$1(n, a$2)),
        r = new HKDF_1(sha256.SHA256, t).expand(H$4);
    return toString$1(r, a$2);
  }

  function pn(e) {
    var n = sha256.hash(fromString$1(e, a$2));
    return toString$1(n, a$2);
  }

  function mn(e) {
    var n = sha256.hash(fromString$1(e, C$3));
    return toString$1(n, a$2);
  }

  function he$2(e) {
    return fromString$1("".concat(e), k$3);
  }

  function T$5(e) {
    return Number(toString$1(e, k$3));
  }

  function yn(e) {
    var n = he$2(_typeof$1(e.type) < "u" ? e.type : L$4);
    if (T$5(n) === O$2 && _typeof$1(e.senderPublicKey) > "u") throw new Error("Missing sender public key for type 1 envelope");
    var t = _typeof$1(e.senderPublicKey) < "u" ? fromString$1(e.senderPublicKey, a$2) : void 0,
        r = _typeof$1(e.iv) < "u" ? fromString$1(e.iv, a$2) : random.randomBytes(F$3),
        o = new chacha20poly1305.ChaCha20Poly1305(fromString$1(e.symKey, a$2)).seal(r, fromString$1(e.message, C$3));
    return Ne$1({
      type: n,
      sealed: o,
      iv: r,
      senderPublicKey: t
    });
  }

  function En(e) {
    var n = new chacha20poly1305.ChaCha20Poly1305(fromString$1(e.symKey, a$2)),
        _q = q$3(e.encoded),
        t = _q.sealed,
        r = _q.iv,
        o = n.open(r, t);

    if (o === null) throw new Error("Failed to decrypt");
    return toString$1(o, C$3);
  }

  function Ne$1(e) {
    if (T$5(e.type) === O$2) {
      if (_typeof$1(e.senderPublicKey) > "u") throw new Error("Missing sender public key for type 1 envelope");
      return toString$1(concat([e.type, e.senderPublicKey, e.iv, e.sealed]), R$2);
    }

    return toString$1(concat([e.type, e.iv, e.sealed]), R$2);
  }

  function q$3(e) {
    var n = fromString$1(e, R$2),
        t = n.slice(un, Ee$1),
        r = Ee$1;

    if (T$5(t) === O$2) {
      var c = r + H$4,
          l = c + F$3,
          h = n.slice(r, c),
          g = n.slice(c, l),
          P = n.slice(l);
      return {
        type: t,
        sealed: P,
        iv: g,
        senderPublicKey: h
      };
    }

    var o = r + F$3,
        i = n.slice(r, o),
        s = n.slice(o);
    return {
      type: t,
      sealed: s,
      iv: i
    };
  }

  function hn(e, n) {
    var t = q$3(e);
    return ge$2({
      type: T$5(t.type),
      senderPublicKey: _typeof$1(t.senderPublicKey) < "u" ? toString$1(t.senderPublicKey, a$2) : void 0,
      receiverPublicKey: n === null || n === void 0 ? void 0 : n.receiverPublicKey
    });
  }

  function ge$2(e) {
    var n = (e === null || e === void 0 ? void 0 : e.type) || L$4;

    if (n === O$2) {
      if (_typeof$1(e === null || e === void 0 ? void 0 : e.senderPublicKey) > "u") throw new Error("missing sender public key");
      if (_typeof$1(e === null || e === void 0 ? void 0 : e.receiverPublicKey) > "u") throw new Error("missing receiver public key");
    }

    return {
      type: n,
      senderPublicKey: e === null || e === void 0 ? void 0 : e.senderPublicKey,
      receiverPublicKey: e === null || e === void 0 ? void 0 : e.receiverPublicKey
    };
  }

  function Nn(e) {
    return e.type === O$2 && typeof e.senderPublicKey == "string" && typeof e.receiverPublicKey == "string";
  }

  var gn = Object.defineProperty,
      ve$1 = Object.getOwnPropertySymbols,
      vn = Object.prototype.hasOwnProperty,
      bn = Object.prototype.propertyIsEnumerable,
      be$1 = function be(e, n, t) {
    return n in e ? gn(e, n, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }) : e[n] = t;
  },
      Oe$1 = function Oe(e, n) {
    for (var t in n || (n = {})) {
      vn.call(n, t) && be$1(e, t, n[t]);
    }

    if (ve$1) {
      var _iterator = _createForOfIteratorHelper(ve$1(n)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var t = _step.value;
          bn.call(n, t) && be$1(e, t, n[t]);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return e;
  };

  var Se$1 = "ReactNative",
      S$1 = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown"
  },
      Pe$1 = "js";

  function B$1() {
    return (typeof process === "undefined" ? "undefined" : _typeof$1(process)) < "u" && _typeof$1(process.versions) < "u" && _typeof$1(process.versions.node) < "u";
  }

  function Te$1() {
    return !getDocument_1() && !!getNavigator_1() && navigator.product === Se$1;
  }

  function _e$1() {
    return !B$1() && !!getNavigator_1();
  }

  function z$4() {
    return Te$1() ? S$1.reactNative : B$1() ? S$1.node : _e$1() ? S$1.browser : S$1.unknown;
  }

  function Ue$1(e, n) {
    var t = queryString.parse(e);
    return t = Oe$1(Oe$1({}, t), n), e = queryString.stringify(t), e;
  }

  function In() {
    return getWindowMetadata_1() || {
      name: "",
      description: "",
      url: "",
      icons: [""]
    };
  }

  function Ae$1() {
    var e = detect$1();
    if (e === null) return "unknown";
    var n = e.os ? e.os.replace(" ", "").toLowerCase() : "unknown";
    return e.type === "browser" ? [n, e.name, e.version].join("-") : [n, e.version].join("-");
  }

  function Re$1() {
    var e;
    var n = z$4();
    return n === S$1.browser ? [n, ((e = getLocation_1()) == null ? void 0 : e.host) || "unknown"].join(":") : n;
  }

  function Ce$1(e, n, t) {
    var r = Ae$1(),
        o = Re$1();
    return [[e, n].join("-"), [Pe$1, t].join("-"), r, o].join("/");
  }

  function Tn(_ref) {
    var e = _ref.protocol,
        n = _ref.version,
        t = _ref.relayUrl,
        r = _ref.sdkVersion,
        o = _ref.auth,
        i = _ref.projectId;
    var s = t.split("?"),
        c = Ce$1(e, n, r),
        l = {
      auth: o,
      ua: c,
      projectId: i
    },
        h = Ue$1(s[1] || "", l);
    return s[0] + "?" + h;
  }

  function u$2(e, n) {
    return e.filter(function (t) {
      return n.includes(t);
    }).length === e.length;
  }

  function Rn(e) {
    return Object.fromEntries(e.entries());
  }

  function Cn(e) {
    return new Map(Object.entries(e));
  }

  function jn(e, n) {
    return cjs$5.fromMiliseconds((n || Date.now()) + cjs$5.toMiliseconds(e));
  }

  function xn(e) {
    return cjs$5.fromMiliseconds(Date.now()) >= cjs$5.toMiliseconds(e);
  }

  function Vn() {
    var e = cjs$5.toMiliseconds(cjs$5.FIVE_MINUTES);
    var n, t, r;
    return {
      resolve: function resolve(o) {
        r && n && (clearTimeout(r), n(o));
      },
      reject: function reject(o) {
        r && t && (clearTimeout(r), t(o));
      },
      done: function done() {
        return new Promise(function (o, i) {
          r = setTimeout(i, e), n = o, t = i;
        });
      }
    };
  }

  function Y$2(e, n) {
    if (typeof n == "string" && n.startsWith("".concat(e, ":"))) return n;

    if (e.toLowerCase() === "topic") {
      if (typeof n != "string") throw new Error('Value must be "string" for expirer target type: topic');
      return "topic:".concat(n);
    } else if (e.toLowerCase() === "id") {
      if (typeof n != "number") throw new Error('Value must be "number" for expirer target type: id');
      return "id:".concat(n);
    }

    throw new Error("Unknown expirer target type: ".concat(e));
  }

  function Mn(e) {
    return Y$2("topic", e);
  }

  function Kn(e) {
    return Y$2("id", e);
  }

  function kn(e) {
    var _e$split5 = e.split(":"),
        _e$split6 = _slicedToArray(_e$split5, 2),
        n = _e$split6[0],
        t = _e$split6[1],
        r = {
      id: void 0,
      topic: void 0
    };

    if (n === "topic" && typeof t == "string") r.topic = t;else if (n === "id" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error("Invalid target, expected id:number or topic:string, got ".concat(n, ":").concat(t));
    return r;
  }

  function Ln(e, n) {
    return "".concat(e).concat(n ? ":".concat(n) : "");
  }

  var je$1 = "irn";

  function Fn(e) {
    return (e === null || e === void 0 ? void 0 : e.relay) || {
      protocol: je$1
    };
  }

  function Hn(e) {
    var n = RELAY_JSONRPC[e];
    if (_typeof$1(n) > "u") throw new Error("Relay Protocol not supported: ".concat(e));
    return n;
  }

  var qn = Object.defineProperty,
      xe$1 = Object.getOwnPropertySymbols,
      Gn = Object.prototype.hasOwnProperty,
      Bn = Object.prototype.propertyIsEnumerable,
      Ve$1 = function Ve(e, n, t) {
    return n in e ? qn(e, n, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }) : e[n] = t;
  },
      zn = function zn(e, n) {
    for (var t in n || (n = {})) {
      Gn.call(n, t) && Ve$1(e, t, n[t]);
    }

    if (xe$1) {
      var _iterator2 = _createForOfIteratorHelper(xe$1(n)),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var t = _step2.value;
          Bn.call(n, t) && Ve$1(e, t, n[t]);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    return e;
  };

  function Me$1(e) {
    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "-";
    var t = {},
        r = "relay" + n;
    return Object.keys(e).forEach(function (o) {
      if (o.startsWith(r)) {
        var i = o.replace(r, ""),
            s = e[o];
        t[i] = s;
      }
    }), t;
  }

  function Yn(e) {
    var n = e.indexOf(":"),
        t = e.indexOf("?") !== -1 ? e.indexOf("?") : void 0,
        r = e.substring(0, n),
        o = e.substring(n + 1, t).split("@"),
        i = _typeof$1(t) < "u" ? e.substring(t) : "",
        s = queryString.parse(i);
    return {
      protocol: r,
      topic: o[0],
      version: parseInt(o[1], 10),
      symKey: s.symKey,
      relay: Me$1(s)
    };
  }

  function Ke$1(e) {
    var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "-";
    var t = "relay",
        r = {};
    return Object.keys(e).forEach(function (o) {
      var i = t + n + o;
      e[o] && (r[i] = e[o]);
    }), r;
  }

  function Jn(e) {
    return "".concat(e.protocol, ":").concat(e.topic, "@").concat(e.version, "?") + queryString.stringify(zn({
      symKey: e.symKey
    }, Ke$1(e.relay)));
  }

  function m$3(e) {
    var n = [];
    return e.forEach(function (t) {
      var _t$split = t.split(":"),
          _t$split2 = _slicedToArray(_t$split, 2),
          r = _t$split2[0],
          o = _t$split2[1];

      n.push("".concat(r, ":").concat(o));
    }), n;
  }

  function ke$1(e) {
    var n = [];
    return Object.values(e).forEach(function (t) {
      n.push.apply(n, _toConsumableArray(m$3(t.accounts))), t.extension && t.extension.forEach(function (r) {
        n.push.apply(n, _toConsumableArray(m$3(r.accounts)));
      });
    }), n;
  }

  function Le$1(e, n) {
    var t = [];
    return Object.values(e).forEach(function (r) {
      m$3(r.accounts).includes(n) && t.push.apply(t, _toConsumableArray(r.methods)), r.extension && r.extension.forEach(function (o) {
        m$3(o.accounts).includes(n) && t.push.apply(t, _toConsumableArray(o.methods));
      });
    }), t;
  }

  function Fe$1(e, n) {
    var t = [];
    return Object.values(e).forEach(function (r) {
      m$3(r.accounts).includes(n) && t.push.apply(t, _toConsumableArray(r.events)), r.extension && r.extension.forEach(function (o) {
        m$3(o.accounts).includes(n) && t.push.apply(t, _toConsumableArray(o.events));
      });
    }), t;
  }

  var Wn = {
    INVALID_METHOD: {
      message: "Invalid method.",
      code: 1001
    },
    INVALID_EVENT: {
      message: "Invalid event.",
      code: 1002
    },
    INVALID_UPDATE_REQUEST: {
      message: "Invalid update request.",
      code: 1003
    },
    INVALID_EXTEND_REQUEST: {
      message: "Invalid extend request.",
      code: 1004
    },
    INVALID_SESSION_SETTLE_REQUEST: {
      message: "Invalid session settle request.",
      code: 1005
    },
    UNAUTHORIZED_METHOD: {
      message: "Unauthorized method.",
      code: 3001
    },
    UNAUTHORIZED_EVENT: {
      message: "Unauthorized event.",
      code: 3002
    },
    UNAUTHORIZED_UPDATE_REQUEST: {
      message: "Unauthorized update request.",
      code: 3003
    },
    UNAUTHORIZED_EXTEND_REQUEST: {
      message: "Unauthorized extend request.",
      code: 3004
    },
    USER_REJECTED: {
      message: "User rejected.",
      code: 5e3
    },
    USER_REJECTED_CHAINS: {
      message: "User rejected chains.",
      code: 5001
    },
    USER_REJECTED_METHODS: {
      message: "User rejected methods.",
      code: 5002
    },
    USER_REJECTED_EVENTS: {
      message: "User rejected events.",
      code: 5003
    },
    UNSUPPORTED_CHAINS: {
      message: "Unsupported chains.",
      code: 5100
    },
    UNSUPPORTED_METHODS: {
      message: "Unsupported methods.",
      code: 5101
    },
    UNSUPPORTED_EVENTS: {
      message: "Unsupported events.",
      code: 5102
    },
    UNSUPPORTED_ACCOUNTS: {
      message: "Unsupported accounts.",
      code: 5103
    },
    UNSUPPORTED_NAMESPACE_KEY: {
      message: "Unsupported namespace key.",
      code: 5104
    },
    USER_DISCONNECTED: {
      message: "User disconnected.",
      code: 6e3
    },
    SESSION_SETTLEMENT_FAILED: {
      message: "Session settlement failed.",
      code: 7e3
    }
  },
      Qn = {
    NOT_INITIALIZED: {
      message: "Not initialized.",
      code: 1
    },
    NO_MATCHING_KEY: {
      message: "No matching key.",
      code: 2
    },
    RESTORE_WILL_OVERRIDE: {
      message: "Restore will override.",
      code: 3
    },
    RESUBSCRIBED: {
      message: "Resubscribed.",
      code: 4
    },
    MISSING_OR_INVALID: {
      message: "Missing or invalid.",
      code: 5
    },
    EXPIRED: {
      message: "Expired.",
      code: 6
    },
    UNKNOWN_TYPE: {
      message: "Unknown type.",
      code: 7
    },
    MISMATCHED_TOPIC: {
      message: "Mismatched topic.",
      code: 8
    },
    NON_CONFORMING_NAMESPACES: {
      message: "Non conforming namespaces.",
      code: 9
    }
  };

  function y$2(e, n) {
    var _Qn$e = Qn[e],
        t = _Qn$e.message,
        r = _Qn$e.code;
    return {
      message: n ? "".concat(t, " ").concat(n) : t,
      code: r
    };
  }

  function N$2(e, n) {
    var _Wn$e = Wn[e],
        t = _Wn$e.message,
        r = _Wn$e.code;
    return {
      message: n ? "".concat(t, " ").concat(n) : t,
      code: r
    };
  }

  function I$3(e, n) {
    return Array.isArray(e) ? _typeof$1(n) < "u" && e.length ? e.every(n) : !0 : !1;
  }

  function J$2(e) {
    return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;
  }

  function E$3(e) {
    return _typeof$1(e) > "u";
  }

  function d$4(e, n) {
    return n && E$3(e) ? !0 : typeof e == "string" && Boolean(e.trim().length);
  }

  function W$2(e, n) {
    return n && E$3(e) ? !0 : typeof e == "number" && !isNaN(e);
  }

  function Zn(e, n) {
    var t = n.requiredNamespaces,
        r = Object.keys(e.namespaces),
        o = Object.keys(t);
    var i = !0;
    return u$2(o, r) ? (r.forEach(function (s) {
      var _e$namespaces$s = e.namespaces[s],
          c = _e$namespaces$s.accounts,
          l = _e$namespaces$s.methods,
          h = _e$namespaces$s.events,
          g = _e$namespaces$s.extension,
          P = m$3(c),
          v = t[s];
      (!u$2(v.chains, P) || !u$2(v.methods, l) || !u$2(v.events, h)) && (i = !1), i && g && g.forEach(function (_) {
        var b;
        var j = _.accounts,
            ze = _.methods,
            Ye = _.events,
            Je = m$3(j);
        (b = v.extension) != null && b.find(function (x) {
          return u$2(x.chains, Je) && u$2(x.methods, ze) && u$2(x.events, Ye);
        }) || (i = !1);
      });
    }), i) : !1;
  }

  function D$3(e) {
    return d$4(e, !1) && e.includes(":") ? e.split(":").length === 2 : !1;
  }

  function He$1(e) {
    if (d$4(e, !1) && e.includes(":")) {
      var n = e.split(":");

      if (n.length === 3) {
        var t = n[0] + ":" + n[1];
        return !!n[2] && D$3(t);
      }
    }

    return !1;
  }

  function Xn(e) {
    if (d$4(e, !1)) try {
      return _typeof$1(new URL(e)) < "u";
    } catch (_unused) {
      return !1;
    }
    return !1;
  }

  function et$1(e) {
    var n;
    return (n = e === null || e === void 0 ? void 0 : e.proposer) == null ? void 0 : n.publicKey;
  }

  function nt$2(e) {
    return e === null || e === void 0 ? void 0 : e.topic;
  }

  function tt$1(e, n) {
    var t = null;
    return d$4(e === null || e === void 0 ? void 0 : e.publicKey, !1) || (t = y$2("MISSING_OR_INVALID", "".concat(n, " controller public key should be a string"))), t;
  }

  function $$4(e, n) {
    var t = null;
    return E$3(e === null || e === void 0 ? void 0 : e.extension) || (!I$3(e.extension) || !e.extension.length) && (t = y$2("MISSING_OR_INVALID", "".concat(n, " extension should be an array of namespaces, or omitted"))), t;
  }

  function Q$2(e) {
    var n = !0;
    return I$3(e) ? e.length && (n = e.every(function (t) {
      return d$4(t, !1);
    })) : n = !1, n;
  }

  function Z$2(e, n, t) {
    var r = null;
    return I$3(n) ? n.forEach(function (o) {
      r || (!D$3(o) || !o.includes(e)) && (r = N$2("UNSUPPORTED_CHAINS", "".concat(t, ", chain ").concat(o, " should be a string and conform to \"namespace:chainId\" format")));
    }) : r = N$2("UNSUPPORTED_CHAINS", "".concat(t, ", chains ").concat(n, " should be an array of strings conforming to \"namespace:chainId\" format")), r;
  }

  function qe$1(e, n) {
    var t = null;
    return Object.entries(e).forEach(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          r = _ref3[0],
          o = _ref3[1];

      if (t) return;
      var i = Z$2(r, o === null || o === void 0 ? void 0 : o.chains, "".concat(n, " requiredNamespace")),
          s = $$4(o, n);
      i ? t = i : s ? t = s : o.extension && o.extension.forEach(function (c) {
        if (t) return;
        var l = Z$2(r, c.chains, "".concat(n, " extension"));
        l && (t = l);
      });
    }), t;
  }

  function X$3(e, n) {
    var t = null;
    return I$3(e) ? e.forEach(function (r) {
      t || He$1(r) || (t = N$2("UNSUPPORTED_ACCOUNTS", "".concat(n, ", account ").concat(r, " should be a string and conform to \"namespace:chainId:address\" format")));
    }) : t = N$2("UNSUPPORTED_ACCOUNTS", "".concat(n, ", accounts should be an array of strings conforming to \"namespace:chainId:address\" format")), t;
  }

  function Ge$1(e, n) {
    var t = null;
    return Object.values(e).forEach(function (r) {
      if (t) return;
      var o = X$3(r === null || r === void 0 ? void 0 : r.accounts, "".concat(n, " namespace")),
          i = $$4(r, n);
      o ? t = o : i ? t = i : r.extension && r.extension.forEach(function (s) {
        if (t) return;
        var c = X$3(s.accounts, "".concat(n, " extension"));
        c && (t = c);
      });
    }), t;
  }

  function ee(e, n) {
    var t = null;
    return Q$2(e === null || e === void 0 ? void 0 : e.methods) ? Q$2(e === null || e === void 0 ? void 0 : e.events) || (t = N$2("UNSUPPORTED_EVENTS", "".concat(n, ", events should be an array of strings or empty array for no events"))) : t = N$2("UNSUPPORTED_METHODS", "".concat(n, ", methods should be an array of strings or empty array for no methods")), t;
  }

  function ne$1(e, n) {
    var t = null;
    return Object.values(e).forEach(function (r) {
      if (t) return;
      var o = ee(r, "".concat(n, ", namespace")),
          i = $$4(r, n);
      o ? t = o : i ? t = i : r.extension && r.extension.forEach(function (s) {
        if (t) return;
        var c = ee(s, "".concat(n, ", extension"));
        c && (t = c);
      });
    }), t;
  }

  function rt$2(e, n) {
    var t = null;

    if (e && J$2(e)) {
      var r = ne$1(e, n);
      r && (t = r);
      var o = qe$1(e, n);
      o && (t = o);
    } else t = y$2("MISSING_OR_INVALID", "".concat(n, ", requiredNamespaces should be an object with data"));

    return t;
  }

  function ot$1(e, n) {
    var t = null;

    if (e && J$2(e)) {
      var r = ne$1(e, n);
      r && (t = r);
      var o = Ge$1(e, n);
      o && (t = o);
    } else t = y$2("MISSING_OR_INVALID", "".concat(n, ", namespaces should be an object with data"));

    return t;
  }

  function Be$1(e) {
    return d$4(e.protocol, !0);
  }

  function st$2(e, n) {
    var t = !1;
    return n && !e ? t = !0 : e && I$3(e) && e.length && e.forEach(function (r) {
      t = Be$1(r);
    }), t;
  }

  function it$2(e) {
    return typeof e == "number";
  }

  function ct$1(e) {
    return _typeof$1(e) < "u" && _typeof$1(e) !== null;
  }

  function at$1(e) {
    return !(!e || _typeof$1(e) != "object" || !e.code || !W$2(e.code, !1) || !e.message || !d$4(e.message, !1));
  }

  function ut(e) {
    return !(E$3(e) || !d$4(e.method, !1));
  }

  function dt$1(e) {
    return !(E$3(e) || E$3(e.result) && E$3(e.error) || !W$2(e.id, !1) || !d$4(e.jsonrpc, !1));
  }

  function lt$1(e) {
    return !(E$3(e) || !d$4(e.name, !1));
  }

  function ft(e, n) {
    return !(!D$3(n) || !ke$1(e).includes(n));
  }

  function pt$2(e, n, t) {
    return d$4(t, !1) ? Le$1(e, n).includes(t) : !1;
  }

  function mt(e, n, t) {
    return d$4(t, !1) ? Fe$1(e, n).includes(t) : !1;
  }

  function yt(e, n, t) {
    var r = null;
    var o = Object.keys(e),
        i = Object.keys(n);
    return u$2(o, i) ? o.forEach(function (s) {
      var c;
      if (r) return;
      var l = e[s].chains,
          h = m$3(n[s].accounts);
      u$2(l, h) ? u$2(e[s].methods, n[s].methods) ? u$2(e[s].events, n[s].events) ? e[s].extension && !n[s].extension ? r = y$2("NON_CONFORMING_NAMESPACES", "".concat(t, " namespaces extension doesn't satisfy requiredNamespaces extension for ").concat(s)) : e[s].extension && n[s].extension && ((c = e[s].extension) == null || c.forEach(function (_ref4) {
        var g = _ref4.methods,
            P = _ref4.events,
            v = _ref4.chains;

        var _;

        r || (_ = n[s].extension) != null && _.find(function (b) {
          var j = m$3(b.accounts);
          return u$2(v, j) && u$2(P, b.events) && u$2(g, b.methods);
        }) || (r = y$2("NON_CONFORMING_NAMESPACES", "".concat(t, " namespaces extension doesn't satisfy requiredNamespaces extension for ").concat(s)));
      })) : r = y$2("NON_CONFORMING_NAMESPACES", "".concat(t, " namespaces events don't satisfy requiredNamespaces events for ").concat(s)) : r = y$2("NON_CONFORMING_NAMESPACES", "".concat(t, " namespaces methods don't satisfy requiredNamespaces methods for ").concat(s)) : r = y$2("NON_CONFORMING_NAMESPACES", "".concat(t, " namespaces accounts don't satisfy requiredNamespaces chains for ").concat(s));
    }) : r = y$2("NON_CONFORMING_NAMESPACES", "".concat(t, " namespaces keys don't satisfy requiredNamespaces")), r;
  }

  var _STANDARD_ERROR_MAP;

  var PARSE_ERROR = "PARSE_ERROR";
  var INVALID_REQUEST = "INVALID_REQUEST";
  var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
  var INVALID_PARAMS = "INVALID_PARAMS";
  var INTERNAL_ERROR = "INTERNAL_ERROR";
  var SERVER_ERROR = "SERVER_ERROR";
  var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
  var STANDARD_ERROR_MAP = (_STANDARD_ERROR_MAP = {}, _defineProperty(_STANDARD_ERROR_MAP, PARSE_ERROR, {
    code: -32700,
    message: "Parse error"
  }), _defineProperty(_STANDARD_ERROR_MAP, INVALID_REQUEST, {
    code: -32600,
    message: "Invalid Request"
  }), _defineProperty(_STANDARD_ERROR_MAP, METHOD_NOT_FOUND, {
    code: -32601,
    message: "Method not found"
  }), _defineProperty(_STANDARD_ERROR_MAP, INVALID_PARAMS, {
    code: -32602,
    message: "Invalid params"
  }), _defineProperty(_STANDARD_ERROR_MAP, INTERNAL_ERROR, {
    code: -32603,
    message: "Internal error"
  }), _defineProperty(_STANDARD_ERROR_MAP, SERVER_ERROR, {
    code: -32000,
    message: "Server error"
  }), _STANDARD_ERROR_MAP);
  var DEFAULT_ERROR = SERVER_ERROR;

  function isReservedErrorCode(code) {
    return RESERVED_ERROR_CODES.includes(code);
  }
  function getError(type) {
    if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
      return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }

    return STANDARD_ERROR_MAP[type];
  }
  function getErrorByCode(code) {
    var match = Object.values(STANDARD_ERROR_MAP).find(function (e) {
      return e.code === code;
    });

    if (!match) {
      return STANDARD_ERROR_MAP[DEFAULT_ERROR];
    }

    return match;
  }
  function parseConnectionError(e, url, type) {
    return e.message.includes("getaddrinfo ENOTFOUND") || e.message.includes("connect ECONNREFUSED") ? new Error("Unavailable ".concat(type, " RPC url at ").concat(url)) : e;
  }

  var cjs$1 = {};

  var crypto$1 = {};

  Object.defineProperty(crypto$1, "__esModule", {
    value: true
  });
  crypto$1.isBrowserCryptoAvailable = crypto$1.getSubtleCrypto = crypto$1.getBrowerCrypto = void 0;

  function getBrowerCrypto() {
    return (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.crypto) || (commonjsGlobal === null || commonjsGlobal === void 0 ? void 0 : commonjsGlobal.msCrypto) || {};
  }

  crypto$1.getBrowerCrypto = getBrowerCrypto;

  function getSubtleCrypto() {
    var browserCrypto = getBrowerCrypto();
    return browserCrypto.subtle || browserCrypto.webkitSubtle;
  }

  crypto$1.getSubtleCrypto = getSubtleCrypto;

  function isBrowserCryptoAvailable() {
    return !!getBrowerCrypto() && !!getSubtleCrypto();
  }

  crypto$1.isBrowserCryptoAvailable = isBrowserCryptoAvailable;

  var env = {};

  Object.defineProperty(env, "__esModule", {
    value: true
  });
  env.isBrowser = env.isNode = env.isReactNative = void 0;

  function isReactNative() {
    return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
  }

  env.isReactNative = isReactNative;

  function isNode$2() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
  }

  env.isNode = isNode$2;

  function isBrowser$1() {
    return !isReactNative() && !isNode$2();
  }

  env.isBrowser = isBrowser$1;

  (function (exports) {

    var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, {
        enumerable: true,
        get: function get() {
          return m[k];
        }
      });
    } : function (o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
    });

    var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
      for (var p in m) {
        if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
      }
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    __exportStar(crypto$1, exports);

    __exportStar(env, exports);
  })(cjs$1);

  function payloadId() {
    var date = Date.now() * Math.pow(10, 3);
    var extra = Math.floor(Math.random() * Math.pow(10, 3));
    return date + extra;
  }
  function formatJsonRpcRequest(method, params, id) {
    return {
      id: id || payloadId(),
      jsonrpc: "2.0",
      method: method,
      params: params
    };
  }
  function formatJsonRpcResult(id, result) {
    return {
      id: id,
      jsonrpc: "2.0",
      result: result
    };
  }
  function formatJsonRpcError(id, error, data) {
    return {
      id: id,
      jsonrpc: "2.0",
      error: formatErrorMessage(error, data)
    };
  }
  function formatErrorMessage(error, data) {
    if (typeof error === "undefined") {
      return getError(INTERNAL_ERROR);
    }

    if (typeof error === "string") {
      error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), {
        message: error
      });
    }

    if (typeof data !== "undefined") {
      error.data = data;
    }

    if (isReservedErrorCode(error.code)) {
      error = getErrorByCode(error.code);
    }

    return error;
  }

  var IEvents = /*#__PURE__*/_createClass(function IEvents() {
    _classCallCheck(this, IEvents);
  });

  var IBaseJsonRpcProvider = /*#__PURE__*/function (_IEvents2) {
    _inherits(IBaseJsonRpcProvider, _IEvents2);

    var _super2 = _createSuper(IBaseJsonRpcProvider);

    function IBaseJsonRpcProvider() {
      _classCallCheck(this, IBaseJsonRpcProvider);

      return _super2.call(this);
    }

    return _createClass(IBaseJsonRpcProvider);
  }(IEvents);
  var IJsonRpcProvider = /*#__PURE__*/function (_IBaseJsonRpcProvider) {
    _inherits(IJsonRpcProvider, _IBaseJsonRpcProvider);

    var _super3 = _createSuper(IJsonRpcProvider);

    function IJsonRpcProvider(connection) {
      _classCallCheck(this, IJsonRpcProvider);

      return _super3.call(this);
    }

    return _createClass(IJsonRpcProvider);
  }(IBaseJsonRpcProvider);

  var WS_REGEX = "^wss?:";

  function getUrlProtocol(url) {
    var matches = url.match(new RegExp(/^\w+:/, "gi"));
    if (!matches || !matches.length) return;
    return matches[0];
  }

  function matchRegexProtocol(url, regex) {
    var protocol = getUrlProtocol(url);
    if (typeof protocol === "undefined") return false;
    return new RegExp(regex).test(protocol);
  }
  function isWsUrl(url) {
    return matchRegexProtocol(url, WS_REGEX);
  }
  function isLocalhostUrl(url) {
    return new RegExp("wss?://localhost(:d{2,5})?").test(url);
  }

  function isJsonRpcPayload(payload) {
    return _typeof$1(payload) === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
  }
  function isJsonRpcRequest(payload) {
    return isJsonRpcPayload(payload) && "method" in payload;
  }
  function isJsonRpcResponse(payload) {
    return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
  }
  function isJsonRpcResult(payload) {
    return "result" in payload;
  }
  function isJsonRpcError(payload) {
    return "error" in payload;
  }

  var JsonRpcProvider = /*#__PURE__*/function (_IJsonRpcProvider) {
    _inherits(JsonRpcProvider, _IJsonRpcProvider);

    var _super = _createSuper(JsonRpcProvider);

    function JsonRpcProvider(connection) {
      var _this;

      _classCallCheck(this, JsonRpcProvider);

      _this = _super.call(this, connection);
      _this.events = new events.exports.EventEmitter();
      _this.hasRegisteredEventListeners = false;
      _this.connection = _this.setConnection(connection);

      if (_this.connection.connected) {
        _this.registerEventListeners();
      }

      return _this;
    }

    _createClass(JsonRpcProvider, [{
      key: "connect",
      value: function () {
        var _connect = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var connection,
              _args = arguments;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  connection = _args.length > 0 && _args[0] !== undefined ? _args[0] : this.connection;
                  _context.next = 3;
                  return this.open(connection);

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function connect() {
          return _connect.apply(this, arguments);
        }

        return connect;
      }()
    }, {
      key: "disconnect",
      value: function () {
        var _disconnect = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return this.close();

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function disconnect() {
          return _disconnect.apply(this, arguments);
        }

        return disconnect;
      }()
    }, {
      key: "on",
      value: function on(event, listener) {
        this.events.on(event, listener);
      }
    }, {
      key: "once",
      value: function once(event, listener) {
        this.events.once(event, listener);
      }
    }, {
      key: "off",
      value: function off(event, listener) {
        this.events.off(event, listener);
      }
    }, {
      key: "removeListener",
      value: function removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
    }, {
      key: "request",
      value: function () {
        var _request2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(_request, context) {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", this.requestStrict(formatJsonRpcRequest(_request.method, _request.params || []), context));

                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function request(_x, _x2) {
          return _request2.apply(this, arguments);
        }

        return request;
      }()
    }, {
      key: "requestStrict",
      value: function () {
        var _requestStrict = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(request, context) {
          var _this2 = this;

          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  return _context5.abrupt("return", new Promise( /*#__PURE__*/function () {
                    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(resolve, reject) {
                      return regenerator.wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              if (_this2.connection.connected) {
                                _context4.next = 9;
                                break;
                              }

                              _context4.prev = 1;
                              _context4.next = 4;
                              return _this2.open();

                            case 4:
                              _context4.next = 9;
                              break;

                            case 6:
                              _context4.prev = 6;
                              _context4.t0 = _context4["catch"](1);
                              reject(_context4.t0);

                            case 9:
                              _this2.events.on("".concat(request.id), function (response) {
                                if (isJsonRpcError(response)) {
                                  reject(response.error);
                                } else {
                                  resolve(response.result);
                                }
                              });

                              _context4.prev = 10;
                              _context4.next = 13;
                              return _this2.connection.send(request, context);

                            case 13:
                              _context4.next = 18;
                              break;

                            case 15:
                              _context4.prev = 15;
                              _context4.t1 = _context4["catch"](10);
                              reject(_context4.t1);

                            case 18:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4, null, [[1, 6], [10, 15]]);
                    }));

                    return function (_x5, _x6) {
                      return _ref.apply(this, arguments);
                    };
                  }()));

                case 1:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        function requestStrict(_x3, _x4) {
          return _requestStrict.apply(this, arguments);
        }

        return requestStrict;
      }()
    }, {
      key: "setConnection",
      value: function setConnection() {
        var connection = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.connection;
        return connection;
      }
    }, {
      key: "onPayload",
      value: function onPayload(payload) {
        this.events.emit("payload", payload);

        if (isJsonRpcResponse(payload)) {
          this.events.emit("".concat(payload.id), payload);
        } else {
          this.events.emit("message", {
            type: payload.method,
            data: payload.params
          });
        }
      }
    }, {
      key: "open",
      value: function () {
        var _open = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
          var connection,
              _args6 = arguments;
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  connection = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : this.connection;

                  if (!(this.connection === connection && this.connection.connected)) {
                    _context6.next = 3;
                    break;
                  }

                  return _context6.abrupt("return");

                case 3:
                  if (this.connection.connected) this.close();

                  if (!(typeof connection === "string")) {
                    _context6.next = 8;
                    break;
                  }

                  _context6.next = 7;
                  return this.connection.open(connection);

                case 7:
                  connection = this.connection;

                case 8:
                  this.connection = this.setConnection(connection);
                  _context6.next = 11;
                  return this.connection.open();

                case 11:
                  this.registerEventListeners();
                  this.events.emit("connect");

                case 13:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function open() {
          return _open.apply(this, arguments);
        }

        return open;
      }()
    }, {
      key: "close",
      value: function () {
        var _close = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return this.connection.close();

                case 2:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function close() {
          return _close.apply(this, arguments);
        }

        return close;
      }()
    }, {
      key: "registerEventListeners",
      value: function registerEventListeners() {
        var _this3 = this;

        if (this.hasRegisteredEventListeners) return;
        this.connection.on("payload", function (payload) {
          return _this3.onPayload(payload);
        });
        this.connection.on("close", function () {
          return _this3.events.emit("disconnect");
        });
        this.connection.on("error", function (error) {
          return _this3.events.emit("error", error);
        });
        this.hasRegisteredEventListeners = true;
      }
    }]);

    return JsonRpcProvider;
  }(IJsonRpcProvider);

  var EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;
  var WS = typeof global.WebSocket !== "undefined" ? global.WebSocket : require("ws");
  var WsConnection = /*#__PURE__*/function () {
    function WsConnection(url) {
      _classCallCheck(this, WsConnection);

      this.url = url;
      this.events = new events.exports.EventEmitter();
      this.registering = false;

      if (!isWsUrl(url)) {
        throw new Error("Provided URL is not compatible with WebSocket connection: ".concat(url));
      }

      this.url = url;
    }

    _createClass(WsConnection, [{
      key: "connected",
      get: function get() {
        return typeof this.socket !== "undefined";
      }
    }, {
      key: "connecting",
      get: function get() {
        return this.registering;
      }
    }, {
      key: "on",
      value: function on(event, listener) {
        this.events.on(event, listener);
      }
    }, {
      key: "once",
      value: function once(event, listener) {
        this.events.once(event, listener);
      }
    }, {
      key: "off",
      value: function off(event, listener) {
        this.events.off(event, listener);
      }
    }, {
      key: "removeListener",
      value: function removeListener(event, listener) {
        this.events.removeListener(event, listener);
      }
    }, {
      key: "open",
      value: function () {
        var _open = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var url,
              _args = arguments;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  url = _args.length > 0 && _args[0] !== undefined ? _args[0] : this.url;
                  _context.next = 3;
                  return this.register(url);

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function open() {
          return _open.apply(this, arguments);
        }

        return open;
      }()
    }, {
      key: "close",
      value: function () {
        var _close = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!(typeof this.socket === "undefined")) {
                    _context2.next = 2;
                    break;
                  }

                  throw new Error("Connection already closed");

                case 2:
                  this.socket.close();
                  this.onClose();

                case 4:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function close() {
          return _close.apply(this, arguments);
        }

        return close;
      }()
    }, {
      key: "send",
      value: function () {
        var _send = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(payload, context) {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!(typeof this.socket === "undefined")) {
                    _context3.next = 4;
                    break;
                  }

                  _context3.next = 3;
                  return this.register();

                case 3:
                  this.socket = _context3.sent;

                case 4:
                  try {
                    this.socket.send(safeJsonStringify$1(payload));
                  } catch (e) {
                    this.onError(payload.id, e);
                  }

                case 5:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function send(_x, _x2) {
          return _send.apply(this, arguments);
        }

        return send;
      }()
    }, {
      key: "register",
      value: function register() {
        var _this = this;

        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.url;

        if (!isWsUrl(url)) {
          throw new Error("Provided URL is not compatible with WebSocket connection: ".concat(url));
        }

        if (this.registering) {
          var currentMaxListeners = this.events.getMaxListeners();

          if (this.events.listenerCount("register_error") >= currentMaxListeners || this.events.listenerCount("open") >= currentMaxListeners) {
            this.events.setMaxListeners(currentMaxListeners + 1);
          }

          return new Promise(function (resolve, reject) {
            _this.events.once("register_error", function (error) {
              _this.resetMaxListeners();

              reject(error);
            });

            _this.events.once("open", function () {
              _this.resetMaxListeners();

              if (typeof _this.socket === "undefined") {
                return reject(new Error("WebSocket connection is missing or invalid"));
              }

              resolve(_this.socket);
            });
          });
        }

        this.url = url;
        this.registering = true;
        return new Promise(function (resolve, reject) {
          var opts = !cjs$1.isReactNative() ? {
            rejectUnauthorized: !isLocalhostUrl(url)
          } : undefined;
          var socket = new WS(url, [], opts);

          socket.onopen = function () {
            _this.onOpen(socket);

            resolve(socket);
          };

          socket.onerror = function (event) {
            var error = _this.parseError(event.error);

            _this.events.emit("register_error", error);

            _this.onClose();

            reject(error);
          };
        });
      }
    }, {
      key: "onOpen",
      value: function onOpen(socket) {
        var _this2 = this;

        socket.onmessage = function (event) {
          return _this2.onPayload(event);
        };

        socket.onclose = function () {
          return _this2.onClose();
        };

        socket.onerror = function (event) {
          var error = _this2.parseError(event.error);

          _this2.events.emit("error", error);
        };

        this.socket = socket;
        this.registering = false;
        this.events.emit("open");
      }
    }, {
      key: "onClose",
      value: function onClose() {
        this.socket = undefined;
        this.registering = false;
        this.events.emit("close");
      }
    }, {
      key: "onPayload",
      value: function onPayload(e) {
        if (typeof e.data === "undefined") return;
        var payload = typeof e.data === "string" ? safeJsonParse$1(e.data) : e.data;
        this.events.emit("payload", payload);
      }
    }, {
      key: "onError",
      value: function onError(id, e) {
        var error = this.parseError(e);
        var message = error.message || error.toString();
        var payload = formatJsonRpcError(id, message);
        this.events.emit("payload", payload);
      }
    }, {
      key: "parseError",
      value: function parseError(e) {
        var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.url;
        return parseConnectionError(e, url, "WS");
      }
    }, {
      key: "resetMaxListeners",
      value: function resetMaxListeners() {
        if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {
          this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);
        }
      }
    }]);

    return WsConnection;
  }();

  var lodash_isequal = {exports: {}};

  (function (module, exports) {
    /** Used as the size to enable large array optimizations. */
    var LARGE_ARRAY_SIZE = 200;
    /** Used to stand-in for `undefined` hash values. */

    var HASH_UNDEFINED = '__lodash_hash_undefined__';
    /** Used to compose bitmasks for value comparisons. */

    var COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;
    /** Used as references for various `Number` constants. */

    var MAX_SAFE_INTEGER = 9007199254740991;
    /** `Object#toString` result references. */

    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        asyncTag = '[object AsyncFunction]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        nullTag = '[object Null]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        proxyTag = '[object Proxy]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        undefinedTag = '[object Undefined]',
        weakMapTag = '[object WeakMap]';
    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';
    /**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */

    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    /** Used to detect host constructors (Safari). */

    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    /** Used to detect unsigned integer values. */

    var reIsUint = /^(?:0|[1-9]\d*)$/;
    /** Used to identify `toStringTag` values of typed arrays. */

    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    /** Detect free variable `global` from Node.js. */

    var freeGlobal = _typeof$1(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    /** Detect free variable `self`. */

    var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof$1(self)) == 'object' && self && self.Object === Object && self;
    /** Used as a reference to the global object. */

    var root = freeGlobal || freeSelf || Function('return this')();
    /** Detect free variable `exports`. */

    var freeExports = exports && !exports.nodeType && exports;
    /** Detect free variable `module`. */

    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports`. */

    var moduleExports = freeModule && freeModule.exports === freeExports;
    /** Detect free variable `process` from Node.js. */

    var freeProcess = moduleExports && freeGlobal.process;
    /** Used to access faster Node.js helpers. */

    var nodeUtil = function () {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();
    /* Node.js helper references. */


    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    /**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */

    function arrayFilter(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];

        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }

      return result;
    }
    /**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */


    function arrayPush(array, values) {
      var index = -1,
          length = values.length,
          offset = array.length;

      while (++index < length) {
        array[offset + index] = values[index];
      }

      return array;
    }
    /**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */


    function arraySome(array, predicate) {
      var index = -1,
          length = array == null ? 0 : array.length;

      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }

      return false;
    }
    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */


    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }

      return result;
    }
    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */


    function baseUnary(func) {
      return function (value) {
        return func(value);
      };
    }
    /**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function cacheHas(cache, key) {
      return cache.has(key);
    }
    /**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */


    function getValue(object, key) {
      return object == null ? undefined : object[key];
    }
    /**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */


    function mapToArray(map) {
      var index = -1,
          result = Array(map.size);
      map.forEach(function (value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */


    function overArg(func, transform) {
      return function (arg) {
        return func(transform(arg));
      };
    }
    /**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */


    function setToArray(set) {
      var index = -1,
          result = Array(set.size);
      set.forEach(function (value) {
        result[++index] = value;
      });
      return result;
    }
    /** Used for built-in method references. */


    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;
    /** Used to detect overreaching core-js shims. */

    var coreJsData = root['__core-js_shared__'];
    /** Used to resolve the decompiled source of functions. */

    var funcToString = funcProto.toString;
    /** Used to check objects for own properties. */

    var hasOwnProperty = objectProto.hasOwnProperty;
    /** Used to detect methods masquerading as native. */

    var maskSrcKey = function () {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? 'Symbol(src)_1.' + uid : '';
    }();
    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */


    var nativeObjectToString = objectProto.toString;
    /** Used to detect if a method is native. */

    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
    /** Built-in value references. */

    var Buffer = moduleExports ? root.Buffer : undefined,
        _Symbol = root.Symbol,
        Uint8Array = root.Uint8Array,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;
    /* Built-in method references for those with the same name as other `lodash` methods. */

    var nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeKeys = overArg(Object.keys, Object);
    /* Built-in method references that are verified to be native. */

    var DataView = getNative(root, 'DataView'),
        Map = getNative(root, 'Map'),
        Promise = getNative(root, 'Promise'),
        Set = getNative(root, 'Set'),
        WeakMap = getNative(root, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');
    /** Used to detect maps, sets, and weakmaps. */

    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);
    /** Used to convert symbols to primitives and strings. */

    var symbolProto = _Symbol ? _Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */


    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function hashGet(key) {
      var data = this.__data__;

      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }

      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }
    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
    }
    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */


    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
      return this;
    } // Add methods to `Hash`.


    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */


    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }

      var lastIndex = data.length - 1;

      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }

      --this.size;
      return true;
    }
    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);
      return index < 0 ? undefined : data[index][1];
    }
    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */


    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }

      return this;
    } // Add methods to `ListCache`.


    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;
      this.clear();

      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */


    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash(),
        'map': new (Map || ListCache)(),
        'string': new Hash()
      };
    }
    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */


    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;
      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    } // Add methods to `MapCache`.


    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */

    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();

      while (++index < length) {
        this.add(values[index]);
      }
    }
    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */


    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);

      return this;
    }
    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */


    function setCacheHas(value) {
      return this.__data__.has(value);
    } // Add methods to `SetCache`.


    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */

    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }
    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */


    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */


    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);
      this.size = data.size;
      return result;
    }
    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */


    function stackGet(key) {
      return this.__data__.get(key);
    }
    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */


    function stackHas(key) {
      return this.__data__.has(key);
    }
    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */


    function stackSet(key, value) {
      var data = this.__data__;

      if (data instanceof ListCache) {
        var pairs = data.__data__;

        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }

        data = this.__data__ = new MapCache(pairs);
      }

      data.set(key, value);
      this.size = data.size;
      return this;
    } // Add methods to `Stack`.


    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */

    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && ( // Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == 'offset' || key == 'parent') || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */


    function assocIndexOf(array, key) {
      var length = array.length;

      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }

      return -1;
    }
    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */


    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }

      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */


    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */


    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }

      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }

      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }

        objIsArr = true;
        objIsObj = false;
      }

      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }

      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }

      if (!isSameTag) {
        return false;
      }

      stack || (stack = new Stack());
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }
    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */


    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }

      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */


    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */


    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }

      var result = [];

      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }

      return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */


    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      } // Assume cyclic values are equal.


      var stacked = stack.get(array);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var index = -1,
          result = true,
          seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
      stack.set(array, other);
      stack.set(other, array); // Ignore non-index properties.

      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }

        if (compared !== undefined) {
          if (compared) {
            continue;
          }

          result = false;
          break;
        } // Recursively compare arrays (susceptible to call stack limits).


        if (seen) {
          if (!arraySome(other, function (othValue, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }

      stack['delete'](array);
      stack['delete'](other);
      return result;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }

          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }

          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == other + '';

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          } // Assume cyclic values are equal.


          var stacked = stack.get(object);

          if (stacked) {
            return stacked == other;
          }

          bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }

      }

      return false;
    }
    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */


    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }

      var index = objLength;

      while (index--) {
        var key = objProps[index];

        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      } // Assume cyclic values are equal.


      var stacked = stack.get(object);

      if (stacked && stack.get(other)) {
        return stacked == other;
      }

      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;

      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        } // Recursively compare objects (susceptible to call stack limits).


        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }

        skipCtor || (skipCtor = key == 'constructor');
      }

      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }

      stack['delete'](object);
      stack['delete'](other);
      return result;
    }
    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */


    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */


    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
    }
    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */


    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }
    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */


    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);

      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }

      return result;
    }
    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */


    var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
      if (object == null) {
        return [];
      }

      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function (symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };
    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */

    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function getTag(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;

            case mapCtorString:
              return mapTag;

            case promiseCtorString:
              return promiseTag;

            case setCtorString:
              return setTag;

            case weakMapCtorString:
              return weakMapTag;
          }
        }

        return result;
      };
    }
    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */


    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
    }
    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */


    function isKeyable(value) {
      var type = _typeof$1(value);

      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
    }
    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */


    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */


    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
      return value === proto;
    }
    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */


    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */


    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}

        try {
          return func + '';
        } catch (e) {}
      }

      return '';
    }
    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */


    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */


    var isArguments = baseIsArguments(function () {
      return arguments;
    }()) ? baseIsArguments : function (value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
    };
    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */

    var isArray = Array.isArray;
    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */

    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */


    var isBuffer = nativeIsBuffer || stubFalse;
    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */

    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */


    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      } // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.


      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */


    function isLength(value) {
      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */


    function isObject(value) {
      var type = _typeof$1(value);

      return value != null && (type == 'object' || type == 'function');
    }
    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */


    function isObjectLike(value) {
      return value != null && _typeof$1(value) == 'object';
    }
    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */


    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */

    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */


    function stubArray() {
      return [];
    }
    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */


    function stubFalse() {
      return false;
    }

    module.exports = isEqual;
  })(lodash_isequal, lodash_isequal.exports);

  var Bt = lodash_isequal.exports;

  function D$2() {
    this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
  }

  var M$2 = D$2;
  D$2.EventEmitter = D$2, D$2.prototype._events = void 0, D$2.prototype._maxListeners = void 0, D$2.defaultMaxListeners = 10, D$2.prototype.setMaxListeners = function (s) {
    if (!Mt(s) || s < 0 || isNaN(s)) throw TypeError("n must be a positive number");
    return this._maxListeners = s, this;
  }, D$2.prototype.emit = function (s) {
    var e, t, i, r, n, a;

    if (this._events || (this._events = {}), s === "error" && (!this._events.error || P$2(this._events.error) && !this._events.error.length)) {
      if (e = arguments[1], e instanceof Error) throw e;
      var o = new Error('Uncaught, unspecified "error" event. (' + e + ")");
      throw o.context = e, o;
    }

    if (t = this._events[s], oe$1(t)) return !1;
    if (_$4(t)) switch (arguments.length) {
      case 1:
        t.call(this);
        break;

      case 2:
        t.call(this, arguments[1]);
        break;

      case 3:
        t.call(this, arguments[1], arguments[2]);
        break;

      default:
        r = Array.prototype.slice.call(arguments, 1), t.apply(this, r);
    } else if (P$2(t)) for (r = Array.prototype.slice.call(arguments, 1), a = t.slice(), i = a.length, n = 0; n < i; n++) {
      a[n].apply(this, r);
    }
    return !0;
  }, D$2.prototype.addListener = function (s, e) {
    var t;
    if (!_$4(e)) throw TypeError("listener must be a function");
    return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", s, _$4(e.listener) ? e.listener : e), this._events[s] ? P$2(this._events[s]) ? this._events[s].push(e) : this._events[s] = [this._events[s], e] : this._events[s] = e, P$2(this._events[s]) && !this._events[s].warned && (oe$1(this._maxListeners) ? t = D$2.defaultMaxListeners : t = this._maxListeners, t && t > 0 && this._events[s].length > t && (this._events[s].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[s].length), typeof console.trace == "function" && console.trace())), this;
  }, D$2.prototype.on = D$2.prototype.addListener, D$2.prototype.once = function (s, e) {
    if (!_$4(e)) throw TypeError("listener must be a function");
    var t = !1;

    function i() {
      this.removeListener(s, i), t || (t = !0, e.apply(this, arguments));
    }

    return i.listener = e, this.on(s, i), this;
  }, D$2.prototype.removeListener = function (s, e) {
    var t, i, r, n;
    if (!_$4(e)) throw TypeError("listener must be a function");
    if (!this._events || !this._events[s]) return this;
    if (t = this._events[s], r = t.length, i = -1, t === e || _$4(t.listener) && t.listener === e) delete this._events[s], this._events.removeListener && this.emit("removeListener", s, e);else if (P$2(t)) {
      for (n = r; n-- > 0;) {
        if (t[n] === e || t[n].listener && t[n].listener === e) {
          i = n;
          break;
        }
      }

      if (i < 0) return this;
      t.length === 1 ? (t.length = 0, delete this._events[s]) : t.splice(i, 1), this._events.removeListener && this.emit("removeListener", s, e);
    }
    return this;
  }, D$2.prototype.removeAllListeners = function (s) {
    var e, t;
    if (!this._events) return this;
    if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[s] && delete this._events[s], this;

    if (arguments.length === 0) {
      for (e in this._events) {
        e !== "removeListener" && this.removeAllListeners(e);
      }

      return this.removeAllListeners("removeListener"), this._events = {}, this;
    }

    if (t = this._events[s], _$4(t)) this.removeListener(s, t);else if (t) for (; t.length;) {
      this.removeListener(s, t[t.length - 1]);
    }
    return delete this._events[s], this;
  }, D$2.prototype.listeners = function (s) {
    var e;
    return !this._events || !this._events[s] ? e = [] : _$4(this._events[s]) ? e = [this._events[s]] : e = this._events[s].slice(), e;
  }, D$2.prototype.listenerCount = function (s) {
    if (this._events) {
      var e = this._events[s];
      if (_$4(e)) return 1;
      if (e) return e.length;
    }

    return 0;
  }, D$2.listenerCount = function (s, e) {
    return s.listenerCount(e);
  };

  function _$4(s) {
    return typeof s == "function";
  }

  function Mt(s) {
    return typeof s == "number";
  }

  function P$2(s) {
    return _typeof$1(s) == "object" && s !== null;
  }

  function oe$1(s) {
    return s === void 0;
  }

  function Kt(s, e) {
    if (s.length >= 255) throw new TypeError("Alphabet too long");

    for (var t = new Uint8Array(256), i = 0; i < t.length; i++) {
      t[i] = 255;
    }

    for (var r = 0; r < s.length; r++) {
      var n = s.charAt(r),
          a = n.charCodeAt(0);
      if (t[a] !== 255) throw new TypeError(n + " is ambiguous");
      t[a] = r;
    }

    var o = s.length,
        u = s.charAt(0),
        p = Math.log(o) / Math.log(256),
        c = Math.log(256) / Math.log(o);

    function l(h) {
      if (h instanceof Uint8Array || (ArrayBuffer.isView(h) ? h = new Uint8Array(h.buffer, h.byteOffset, h.byteLength) : Array.isArray(h) && (h = Uint8Array.from(h))), !(h instanceof Uint8Array)) throw new TypeError("Expected Uint8Array");
      if (h.length === 0) return "";

      for (var g = 0, R = 0, f = 0, E = h.length; f !== E && h[f] === 0;) {
        f++, g++;
      }

      for (var v = (E - f) * c + 1 >>> 0, b = new Uint8Array(v); f !== E;) {
        for (var w = h[f], S = 0, y = v - 1; (w !== 0 || S < R) && y !== -1; y--, S++) {
          w += 256 * b[y] >>> 0, b[y] = w % o >>> 0, w = w / o >>> 0;
        }

        if (w !== 0) throw new Error("Non-zero carry");
        R = S, f++;
      }

      for (var C = v - R; C !== v && b[C] === 0;) {
        C++;
      }

      for (var U = u.repeat(g); C < v; ++C) {
        U += s.charAt(b[C]);
      }

      return U;
    }

    function F(h) {
      if (typeof h != "string") throw new TypeError("Expected String");
      if (h.length === 0) return new Uint8Array();
      var g = 0;

      if (h[g] !== " ") {
        for (var R = 0, f = 0; h[g] === u;) {
          R++, g++;
        }

        for (var E = (h.length - g) * p + 1 >>> 0, v = new Uint8Array(E); h[g];) {
          var b = t[h.charCodeAt(g)];
          if (b === 255) return;

          for (var w = 0, S = E - 1; (b !== 0 || w < f) && S !== -1; S--, w++) {
            b += o * v[S] >>> 0, v[S] = b % 256 >>> 0, b = b / 256 >>> 0;
          }

          if (b !== 0) throw new Error("Non-zero carry");
          f = w, g++;
        }

        if (h[g] !== " ") {
          for (var y = E - f; y !== E && v[y] === 0;) {
            y++;
          }

          for (var C = new Uint8Array(R + (E - y)), U = R; y !== E;) {
            C[U++] = v[y++];
          }

          return C;
        }
      }
    }

    function Y(h) {
      var g = F(h);
      if (g) return g;
      throw new Error("Non-".concat(e, " character"));
    }

    return {
      encode: l,
      decodeUnsafe: F,
      decode: Y
    };
  }

  var kt = Kt,
      $t = kt;

  var ue = function ue(s) {
    if (s instanceof Uint8Array && s.constructor.name === "Uint8Array") return s;
    if (s instanceof ArrayBuffer) return new Uint8Array(s);
    if (ArrayBuffer.isView(s)) return new Uint8Array(s.buffer, s.byteOffset, s.byteLength);
    throw new Error("Unknown type, must be binary type");
  },
      jt = function jt(s) {
    return new TextEncoder().encode(s);
  },
      Yt = function Yt(s) {
    return new TextDecoder().decode(s);
  };

  var Vt = /*#__PURE__*/function () {
    function Vt(e, t, i) {
      _classCallCheck(this, Vt);

      this.name = e, this.prefix = t, this.baseEncode = i;
    }

    _createClass(Vt, [{
      key: "encode",
      value: function encode(e) {
        if (e instanceof Uint8Array) return "".concat(this.prefix).concat(this.baseEncode(e));
        throw Error("Unknown type, must be binary type");
      }
    }]);

    return Vt;
  }();

  var Gt = /*#__PURE__*/function () {
    function Gt(e, t, i) {
      _classCallCheck(this, Gt);

      if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0) throw new Error("Invalid prefix character");
      this.prefixCodePoint = t.codePointAt(0), this.baseDecode = i;
    }

    _createClass(Gt, [{
      key: "decode",
      value: function decode(e) {
        if (typeof e == "string") {
          if (e.codePointAt(0) !== this.prefixCodePoint) throw Error("Unable to decode multibase string ".concat(JSON.stringify(e), ", ").concat(this.name, " decoder only supports inputs prefixed with ").concat(this.prefix));
          return this.baseDecode(e.slice(this.prefix.length));
        } else throw Error("Can only multibase decode strings");
      }
    }, {
      key: "or",
      value: function or(e) {
        return he$1(this, e);
      }
    }]);

    return Gt;
  }();

  var qt = /*#__PURE__*/function () {
    function qt(e) {
      _classCallCheck(this, qt);

      this.decoders = e;
    }

    _createClass(qt, [{
      key: "or",
      value: function or(e) {
        return he$1(this, e);
      }
    }, {
      key: "decode",
      value: function decode(e) {
        var t = e[0],
            i = this.decoders[t];
        if (i) return i.decode(e);
        throw RangeError("Unable to decode multibase string ".concat(JSON.stringify(e), ", only inputs prefixed with ").concat(Object.keys(this.decoders), " are supported"));
      }
    }]);

    return qt;
  }();

  var he$1 = function he(s, e) {
    return new qt(_objectSpread2(_objectSpread2({}, s.decoders || _defineProperty({}, s.prefix, s)), e.decoders || _defineProperty({}, e.prefix, e)));
  };

  var Jt = /*#__PURE__*/function () {
    function Jt(e, t, i, r) {
      _classCallCheck(this, Jt);

      this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = r, this.encoder = new Vt(e, t, i), this.decoder = new Gt(e, t, r);
    }

    _createClass(Jt, [{
      key: "encode",
      value: function encode(e) {
        return this.encoder.encode(e);
      }
    }, {
      key: "decode",
      value: function decode(e) {
        return this.decoder.decode(e);
      }
    }]);

    return Jt;
  }();

  var K$1 = function K(_ref3) {
    var s = _ref3.name,
        e = _ref3.prefix,
        t = _ref3.encode,
        i = _ref3.decode;
    return new Jt(s, e, t, i);
  },
      x$2 = function x(_ref4) {
    var s = _ref4.prefix,
        e = _ref4.name,
        t = _ref4.alphabet;

    var _$t = $t(t, e),
        i = _$t.encode,
        r = _$t.decode;

    return K$1({
      prefix: s,
      name: e,
      encode: i,
      decode: function decode(n) {
        return ue(r(n));
      }
    });
  },
      Wt = function Wt(s, e, t, i) {
    var r = {};

    for (var c = 0; c < e.length; ++c) {
      r[e[c]] = c;
    }

    var n = s.length;

    for (; s[n - 1] === "=";) {
      --n;
    }

    var a = new Uint8Array(n * t / 8 | 0);
    var o = 0,
        u = 0,
        p = 0;

    for (var _c = 0; _c < n; ++_c) {
      var l = r[s[_c]];
      if (l === void 0) throw new SyntaxError("Non-".concat(i, " character"));
      u = u << t | l, o += t, o >= 8 && (o -= 8, a[p++] = 255 & u >> o);
    }

    if (o >= t || 255 & u << 8 - o) throw new SyntaxError("Unexpected end of data");
    return a;
  },
      Xt = function Xt(s, e, t) {
    var i = e[e.length - 1] === "=",
        r = (1 << t) - 1;
    var n = "",
        a = 0,
        o = 0;

    for (var u = 0; u < s.length; ++u) {
      for (o = o << 8 | s[u], a += 8; a > t;) {
        a -= t, n += e[r & o >> a];
      }
    }

    if (a && (n += e[r & o << t - a]), i) for (; n.length * t & 7;) {
      n += "=";
    }
    return n;
  },
      d$3 = function d(_ref5) {
    var s = _ref5.name,
        e = _ref5.prefix,
        t = _ref5.bitsPerChar,
        i = _ref5.alphabet;
    return K$1({
      prefix: e,
      name: s,
      encode: function encode(r) {
        return Xt(r, i, t);
      },
      decode: function decode(r) {
        return Wt(r, i, t, s);
      }
    });
  },
      Ht = K$1({
    prefix: "\0",
    name: "identity",
    encode: function encode(s) {
      return Yt(s);
    },
    decode: function decode(s) {
      return jt(s);
    }
  });

  var Zt = Object.freeze({
    __proto__: null,
    identity: Ht
  });
  var Qt = d$3({
    prefix: "0",
    name: "base2",
    alphabet: "01",
    bitsPerChar: 1
  });
  var es$1 = Object.freeze({
    __proto__: null,
    base2: Qt
  });
  var ts = d$3({
    prefix: "7",
    name: "base8",
    alphabet: "01234567",
    bitsPerChar: 3
  });
  var ss = Object.freeze({
    __proto__: null,
    base8: ts
  });
  var is = x$2({
    prefix: "9",
    name: "base10",
    alphabet: "0123456789"
  });
  var rs = Object.freeze({
    __proto__: null,
    base10: is
  });
  var ns = d$3({
    prefix: "f",
    name: "base16",
    alphabet: "0123456789abcdef",
    bitsPerChar: 4
  }),
      as = d$3({
    prefix: "F",
    name: "base16upper",
    alphabet: "0123456789ABCDEF",
    bitsPerChar: 4
  });
  var os = Object.freeze({
    __proto__: null,
    base16: ns,
    base16upper: as
  });
  var us = d$3({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
  }),
      hs = d$3({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
  }),
      cs = d$3({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
  }),
      ls = d$3({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
  }),
      Ds = d$3({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
  }),
      ds = d$3({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
  }),
      gs = d$3({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
  }),
      ps = d$3({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
  }),
      bs = d$3({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
  });
  var fs = Object.freeze({
    __proto__: null,
    base32: us,
    base32upper: hs,
    base32pad: cs,
    base32padupper: ls,
    base32hex: Ds,
    base32hexupper: ds,
    base32hexpad: gs,
    base32hexpadupper: ps,
    base32z: bs
  });
  var ys = x$2({
    prefix: "k",
    name: "base36",
    alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
  }),
      ms = x$2({
    prefix: "K",
    name: "base36upper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  });
  var Es = Object.freeze({
    __proto__: null,
    base36: ys,
    base36upper: ms
  });
  var vs = x$2({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  }),
      ws = x$2({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
  });
  var Cs = Object.freeze({
    __proto__: null,
    base58btc: vs,
    base58flickr: ws
  });

  var _s = d$3({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
  }),
      Ss = d$3({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
  }),
      Is = d$3({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
  }),
      As = d$3({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
  });

  var Os = Object.freeze({
    __proto__: null,
    base64: _s,
    base64pad: Ss,
    base64url: Is,
    base64urlpad: As
  });
  var ce$1 = Array.from("\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42"),
      Rs = ce$1.reduce(function (s, e, t) {
    return s[t] = e, s;
  }, []),
      Ts = ce$1.reduce(function (s, e, t) {
    return s[e.codePointAt(0)] = t, s;
  }, []);

  function zs(s) {
    return s.reduce(function (e, t) {
      return e += Rs[t], e;
    }, "");
  }

  function Ps(s) {
    var e = [];

    var _iterator = _createForOfIteratorHelper(s),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var t = _step.value;
        var i = Ts[t.codePointAt(0)];
        if (i === void 0) throw new Error("Non-base256emoji character: ".concat(t));
        e.push(i);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return new Uint8Array(e);
  }

  var xs = K$1({
    prefix: "\uD83D\uDE80",
    name: "base256emoji",
    encode: zs,
    decode: Ps
  });
  var Ls = Object.freeze({
    __proto__: null,
    base256emoji: xs
  }),
      Fs = De,
      le$1 = 128,
      Us = 127,
      Ns = ~Us,
      Bs = Math.pow(2, 31);

  function De(s, e, t) {
    e = e || [], t = t || 0;

    for (var i = t; s >= Bs;) {
      e[t++] = s & 255 | le$1, s /= 128;
    }

    for (; s & Ns;) {
      e[t++] = s & 255 | le$1, s >>>= 7;
    }

    return e[t] = s | 0, De.bytes = t - i + 1, e;
  }

  var Ms = J$1,
      Ks = 128,
      de$2 = 127;

  function J$1(s, i) {
    var t = 0,
        i = i || 0,
        r = 0,
        n = i,
        a,
        o = s.length;

    do {
      if (n >= o) throw J$1.bytes = 0, new RangeError("Could not decode varint");
      a = s[n++], t += r < 28 ? (a & de$2) << r : (a & de$2) * Math.pow(2, r), r += 7;
    } while (a >= Ks);

    return J$1.bytes = n - i, t;
  }

  var ks = Math.pow(2, 7),
      $s = Math.pow(2, 14),
      js = Math.pow(2, 21),
      Ys = Math.pow(2, 28),
      Vs = Math.pow(2, 35),
      Gs = Math.pow(2, 42),
      qs = Math.pow(2, 49),
      Js = Math.pow(2, 56),
      Ws = Math.pow(2, 63),
      Xs = function Xs(s) {
    return s < ks ? 1 : s < $s ? 2 : s < js ? 3 : s < Ys ? 4 : s < Vs ? 5 : s < Gs ? 6 : s < qs ? 7 : s < Js ? 8 : s < Ws ? 9 : 10;
  },
      Hs = {
    encode: Fs,
    decode: Ms,
    encodingLength: Xs
  },
      ge$1 = Hs;

  var pe$1 = function pe(s, e) {
    var t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return ge$1.encode(s, e, t), e;
  },
      be = function be(s) {
    return ge$1.encodingLength(s);
  },
      W$1 = function W(s, e) {
    var t = e.byteLength,
        i = be(s),
        r = i + be(t),
        n = new Uint8Array(r + t);
    return pe$1(s, n, 0), pe$1(t, n, i), n.set(e, r), new Zs(s, t, e, n);
  };

  var Zs = /*#__PURE__*/_createClass(function Zs(e, t, i, r) {
    _classCallCheck(this, Zs);

    this.code = e, this.size = t, this.digest = i, this.bytes = r;
  });

  var fe = function fe(_ref6) {
    var s = _ref6.name,
        e = _ref6.code,
        t = _ref6.encode;
    return new Qs(s, e, t);
  };

  var Qs = /*#__PURE__*/function () {
    function Qs(e, t, i) {
      _classCallCheck(this, Qs);

      this.name = e, this.code = t, this.encode = i;
    }

    _createClass(Qs, [{
      key: "digest",
      value: function digest(e) {
        var _this = this;

        if (e instanceof Uint8Array) {
          var t = this.encode(e);
          return t instanceof Uint8Array ? W$1(this.code, t) : t.then(function (i) {
            return W$1(_this.code, i);
          });
        } else throw Error("Unknown type, must be binary type");
      }
    }]);

    return Qs;
  }();

  var ye = function ye(s) {
    return /*#__PURE__*/function () {
      var _ref7 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(e) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = Uint8Array;
                _context.next = 3;
                return crypto.subtle.digest(s, e);

              case 3:
                _context.t1 = _context.sent;
                return _context.abrupt("return", new _context.t0(_context.t1));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref7.apply(this, arguments);
      };
    }();
  },
      ei = fe({
    name: "sha2-256",
    code: 18,
    encode: ye("SHA-256")
  }),
      ti = fe({
    name: "sha2-512",
    code: 19,
    encode: ye("SHA-512")
  });

  var si = Object.freeze({
    __proto__: null,
    sha256: ei,
    sha512: ti
  });

  var me = 0,
      ii = "identity",
      Ee = ue,
      ri = function ri(s) {
    return W$1(me, Ee(s));
  },
      ni = {
    code: me,
    name: ii,
    encode: Ee,
    digest: ri
  };

  var ai = Object.freeze({
    __proto__: null,
    identity: ni
  });
  new TextEncoder(), new TextDecoder();

  var ve = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, Zt), es$1), ss), rs), os), fs), Es), Cs), Os), Ls);

  _objectSpread2(_objectSpread2({}, si), ai);

  function oi() {
    var s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(s) : new Uint8Array(s);
  }

  function we(s, e, t, i) {
    return {
      name: s,
      prefix: e,
      encoder: {
        name: s,
        prefix: e,
        encode: t
      },
      decoder: {
        decode: i
      }
    };
  }

  var Ce = we("utf8", "u", function (s) {
    var e = new TextDecoder("utf8");
    return "u" + e.decode(s);
  }, function (s) {
    return new TextEncoder().encode(s.substring(1));
  }),
      X$2 = we("ascii", "a", function (s) {
    var e = "a";

    for (var t = 0; t < s.length; t++) {
      e += String.fromCharCode(s[t]);
    }

    return e;
  }, function (s) {
    s = s.substring(1);
    var e = oi(s.length);

    for (var t = 0; t < s.length; t++) {
      e[t] = s.charCodeAt(t);
    }

    return e;
  }),
      ui = _objectSpread2({
    utf8: Ce,
    "utf-8": Ce,
    hex: ve.base16,
    latin1: X$2,
    ascii: X$2,
    binary: X$2
  }, ve);

  function hi(s) {
    var e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "utf8";
    var t = ui[e];
    if (!t) throw new Error("Unsupported encoding \"".concat(e, "\""));
    return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(s, "utf8") : t.decoder.decode("".concat(t.prefix).concat(s));
  }

  var H$3 = "wc",
      _e = 2,
      k$2 = "core",
      z$3 = "".concat(H$3, "@", 2, ":").concat(k$2, ":"),
      Se = {
    name: k$2,
    logger: "error"
  },
      Ie = {
    database: ":memory:"
  },
      Ae = "crypto",
      Z$1 = "client_ed25519_seed",
      Oe = cjs$5.ONE_DAY,
      Re = "keychain",
      Te = "0.3",
      ze = "messages",
      Pe = "0.3",
      xe = cjs$5.SIX_HOURS,
      Le = "publisher",
      ci = "irn",
      Fe = "error",
      Ue = "wss://relay.walletconnect.com",
      Ne = "relayer",
      L$3 = {
    message: "relayer_message",
    connect: "relayer_connect",
    disconnect: "relayer_disconnect",
    error: "relayer_error"
  },
      Be = "_subscription",
      T$4 = {
    payload: "payload",
    connect: "connect",
    disconnect: "disconnect",
    error: "error"
  },
      Me = cjs$5.ONE_SECOND,
      Ke = "2.0.0-rc.1",
      ke = "0.3",
      O$1 = {
    created: "subscription_created",
    deleted: "subscription_deleted",
    expired: "subscription_expired",
    disabled: "subscription_disabled",
    sync: "subscription_sync"
  },
      $e = "subscription",
      je = "0.3",
      Ye = cjs$5.FIVE_SECONDS * 1e3;

  var Ve = /*#__PURE__*/function () {
    function Ve(e, t) {
      var _this2 = this;

      _classCallCheck(this, Ve);

      this.core = e, this.logger = t, this.keychain = new Map(), this.name = Re, this.version = Te, this.initialized = !1, this.storagePrefix = z$3, this.init = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        var i;
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (_this2.initialized) {
                  _context2.next = 5;
                  break;
                }

                _context2.next = 3;
                return _this2.getKeyChain();

              case 3:
                i = _context2.sent;
                _typeof$1(i) < "u" && (_this2.keychain = i), _this2.initialized = !0;

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })), this.has = function (i) {
        return _this2.isInitialized(), _this2.keychain.has(i);
      }, this.set = /*#__PURE__*/function () {
        var _ref9 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(i, r) {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _this2.isInitialized();

                  _this2.keychain.set(i, r);

                  _context3.next = 4;
                  return _this2.persist();

                case 4:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x2, _x3) {
          return _ref9.apply(this, arguments);
        };
      }(), this.get = function (i) {
        _this2.isInitialized();

        var r = _this2.keychain.get(i);

        if (_typeof$1(r) > "u") {
          var _m = y$2("NO_MATCHING_KEY", "".concat(_this2.name, ": ").concat(i)),
              n = _m.message;

          throw new Error(n);
        }

        return r;
      }, this.del = /*#__PURE__*/function () {
        var _ref10 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(i) {
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _this2.isInitialized();

                  _this2.keychain["delete"](i);

                  _context4.next = 4;
                  return _this2.persist();

                case 4:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function (_x4) {
          return _ref10.apply(this, arguments);
        };
      }(), this.core = e, this.logger = cjs$4.generateChildLogger(t, this.name);
    }

    _createClass(Ve, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "storageKey",
      get: function get() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
    }, {
      key: "setKeyChain",
      value: function () {
        var _setKeyChain = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(e) {
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return this.core.storage.setItem(this.storageKey, Rn(e));

                case 2:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this);
        }));

        function setKeyChain(_x5) {
          return _setKeyChain.apply(this, arguments);
        }

        return setKeyChain;
      }()
    }, {
      key: "getKeyChain",
      value: function () {
        var _getKeyChain = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
          var e;
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return this.core.storage.getItem(this.storageKey);

                case 2:
                  e = _context6.sent;
                  return _context6.abrupt("return", _typeof$1(e) < "u" ? Cn(e) : void 0);

                case 4:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this);
        }));

        function getKeyChain() {
          return _getKeyChain.apply(this, arguments);
        }

        return getKeyChain;
      }()
    }, {
      key: "persist",
      value: function () {
        var _persist = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return this.setKeyChain(this.keychain);

                case 2:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));

        function persist() {
          return _persist.apply(this, arguments);
        }

        return persist;
      }()
    }, {
      key: "isInitialized",
      value: function isInitialized() {
        if (!this.initialized) {
          var _m2 = y$2("NOT_INITIALIZED", this.name),
              e = _m2.message;

          throw new Error(e);
        }
      }
    }]);

    return Ve;
  }();

  var Ge = /*#__PURE__*/function () {
    function Ge(e, t, i) {
      var _this3 = this;

      _classCallCheck(this, Ge);

      this.core = e, this.logger = t, this.name = Ae, this.initialized = !1, this.init = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8() {
        return regenerator.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.t0 = _this3.initialized;

                if (_context8.t0) {
                  _context8.next = 5;
                  break;
                }

                _context8.next = 4;
                return _this3.keychain.init();

              case 4:
                _this3.initialized = !0;

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      })), this.hasKeys = function (r) {
        return _this3.isInitialized(), _this3.keychain.has(r);
      }, this.getClientId = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {
        var r, n;
        return regenerator.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _this3.isInitialized();

                _context9.next = 3;
                return _this3.getClientSeed();

              case 3:
                r = _context9.sent;
                n = generateKeyPair(r);
                return _context9.abrupt("return", encodeIss(n.publicKey));

              case 6:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      })), this.generateKeyPair = function () {
        _this3.isInitialized();

        var r = dn();
        return _this3.setPrivateKey(r.publicKey, r.privateKey);
      }, this.signJWT = /*#__PURE__*/function () {
        var _ref13 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10(r) {
          var n, a, o, u;
          return regenerator.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _this3.isInitialized();

                  _context10.next = 3;
                  return _this3.getClientSeed();

                case 3:
                  n = _context10.sent;
                  a = generateKeyPair(n);
                  o = ln();
                  u = Oe;
                  _context10.next = 9;
                  return signJWT(o, r, u, a);

                case 9:
                  return _context10.abrupt("return", _context10.sent);

                case 10:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }));

        return function (_x6) {
          return _ref13.apply(this, arguments);
        };
      }(), this.generateSharedKey = function (r, n, a) {
        _this3.isInitialized();

        var o = _this3.getPrivateKey(r),
            u = fn(o, n);

        return _this3.setSymKey(u, a);
      }, this.setSymKey = /*#__PURE__*/function () {
        var _ref14 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11(r, n) {
          var a;
          return regenerator.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  _this3.isInitialized();

                  a = n || pn(r);
                  _context11.next = 4;
                  return _this3.keychain.set(a, r);

                case 4:
                  return _context11.abrupt("return", a);

                case 5:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11);
        }));

        return function (_x7, _x8) {
          return _ref14.apply(this, arguments);
        };
      }(), this.deleteKeyPair = /*#__PURE__*/function () {
        var _ref15 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12(r) {
          return regenerator.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  _this3.isInitialized();

                  _context12.next = 3;
                  return _this3.keychain.del(r);

                case 3:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12);
        }));

        return function (_x9) {
          return _ref15.apply(this, arguments);
        };
      }(), this.deleteSymKey = /*#__PURE__*/function () {
        var _ref16 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13(r) {
          return regenerator.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  _this3.isInitialized();

                  _context13.next = 3;
                  return _this3.keychain.del(r);

                case 3:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13);
        }));

        return function (_x10) {
          return _ref16.apply(this, arguments);
        };
      }(), this.encode = /*#__PURE__*/function () {
        var _ref17 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14(r, n, a) {
          var o, u, F, Y, p, c, l;
          return regenerator.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  _this3.isInitialized();

                  o = ge$2(a), u = safeJsonStringify$1(n);

                  if (!Nn(o)) {
                    _context14.next = 7;
                    break;
                  }

                  F = o.senderPublicKey, Y = o.receiverPublicKey;
                  _context14.next = 6;
                  return _this3.generateSharedKey(F, Y);

                case 6:
                  r = _context14.sent;

                case 7:
                  p = _this3.getSymKey(r), c = o.type, l = o.senderPublicKey;
                  return _context14.abrupt("return", yn({
                    type: c,
                    symKey: p,
                    message: u,
                    senderPublicKey: l
                  }));

                case 9:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14);
        }));

        return function (_x11, _x12, _x13) {
          return _ref17.apply(this, arguments);
        };
      }(), this.decode = /*#__PURE__*/function () {
        var _ref18 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee15(r, n, a) {
          var o, c, l, u, p;
          return regenerator.wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  _this3.isInitialized();

                  o = hn(n, a);

                  if (!Nn(o)) {
                    _context15.next = 7;
                    break;
                  }

                  c = o.receiverPublicKey, l = o.senderPublicKey;
                  _context15.next = 6;
                  return _this3.generateSharedKey(c, l);

                case 6:
                  r = _context15.sent;

                case 7:
                  u = _this3.getSymKey(r), p = En({
                    symKey: u,
                    encoded: n
                  });
                  return _context15.abrupt("return", safeJsonParse$1(p));

                case 9:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15);
        }));

        return function (_x14, _x15, _x16) {
          return _ref18.apply(this, arguments);
        };
      }(), this.core = e, this.logger = cjs$4.generateChildLogger(t, this.name), this.keychain = i || new Ve(this.core, this.logger);
    }

    _createClass(Ge, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "setPrivateKey",
      value: function () {
        var _setPrivateKey = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee16(e, t) {
          return regenerator.wrap(function _callee16$(_context16) {
            while (1) {
              switch (_context16.prev = _context16.next) {
                case 0:
                  _context16.next = 2;
                  return this.keychain.set(e, t);

                case 2:
                  return _context16.abrupt("return", e);

                case 3:
                case "end":
                  return _context16.stop();
              }
            }
          }, _callee16, this);
        }));

        function setPrivateKey(_x17, _x18) {
          return _setPrivateKey.apply(this, arguments);
        }

        return setPrivateKey;
      }()
    }, {
      key: "getPrivateKey",
      value: function getPrivateKey(e) {
        return this.keychain.get(e);
      }
    }, {
      key: "getClientSeed",
      value: function () {
        var _getClientSeed = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee17() {
          var e;
          return regenerator.wrap(function _callee17$(_context17) {
            while (1) {
              switch (_context17.prev = _context17.next) {
                case 0:
                  e = "";
                  _context17.prev = 1;
                  e = this.keychain.get(Z$1);
                  _context17.next = 10;
                  break;

                case 5:
                  _context17.prev = 5;
                  _context17.t0 = _context17["catch"](1);
                  e = ln();
                  _context17.next = 10;
                  return this.keychain.set(Z$1, e);

                case 10:
                  return _context17.abrupt("return", hi(e, "base16"));

                case 11:
                case "end":
                  return _context17.stop();
              }
            }
          }, _callee17, this, [[1, 5]]);
        }));

        function getClientSeed() {
          return _getClientSeed.apply(this, arguments);
        }

        return getClientSeed;
      }()
    }, {
      key: "getSymKey",
      value: function getSymKey(e) {
        return this.keychain.get(e);
      }
    }, {
      key: "isInitialized",
      value: function isInitialized() {
        if (!this.initialized) {
          var _m3 = y$2("NOT_INITIALIZED", this.name),
              e = _m3.message;

          throw new Error(e);
        }
      }
    }]);

    return Ge;
  }();

  var qe = /*#__PURE__*/function (_ut) {
    _inherits(qe, _ut);

    var _super = _createSuper(qe);

    function qe(e, t) {
      var _this4;

      _classCallCheck(this, qe);

      _this4 = _super.call(this, e, t), _this4.logger = e, _this4.core = t, _this4.messages = new Map(), _this4.name = ze, _this4.version = Pe, _this4.initialized = !1, _this4.storagePrefix = z$3, _this4.init = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee18() {
        var i;
        return regenerator.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (_this4.initialized) {
                  _context18.next = 15;
                  break;
                }

                _this4.logger.trace("Initialized");

                _context18.prev = 2;
                _context18.next = 5;
                return _this4.getRelayerMessages();

              case 5:
                i = _context18.sent;
                _typeof$1(i) < "u" && (_this4.messages = i), _this4.logger.debug("Successfully Restored records for ".concat(_this4.name)), _this4.logger.trace({
                  type: "method",
                  method: "restore",
                  size: _this4.messages.size
                });
                _context18.next = 12;
                break;

              case 9:
                _context18.prev = 9;
                _context18.t0 = _context18["catch"](2);
                _this4.logger.debug("Failed to Restore records for ".concat(_this4.name)), _this4.logger.error(_context18.t0);

              case 12:
                _context18.prev = 12;
                _this4.initialized = !0;
                return _context18.finish(12);

              case 15:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, null, [[2, 9, 12, 15]]);
      })), _this4.set = /*#__PURE__*/function () {
        var _ref20 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee19(i, r) {
          var n, a;
          return regenerator.wrap(function _callee19$(_context19) {
            while (1) {
              switch (_context19.prev = _context19.next) {
                case 0:
                  _this4.isInitialized();

                  n = mn(r);
                  a = _this4.messages.get(i);
                  _typeof$1(a) > "u" && (a = {});
                  _context19.t0 = _typeof$1(a[n]) < "u";

                  if (_context19.t0) {
                    _context19.next = 10;
                    break;
                  }

                  a[n] = r;

                  _this4.messages.set(i, a);

                  _context19.next = 10;
                  return _this4.persist();

                case 10:
                  return _context19.abrupt("return", n);

                case 11:
                case "end":
                  return _context19.stop();
              }
            }
          }, _callee19);
        }));

        return function (_x19, _x20) {
          return _ref20.apply(this, arguments);
        };
      }(), _this4.get = function (i) {
        _this4.isInitialized();

        var r = _this4.messages.get(i);

        return _typeof$1(r) > "u" && (r = {}), r;
      }, _this4.has = function (i, r) {
        _this4.isInitialized();

        var n = _this4.get(i),
            a = mn(r);

        return _typeof$1(n[a]) < "u";
      }, _this4.del = /*#__PURE__*/function () {
        var _ref21 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee20(i) {
          return regenerator.wrap(function _callee20$(_context20) {
            while (1) {
              switch (_context20.prev = _context20.next) {
                case 0:
                  _this4.isInitialized();

                  _this4.messages["delete"](i);

                  _context20.next = 4;
                  return _this4.persist();

                case 4:
                case "end":
                  return _context20.stop();
              }
            }
          }, _callee20);
        }));

        return function (_x21) {
          return _ref21.apply(this, arguments);
        };
      }(), _this4.logger = cjs$4.generateChildLogger(e, _this4.name), _this4.core = t;
      return _this4;
    }

    _createClass(qe, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "storageKey",
      get: function get() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
    }, {
      key: "setRelayerMessages",
      value: function () {
        var _setRelayerMessages = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee21(e) {
          return regenerator.wrap(function _callee21$(_context21) {
            while (1) {
              switch (_context21.prev = _context21.next) {
                case 0:
                  _context21.next = 2;
                  return this.core.storage.setItem(this.storageKey, Rn(e));

                case 2:
                case "end":
                  return _context21.stop();
              }
            }
          }, _callee21, this);
        }));

        function setRelayerMessages(_x22) {
          return _setRelayerMessages.apply(this, arguments);
        }

        return setRelayerMessages;
      }()
    }, {
      key: "getRelayerMessages",
      value: function () {
        var _getRelayerMessages = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee22() {
          var e;
          return regenerator.wrap(function _callee22$(_context22) {
            while (1) {
              switch (_context22.prev = _context22.next) {
                case 0:
                  _context22.next = 2;
                  return this.core.storage.getItem(this.storageKey);

                case 2:
                  e = _context22.sent;
                  return _context22.abrupt("return", _typeof$1(e) < "u" ? Cn(e) : void 0);

                case 4:
                case "end":
                  return _context22.stop();
              }
            }
          }, _callee22, this);
        }));

        function getRelayerMessages() {
          return _getRelayerMessages.apply(this, arguments);
        }

        return getRelayerMessages;
      }()
    }, {
      key: "persist",
      value: function () {
        var _persist2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee23() {
          return regenerator.wrap(function _callee23$(_context23) {
            while (1) {
              switch (_context23.prev = _context23.next) {
                case 0:
                  _context23.next = 2;
                  return this.setRelayerMessages(this.messages);

                case 2:
                case "end":
                  return _context23.stop();
              }
            }
          }, _callee23, this);
        }));

        function persist() {
          return _persist2.apply(this, arguments);
        }

        return persist;
      }()
    }, {
      key: "isInitialized",
      value: function isInitialized() {
        if (!this.initialized) {
          var _m4 = y$2("NOT_INITIALIZED", this.name),
              e = _m4.message;

          throw new Error(e);
        }
      }
    }]);

    return qe;
  }(p$2);

  var di = /*#__PURE__*/function (_ht) {
    _inherits(di, _ht);

    var _super2 = _createSuper(di);

    function di(e, t) {
      var _this5;

      _classCallCheck(this, di);

      _this5 = _super2.call(this, e, t), _this5.relayer = e, _this5.logger = t, _this5.events = new M$2.EventEmitter(), _this5.name = Le, _this5.queue = new Map(), _this5.publish = /*#__PURE__*/function () {
        var _ref22 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee24(i, r, n) {
          var a, o, u, p, c, l;
          return regenerator.wrap(function _callee24$(_context24) {
            while (1) {
              switch (_context24.prev = _context24.next) {
                case 0:
                  _this5.logger.debug("Publishing Payload"), _this5.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                      topic: i,
                      message: r,
                      opts: n
                    }
                  });
                  _context24.prev = 1;
                  a = (n === null || n === void 0 ? void 0 : n.ttl) || xe, o = Fn(n), u = (n === null || n === void 0 ? void 0 : n.prompt) || !1, p = (n === null || n === void 0 ? void 0 : n.tag) || 0, c = {
                    topic: i,
                    message: r,
                    opts: {
                      ttl: a,
                      relay: o,
                      prompt: u,
                      tag: p
                    }
                  }, l = mn(r);

                  _this5.queue.set(l, c);

                  _context24.next = 6;
                  return _this5.rpcPublish(i, r, a, o, u, p);

                case 6:
                  _this5.onPublish(l, c);

                  _this5.logger.debug("Successfully Published Payload");

                  _this5.logger.trace({
                    type: "method",
                    method: "publish",
                    params: {
                      topic: i,
                      message: r,
                      opts: n
                    }
                  });

                  _context24.next = 14;
                  break;

                case 11:
                  _context24.prev = 11;
                  _context24.t0 = _context24["catch"](1);
                  throw _this5.logger.debug("Failed to Publish Payload"), _this5.logger.error(_context24.t0), _context24.t0;

                case 14:
                case "end":
                  return _context24.stop();
              }
            }
          }, _callee24, null, [[1, 11]]);
        }));

        return function (_x23, _x24, _x25) {
          return _ref22.apply(this, arguments);
        };
      }(), _this5.on = function (i, r) {
        _this5.events.on(i, r);
      }, _this5.once = function (i, r) {
        _this5.events.once(i, r);
      }, _this5.off = function (i, r) {
        _this5.events.off(i, r);
      }, _this5.removeListener = function (i, r) {
        _this5.events.removeListener(i, r);
      }, _this5.relayer = e, _this5.logger = cjs$4.generateChildLogger(t, _this5.name), _this5.registerEventListeners();
      return _this5;
    }

    _createClass(di, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "rpcPublish",
      value: function rpcPublish(e, t, i, r, n, a) {
        var o, u, p, c;
        var l = {
          method: Hn(r.protocol).publish,
          params: {
            topic: e,
            message: t,
            ttl: i,
            prompt: n,
            tag: a
          }
        };
        return E$3((o = l.params) == null ? void 0 : o.prompt) && ((u = l.params) == null || delete u.prompt), E$3((p = l.params) == null ? void 0 : p.tag) && ((c = l.params) == null || delete c.tag), this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
          type: "message",
          direction: "outgoing",
          request: l
        }), this.relayer.provider.request(l);
      }
    }, {
      key: "onPublish",
      value: function onPublish(e, t) {
        this.queue["delete"](e);
      }
    }, {
      key: "checkQueue",
      value: function checkQueue() {
        var _this6 = this;

        this.queue.forEach( /*#__PURE__*/function () {
          var _ref23 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee25(e) {
            var t, i, _e$opts, r, n, a, o, u;

            return regenerator.wrap(function _callee25$(_context25) {
              while (1) {
                switch (_context25.prev = _context25.next) {
                  case 0:
                    t = e.topic, i = e.message, _e$opts = e.opts, r = _e$opts.ttl, n = _e$opts.relay, a = _e$opts.prompt, o = _e$opts.tag, u = mn(i);
                    _context25.next = 3;
                    return _this6.rpcPublish(t, i, r, n, a, o);

                  case 3:
                    _this6.onPublish(u, e);

                  case 4:
                  case "end":
                    return _context25.stop();
                }
              }
            }, _callee25);
          }));

          return function (_x26) {
            return _ref23.apply(this, arguments);
          };
        }());
      }
    }, {
      key: "registerEventListeners",
      value: function registerEventListeners() {
        var _this7 = this;

        this.relayer.core.heartbeat.on(cjs$6.HEARTBEAT_EVENTS.pulse, function () {
          _this7.checkQueue();
        });
      }
    }]);

    return di;
  }(d$5);

  var gi = /*#__PURE__*/function () {
    function gi() {
      var _this8 = this;

      _classCallCheck(this, gi);

      this.map = new Map(), this.set = function (e, t) {
        var i = _this8.get(e);

        _this8.exists(e, t) || _this8.map.set(e, [].concat(_toConsumableArray(i), [t]));
      }, this.get = function (e) {
        return _this8.map.get(e) || [];
      }, this.exists = function (e, t) {
        return _this8.get(e).includes(t);
      }, this["delete"] = function (e, t) {
        if (_typeof$1(t) > "u") {
          _this8.map["delete"](e);

          return;
        }

        if (!_this8.map.has(e)) return;

        var i = _this8.get(e);

        if (!_this8.exists(e, t)) return;
        var r = i.filter(function (n) {
          return n !== t;
        });

        if (!r.length) {
          _this8.map["delete"](e);

          return;
        }

        _this8.map.set(e, r);
      }, this.clear = function () {
        _this8.map.clear();
      };
    }

    _createClass(gi, [{
      key: "topics",
      get: function get() {
        return Array.from(this.map.keys());
      }
    }]);

    return gi;
  }();

  var pi = Object.defineProperty,
      bi = Object.defineProperties,
      fi = Object.getOwnPropertyDescriptors,
      Je = Object.getOwnPropertySymbols,
      yi = Object.prototype.hasOwnProperty,
      mi = Object.prototype.propertyIsEnumerable,
      We = function We(s, e, t) {
    return e in s ? pi(s, e, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }) : s[e] = t;
  },
      $$3 = function $(s, e) {
    for (var t in e || (e = {})) {
      yi.call(e, t) && We(s, t, e[t]);
    }

    if (Je) {
      var _iterator2 = _createForOfIteratorHelper(Je(e)),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var t = _step2.value;
          mi.call(e, t) && We(s, t, e[t]);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    return s;
  },
      Q$1 = function Q(s, e) {
    return bi(s, fi(e));
  };

  var Xe = /*#__PURE__*/function (_ct) {
    _inherits(Xe, _ct);

    var _super3 = _createSuper(Xe);

    function Xe(e, t) {
      var _this9;

      _classCallCheck(this, Xe);

      _this9 = _super3.call(this, e, t), _this9.relayer = e, _this9.logger = t, _this9.subscriptions = new Map(), _this9.topicMap = new gi(), _this9.events = new M$2.EventEmitter(), _this9.name = $e, _this9.version = je, _this9.pending = new Map(), _this9.cached = [], _this9.initialized = !1, _this9.pendingSubscriptionWatchLabel = "pending_sub_watch_label", _this9.pendingSubInterval = 20, _this9.storagePrefix = z$3, _this9.init = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee26() {
        return regenerator.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.t0 = _this9.initialized;

                if (_context26.t0) {
                  _context26.next = 9;
                  break;
                }

                _this9.logger.trace("Initialized");

                _context26.next = 5;
                return _this9.restore();

              case 5:
                _context26.next = 7;
                return _this9.reset();

              case 7:
                _this9.registerEventListeners();

                _this9.onEnable();

              case 9:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26);
      })), _this9.subscribe = /*#__PURE__*/function () {
        var _ref25 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee27(i, r) {
          var n, a, o;
          return regenerator.wrap(function _callee27$(_context27) {
            while (1) {
              switch (_context27.prev = _context27.next) {
                case 0:
                  _this9.isInitialized(), _this9.logger.debug("Subscribing Topic"), _this9.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: {
                      topic: i,
                      opts: r
                    }
                  });
                  _context27.prev = 1;
                  n = Fn(r), a = {
                    topic: i,
                    relay: n
                  };

                  _this9.pending.set(i, a);

                  _context27.next = 6;
                  return _this9.rpcSubscribe(i, n);

                case 6:
                  o = _context27.sent;
                  return _context27.abrupt("return", (_this9.onSubscribe(o, a), _this9.logger.debug("Successfully Subscribed Topic"), _this9.logger.trace({
                    type: "method",
                    method: "subscribe",
                    params: {
                      topic: i,
                      opts: r
                    }
                  }), o));

                case 10:
                  _context27.prev = 10;
                  _context27.t0 = _context27["catch"](1);
                  throw _this9.logger.debug("Failed to Subscribe Topic"), _this9.logger.error(_context27.t0), _context27.t0;

                case 13:
                case "end":
                  return _context27.stop();
              }
            }
          }, _callee27, null, [[1, 10]]);
        }));

        return function (_x27, _x28) {
          return _ref25.apply(this, arguments);
        };
      }(), _this9.unsubscribe = /*#__PURE__*/function () {
        var _ref26 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee28(i, r) {
          return regenerator.wrap(function _callee28$(_context28) {
            while (1) {
              switch (_context28.prev = _context28.next) {
                case 0:
                  _this9.isInitialized();

                  if (!(_typeof$1(r === null || r === void 0 ? void 0 : r.id) < "u")) {
                    _context28.next = 6;
                    break;
                  }

                  _context28.next = 4;
                  return _this9.unsubscribeById(i, r.id, r);

                case 4:
                  _context28.next = 8;
                  break;

                case 6:
                  _context28.next = 8;
                  return _this9.unsubscribeByTopic(i, r);

                case 8:
                case "end":
                  return _context28.stop();
              }
            }
          }, _callee28);
        }));

        return function (_x29, _x30) {
          return _ref26.apply(this, arguments);
        };
      }(), _this9.isSubscribed = /*#__PURE__*/function () {
        var _ref27 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee29(i) {
          return regenerator.wrap(function _callee29$(_context29) {
            while (1) {
              switch (_context29.prev = _context29.next) {
                case 0:
                  if (!_this9.topics.includes(i)) {
                    _context29.next = 4;
                    break;
                  }

                  _context29.t0 = !0;
                  _context29.next = 7;
                  break;

                case 4:
                  _context29.next = 6;
                  return new Promise(function (r, n) {
                    var a = new cjs$5.Watch();
                    a.start(_this9.pendingSubscriptionWatchLabel);
                    var o = setInterval(function () {
                      !_this9.pending.has(i) && _this9.topics.includes(i) && (clearInterval(o), a.stop(_this9.pendingSubscriptionWatchLabel), r(!0)), a.elapsed(_this9.pendingSubscriptionWatchLabel) >= Ye && (clearInterval(o), a.stop(_this9.pendingSubscriptionWatchLabel), n(!1));
                    }, _this9.pendingSubInterval);
                  });

                case 6:
                  _context29.t0 = _context29.sent;

                case 7:
                  return _context29.abrupt("return", _context29.t0);

                case 8:
                case "end":
                  return _context29.stop();
              }
            }
          }, _callee29);
        }));

        return function (_x31) {
          return _ref27.apply(this, arguments);
        };
      }(), _this9.on = function (i, r) {
        _this9.events.on(i, r);
      }, _this9.once = function (i, r) {
        _this9.events.once(i, r);
      }, _this9.off = function (i, r) {
        _this9.events.off(i, r);
      }, _this9.removeListener = function (i, r) {
        _this9.events.removeListener(i, r);
      }, _this9.relayer = e, _this9.logger = cjs$4.generateChildLogger(t, _this9.name);
      return _this9;
    }

    _createClass(Xe, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "storageKey",
      get: function get() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
    }, {
      key: "length",
      get: function get() {
        return this.subscriptions.size;
      }
    }, {
      key: "ids",
      get: function get() {
        return Array.from(this.subscriptions.keys());
      }
    }, {
      key: "values",
      get: function get() {
        return Array.from(this.subscriptions.values());
      }
    }, {
      key: "topics",
      get: function get() {
        return this.topicMap.topics;
      }
    }, {
      key: "hasSubscription",
      value: function hasSubscription(e, t) {
        var i = !1;

        try {
          i = this.getSubscription(e).topic === t;
        } catch (_unused2) {}

        return i;
      }
    }, {
      key: "onEnable",
      value: function onEnable() {
        this.cached = [], this.initialized = !0;
      }
    }, {
      key: "onDisable",
      value: function onDisable() {
        this.cached = this.values, this.subscriptions.clear(), this.topicMap.clear(), this.initialized = !1;
      }
    }, {
      key: "unsubscribeByTopic",
      value: function () {
        var _unsubscribeByTopic = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee31(e, t) {
          var _this10 = this;

          var i;
          return regenerator.wrap(function _callee31$(_context31) {
            while (1) {
              switch (_context31.prev = _context31.next) {
                case 0:
                  i = this.topicMap.get(e);
                  _context31.next = 3;
                  return Promise.all(i.map( /*#__PURE__*/function () {
                    var _ref28 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee30(r) {
                      return regenerator.wrap(function _callee30$(_context30) {
                        while (1) {
                          switch (_context30.prev = _context30.next) {
                            case 0:
                              _context30.next = 2;
                              return _this10.unsubscribeById(e, r, t);

                            case 2:
                              return _context30.abrupt("return", _context30.sent);

                            case 3:
                            case "end":
                              return _context30.stop();
                          }
                        }
                      }, _callee30);
                    }));

                    return function (_x34) {
                      return _ref28.apply(this, arguments);
                    };
                  }()));

                case 3:
                case "end":
                  return _context31.stop();
              }
            }
          }, _callee31, this);
        }));

        function unsubscribeByTopic(_x32, _x33) {
          return _unsubscribeByTopic.apply(this, arguments);
        }

        return unsubscribeByTopic;
      }()
    }, {
      key: "unsubscribeById",
      value: function () {
        var _unsubscribeById = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee32(e, t, i) {
          var r, n;
          return regenerator.wrap(function _callee32$(_context32) {
            while (1) {
              switch (_context32.prev = _context32.next) {
                case 0:
                  this.logger.debug("Unsubscribing Topic"), this.logger.trace({
                    type: "method",
                    method: "unsubscribe",
                    params: {
                      topic: e,
                      id: t,
                      opts: i
                    }
                  });
                  _context32.prev = 1;
                  r = Fn(i);
                  _context32.next = 5;
                  return this.rpcUnsubscribe(e, t, r);

                case 5:
                  n = N$2("USER_DISCONNECTED", "".concat(this.name, ", ").concat(e));
                  _context32.next = 8;
                  return this.onUnsubscribe(e, t, n);

                case 8:
                  this.logger.debug("Successfully Unsubscribed Topic");
                  this.logger.trace({
                    type: "method",
                    method: "unsubscribe",
                    params: {
                      topic: e,
                      id: t,
                      opts: i
                    }
                  });
                  _context32.next = 15;
                  break;

                case 12:
                  _context32.prev = 12;
                  _context32.t0 = _context32["catch"](1);
                  throw this.logger.debug("Failed to Unsubscribe Topic"), this.logger.error(_context32.t0), _context32.t0;

                case 15:
                case "end":
                  return _context32.stop();
              }
            }
          }, _callee32, this, [[1, 12]]);
        }));

        function unsubscribeById(_x35, _x36, _x37) {
          return _unsubscribeById.apply(this, arguments);
        }

        return unsubscribeById;
      }()
    }, {
      key: "rpcSubscribe",
      value: function () {
        var _rpcSubscribe = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee33(e, t) {
          var i;
          return regenerator.wrap(function _callee33$(_context33) {
            while (1) {
              switch (_context33.prev = _context33.next) {
                case 0:
                  i = {
                    method: Hn(t.protocol).subscribe,
                    params: {
                      topic: e
                    }
                  };
                  this.logger.debug("Outgoing Relay Payload");
                  this.logger.trace({
                    type: "payload",
                    direction: "outgoing",
                    request: i
                  });
                  _context33.next = 5;
                  return this.relayer.provider.request(i);

                case 5:
                  return _context33.abrupt("return", _context33.sent);

                case 6:
                case "end":
                  return _context33.stop();
              }
            }
          }, _callee33, this);
        }));

        function rpcSubscribe(_x38, _x39) {
          return _rpcSubscribe.apply(this, arguments);
        }

        return rpcSubscribe;
      }()
    }, {
      key: "rpcUnsubscribe",
      value: function rpcUnsubscribe(e, t, i) {
        var r = {
          method: Hn(i.protocol).unsubscribe,
          params: {
            topic: e,
            id: t
          }
        };
        return this.logger.debug("Outgoing Relay Payload"), this.logger.trace({
          type: "payload",
          direction: "outgoing",
          request: r
        }), this.relayer.provider.request(r);
      }
    }, {
      key: "onSubscribe",
      value: function onSubscribe(e, t) {
        this.setSubscription(e, Q$1($$3({}, t), {
          id: e
        })), this.pending["delete"](t.topic);
      }
    }, {
      key: "onResubscribe",
      value: function onResubscribe(e, t) {
        this.addSubscription(e, Q$1($$3({}, t), {
          id: e
        })), this.pending["delete"](t.topic);
      }
    }, {
      key: "onUnsubscribe",
      value: function () {
        var _onUnsubscribe = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee34(e, t, i) {
          return regenerator.wrap(function _callee34$(_context34) {
            while (1) {
              switch (_context34.prev = _context34.next) {
                case 0:
                  this.events.removeAllListeners(t);
                  this.hasSubscription(t, e) && this.deleteSubscription(t, i);
                  _context34.next = 4;
                  return this.relayer.messages.del(e);

                case 4:
                case "end":
                  return _context34.stop();
              }
            }
          }, _callee34, this);
        }));

        function onUnsubscribe(_x40, _x41, _x42) {
          return _onUnsubscribe.apply(this, arguments);
        }

        return onUnsubscribe;
      }()
    }, {
      key: "setRelayerSubscriptions",
      value: function () {
        var _setRelayerSubscriptions = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee35(e) {
          return regenerator.wrap(function _callee35$(_context35) {
            while (1) {
              switch (_context35.prev = _context35.next) {
                case 0:
                  _context35.next = 2;
                  return this.relayer.core.storage.setItem(this.storageKey, e);

                case 2:
                case "end":
                  return _context35.stop();
              }
            }
          }, _callee35, this);
        }));

        function setRelayerSubscriptions(_x43) {
          return _setRelayerSubscriptions.apply(this, arguments);
        }

        return setRelayerSubscriptions;
      }()
    }, {
      key: "getRelayerSubscriptions",
      value: function () {
        var _getRelayerSubscriptions = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee36() {
          return regenerator.wrap(function _callee36$(_context36) {
            while (1) {
              switch (_context36.prev = _context36.next) {
                case 0:
                  _context36.next = 2;
                  return this.relayer.core.storage.getItem(this.storageKey);

                case 2:
                  return _context36.abrupt("return", _context36.sent);

                case 3:
                case "end":
                  return _context36.stop();
              }
            }
          }, _callee36, this);
        }));

        function getRelayerSubscriptions() {
          return _getRelayerSubscriptions.apply(this, arguments);
        }

        return getRelayerSubscriptions;
      }()
    }, {
      key: "setSubscription",
      value: function setSubscription(e, t) {
        this.subscriptions.has(e) || (this.logger.debug("Setting subscription"), this.logger.trace({
          type: "method",
          method: "setSubscription",
          id: e,
          subscription: t
        }), this.addSubscription(e, t));
      }
    }, {
      key: "addSubscription",
      value: function addSubscription(e, t) {
        this.subscriptions.set(e, $$3({}, t)), this.topicMap.set(t.topic, e), this.events.emit(O$1.created, t);
      }
    }, {
      key: "getSubscription",
      value: function getSubscription(e) {
        this.logger.debug("Getting subscription"), this.logger.trace({
          type: "method",
          method: "getSubscription",
          id: e
        });
        var t = this.subscriptions.get(e);

        if (!t) {
          var _m5 = y$2("NO_MATCHING_KEY", "".concat(this.name, ": ").concat(e)),
              i = _m5.message;

          throw new Error(i);
        }

        return t;
      }
    }, {
      key: "deleteSubscription",
      value: function deleteSubscription(e, t) {
        this.logger.debug("Deleting subscription"), this.logger.trace({
          type: "method",
          method: "deleteSubscription",
          id: e,
          reason: t
        });
        var i = this.getSubscription(e);
        this.subscriptions["delete"](e), this.topicMap["delete"](i.topic, e), this.events.emit(O$1.deleted, Q$1($$3({}, i), {
          reason: t
        }));
      }
    }, {
      key: "persist",
      value: function () {
        var _persist3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee37() {
          return regenerator.wrap(function _callee37$(_context37) {
            while (1) {
              switch (_context37.prev = _context37.next) {
                case 0:
                  _context37.next = 2;
                  return this.setRelayerSubscriptions(this.values);

                case 2:
                  this.events.emit(O$1.sync);

                case 3:
                case "end":
                  return _context37.stop();
              }
            }
          }, _callee37, this);
        }));

        function persist() {
          return _persist3.apply(this, arguments);
        }

        return persist;
      }()
    }, {
      key: "reset",
      value: function () {
        var _reset = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee39() {
          var _this11 = this;

          return regenerator.wrap(function _callee39$(_context39) {
            while (1) {
              switch (_context39.prev = _context39.next) {
                case 0:
                  _context39.t0 = !this.cached.length;

                  if (_context39.t0) {
                    _context39.next = 4;
                    break;
                  }

                  _context39.next = 4;
                  return Promise.all(this.cached.map( /*#__PURE__*/function () {
                    var _ref29 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee38(e) {
                      return regenerator.wrap(function _callee38$(_context38) {
                        while (1) {
                          switch (_context38.prev = _context38.next) {
                            case 0:
                              _context38.next = 2;
                              return _this11.resubscribe(e);

                            case 2:
                              return _context38.abrupt("return", _context38.sent);

                            case 3:
                            case "end":
                              return _context38.stop();
                          }
                        }
                      }, _callee38);
                    }));

                    return function (_x44) {
                      return _ref29.apply(this, arguments);
                    };
                  }()));

                case 4:
                case "end":
                  return _context39.stop();
              }
            }
          }, _callee39, this);
        }));

        function reset() {
          return _reset.apply(this, arguments);
        }

        return reset;
      }()
    }, {
      key: "restore",
      value: function () {
        var _restore = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee40() {
          var e, _m6, t;

          return regenerator.wrap(function _callee40$(_context40) {
            while (1) {
              switch (_context40.prev = _context40.next) {
                case 0:
                  _context40.prev = 0;
                  _context40.next = 3;
                  return this.getRelayerSubscriptions();

                case 3:
                  e = _context40.sent;

                  if (!(_typeof$1(e) > "u" || !e.length)) {
                    _context40.next = 6;
                    break;
                  }

                  return _context40.abrupt("return");

                case 6:
                  if (!this.subscriptions.size) {
                    _context40.next = 9;
                    break;
                  }

                  _m6 = y$2("RESTORE_WILL_OVERRIDE", this.name), t = _m6.message;
                  throw this.logger.error(t), new Error(t);

                case 9:
                  this.cached = e, this.logger.debug("Successfully Restored subscriptions for ".concat(this.name)), this.logger.trace({
                    type: "method",
                    method: "restore",
                    subscriptions: this.values
                  });
                  _context40.next = 15;
                  break;

                case 12:
                  _context40.prev = 12;
                  _context40.t0 = _context40["catch"](0);
                  this.logger.debug("Failed to Restore subscriptions for ".concat(this.name)), this.logger.error(_context40.t0);

                case 15:
                case "end":
                  return _context40.stop();
              }
            }
          }, _callee40, this, [[0, 12]]);
        }));

        function restore() {
          return _restore.apply(this, arguments);
        }

        return restore;
      }()
    }, {
      key: "resubscribe",
      value: function () {
        var _resubscribe = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee41(e) {
          var t, i, r, n;
          return regenerator.wrap(function _callee41$(_context41) {
            while (1) {
              switch (_context41.prev = _context41.next) {
                case 0:
                  if (this.ids.includes(e.id)) {
                    _context41.next = 7;
                    break;
                  }

                  t = e.topic, i = e.relay, r = {
                    topic: t,
                    relay: i
                  };
                  this.pending.set(r.topic, r);
                  _context41.next = 5;
                  return this.rpcSubscribe(r.topic, r.relay);

                case 5:
                  n = _context41.sent;
                  this.onResubscribe(n, r);

                case 7:
                case "end":
                  return _context41.stop();
              }
            }
          }, _callee41, this);
        }));

        function resubscribe(_x45) {
          return _resubscribe.apply(this, arguments);
        }

        return resubscribe;
      }()
    }, {
      key: "onConnect",
      value: function () {
        var _onConnect = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee42() {
          return regenerator.wrap(function _callee42$(_context42) {
            while (1) {
              switch (_context42.prev = _context42.next) {
                case 0:
                  _context42.next = 2;
                  return this.reset();

                case 2:
                  this.onEnable();

                case 3:
                case "end":
                  return _context42.stop();
              }
            }
          }, _callee42, this);
        }));

        function onConnect() {
          return _onConnect.apply(this, arguments);
        }

        return onConnect;
      }()
    }, {
      key: "onDisconnect",
      value: function onDisconnect() {
        this.onDisable();
      }
    }, {
      key: "checkPending",
      value: function checkPending() {
        var _this12 = this;

        this.pending.forEach( /*#__PURE__*/function () {
          var _ref30 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee43(e) {
            var t;
            return regenerator.wrap(function _callee43$(_context43) {
              while (1) {
                switch (_context43.prev = _context43.next) {
                  case 0:
                    _context43.next = 2;
                    return _this12.rpcSubscribe(e.topic, e.relay);

                  case 2:
                    t = _context43.sent;

                    _this12.onSubscribe(t, e);

                  case 4:
                  case "end":
                    return _context43.stop();
                }
              }
            }, _callee43);
          }));

          return function (_x46) {
            return _ref30.apply(this, arguments);
          };
        }());
      }
    }, {
      key: "registerEventListeners",
      value: function registerEventListeners() {
        var _this13 = this;

        this.relayer.core.heartbeat.on(cjs$6.HEARTBEAT_EVENTS.pulse, function () {
          _this13.checkPending();
        }), this.relayer.provider.on(T$4.connect, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee44() {
          return regenerator.wrap(function _callee44$(_context44) {
            while (1) {
              switch (_context44.prev = _context44.next) {
                case 0:
                  _context44.next = 2;
                  return _this13.onConnect();

                case 2:
                case "end":
                  return _context44.stop();
              }
            }
          }, _callee44);
        }))), this.relayer.provider.on(T$4.disconnect, function () {
          _this13.onDisconnect();
        }), this.events.on(O$1.created, /*#__PURE__*/function () {
          var _ref32 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee45(e) {
            var t;
            return regenerator.wrap(function _callee45$(_context45) {
              while (1) {
                switch (_context45.prev = _context45.next) {
                  case 0:
                    t = O$1.created;

                    _this13.logger.info("Emitting ".concat(t));

                    _this13.logger.debug({
                      type: "event",
                      event: t,
                      data: e
                    });

                    _context45.next = 5;
                    return _this13.persist();

                  case 5:
                  case "end":
                    return _context45.stop();
                }
              }
            }, _callee45);
          }));

          return function (_x47) {
            return _ref32.apply(this, arguments);
          };
        }()), this.events.on(O$1.deleted, /*#__PURE__*/function () {
          var _ref33 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee46(e) {
            var t;
            return regenerator.wrap(function _callee46$(_context46) {
              while (1) {
                switch (_context46.prev = _context46.next) {
                  case 0:
                    t = O$1.deleted;

                    _this13.logger.info("Emitting ".concat(t));

                    _this13.logger.debug({
                      type: "event",
                      event: t,
                      data: e
                    });

                    _context46.next = 5;
                    return _this13.persist();

                  case 5:
                  case "end":
                    return _context46.stop();
                }
              }
            }, _callee46);
          }));

          return function (_x48) {
            return _ref33.apply(this, arguments);
          };
        }());
      }
    }, {
      key: "isInitialized",
      value: function isInitialized() {
        if (!this.initialized) {
          var _m7 = y$2("NOT_INITIALIZED", this.name),
              e = _m7.message;

          throw new Error(e);
        }
      }
    }]);

    return Xe;
  }(b$1);

  var Ei = Object.defineProperty,
      He = Object.getOwnPropertySymbols,
      vi = Object.prototype.hasOwnProperty,
      wi = Object.prototype.propertyIsEnumerable,
      Ze$1 = function Ze(s, e, t) {
    return e in s ? Ei(s, e, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }) : s[e] = t;
  },
      Ci = function Ci(s, e) {
    for (var t in e || (e = {})) {
      vi.call(e, t) && Ze$1(s, t, e[t]);
    }

    if (He) {
      var _iterator3 = _createForOfIteratorHelper(He(e)),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var t = _step3.value;
          wi.call(e, t) && Ze$1(s, t, e[t]);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }

    return s;
  };

  var Qe = /*#__PURE__*/function (_lt) {
    _inherits(Qe, _lt);

    var _super4 = _createSuper(Qe);

    function Qe(e) {
      var _this14;

      _classCallCheck(this, Qe);

      _this14 = _super4.call(this, e), _this14.protocol = "wc", _this14.version = 2, _this14.events = new M$2.EventEmitter(), _this14.name = Ne, _this14.initialized = !1, _this14.core = e.core, _this14.logger = _typeof$1(e.logger) < "u" && typeof e.logger != "string" ? cjs$4.generateChildLogger(e.logger, _this14.name) : browser$3(cjs$4.getDefaultLoggerOptions({
        level: e.logger || Fe
      })), _this14.messages = new qe(_this14.logger, e.core), _this14.subscriber = new Xe(_assertThisInitialized(_this14), _this14.logger), _this14.publisher = new di(_assertThisInitialized(_this14), _this14.logger), _this14.relayUrl = (e === null || e === void 0 ? void 0 : e.relayUrl) || Ue, _this14.projectId = e.projectId, _this14.provider = {};
      return _this14;
    }

    _createClass(Qe, [{
      key: "init",
      value: function () {
        var _init = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee47() {
          var e;
          return regenerator.wrap(function _callee47$(_context47) {
            while (1) {
              switch (_context47.prev = _context47.next) {
                case 0:
                  this.logger.trace("Initialized");
                  _context47.next = 3;
                  return this.core.crypto.signJWT(this.relayUrl);

                case 3:
                  e = _context47.sent;
                  this.provider = this.createProvider(e);
                  _context47.next = 7;
                  return Promise.all([this.messages.init(), this.provider.connect(), this.subscriber.init()]);

                case 7:
                  this.registerEventListeners();
                  this.initialized = !0;

                case 9:
                case "end":
                  return _context47.stop();
              }
            }
          }, _callee47, this);
        }));

        function init() {
          return _init.apply(this, arguments);
        }

        return init;
      }()
    }, {
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "connected",
      get: function get() {
        return this.provider.connection.connected;
      }
    }, {
      key: "connecting",
      get: function get() {
        return this.provider.connection.connecting;
      }
    }, {
      key: "publish",
      value: function () {
        var _publish = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee48(e, t, i) {
          return regenerator.wrap(function _callee48$(_context48) {
            while (1) {
              switch (_context48.prev = _context48.next) {
                case 0:
                  this.isInitialized();
                  _context48.next = 3;
                  return this.publisher.publish(e, t, i);

                case 3:
                  _context48.next = 5;
                  return this.recordMessageEvent({
                    topic: e,
                    message: t
                  });

                case 5:
                case "end":
                  return _context48.stop();
              }
            }
          }, _callee48, this);
        }));

        function publish(_x49, _x50, _x51) {
          return _publish.apply(this, arguments);
        }

        return publish;
      }()
    }, {
      key: "subscribe",
      value: function () {
        var _subscribe = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee49(e, t) {
          return regenerator.wrap(function _callee49$(_context49) {
            while (1) {
              switch (_context49.prev = _context49.next) {
                case 0:
                  this.isInitialized();
                  _context49.next = 3;
                  return this.subscriber.subscribe(e, t);

                case 3:
                  return _context49.abrupt("return", _context49.sent);

                case 4:
                case "end":
                  return _context49.stop();
              }
            }
          }, _callee49, this);
        }));

        function subscribe(_x52, _x53) {
          return _subscribe.apply(this, arguments);
        }

        return subscribe;
      }()
    }, {
      key: "unsubscribe",
      value: function () {
        var _unsubscribe = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee50(e, t) {
          return regenerator.wrap(function _callee50$(_context50) {
            while (1) {
              switch (_context50.prev = _context50.next) {
                case 0:
                  this.isInitialized();
                  _context50.next = 3;
                  return this.subscriber.unsubscribe(e, t);

                case 3:
                case "end":
                  return _context50.stop();
              }
            }
          }, _callee50, this);
        }));

        function unsubscribe(_x54, _x55) {
          return _unsubscribe.apply(this, arguments);
        }

        return unsubscribe;
      }()
    }, {
      key: "on",
      value: function on(e, t) {
        this.events.on(e, t);
      }
    }, {
      key: "once",
      value: function once(e, t) {
        this.events.once(e, t);
      }
    }, {
      key: "off",
      value: function off(e, t) {
        this.events.off(e, t);
      }
    }, {
      key: "removeListener",
      value: function removeListener(e, t) {
        this.events.removeListener(e, t);
      }
    }, {
      key: "createProvider",
      value: function createProvider(e) {
        return new JsonRpcProvider(new WsConnection(Tn({
          sdkVersion: Ke,
          protocol: this.protocol,
          version: this.version,
          relayUrl: this.relayUrl,
          projectId: this.projectId,
          auth: e
        })));
      }
    }, {
      key: "recordMessageEvent",
      value: function () {
        var _recordMessageEvent = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee51(e) {
          var t, i;
          return regenerator.wrap(function _callee51$(_context51) {
            while (1) {
              switch (_context51.prev = _context51.next) {
                case 0:
                  t = e.topic, i = e.message;
                  _context51.next = 3;
                  return this.messages.set(t, i);

                case 3:
                case "end":
                  return _context51.stop();
              }
            }
          }, _callee51, this);
        }));

        function recordMessageEvent(_x56) {
          return _recordMessageEvent.apply(this, arguments);
        }

        return recordMessageEvent;
      }()
    }, {
      key: "shouldIgnoreMessageEvent",
      value: function () {
        var _shouldIgnoreMessageEvent = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee52(e) {
          var t, i;
          return regenerator.wrap(function _callee52$(_context52) {
            while (1) {
              switch (_context52.prev = _context52.next) {
                case 0:
                  t = e.topic, i = e.message;
                  _context52.next = 3;
                  return this.subscriber.isSubscribed(t);

                case 3:
                  if (!_context52.sent) {
                    _context52.next = 7;
                    break;
                  }

                  _context52.t0 = this.messages.has(t, i);
                  _context52.next = 8;
                  break;

                case 7:
                  _context52.t0 = !0;

                case 8:
                  return _context52.abrupt("return", _context52.t0);

                case 9:
                case "end":
                  return _context52.stop();
              }
            }
          }, _callee52, this);
        }));

        function shouldIgnoreMessageEvent(_x57) {
          return _shouldIgnoreMessageEvent.apply(this, arguments);
        }

        return shouldIgnoreMessageEvent;
      }()
    }, {
      key: "onProviderPayload",
      value: function () {
        var _onProviderPayload = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee53(e) {
          var t, _t$data, i, r, n;

          return regenerator.wrap(function _callee53$(_context53) {
            while (1) {
              switch (_context53.prev = _context53.next) {
                case 0:
                  if (!(this.logger.debug("Incoming Relay Payload"), this.logger.trace({
                    type: "payload",
                    direction: "incoming",
                    payload: e
                  }), isJsonRpcRequest(e))) {
                    _context53.next = 11;
                    break;
                  }

                  if (e.method.endsWith(Be)) {
                    _context53.next = 3;
                    break;
                  }

                  return _context53.abrupt("return");

                case 3:
                  t = e.params, _t$data = t.data, i = _t$data.topic, r = _t$data.message, n = {
                    topic: i,
                    message: r
                  };
                  this.logger.debug("Emitting Relayer Payload");
                  this.logger.trace(Ci({
                    type: "event",
                    event: t.id
                  }, n));
                  this.events.emit(t.id, n);
                  _context53.next = 9;
                  return this.acknowledgePayload(e);

                case 9:
                  _context53.next = 11;
                  return this.onMessageEvent(n);

                case 11:
                case "end":
                  return _context53.stop();
              }
            }
          }, _callee53, this);
        }));

        function onProviderPayload(_x58) {
          return _onProviderPayload.apply(this, arguments);
        }

        return onProviderPayload;
      }()
    }, {
      key: "onMessageEvent",
      value: function () {
        var _onMessageEvent = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee54(e) {
          return regenerator.wrap(function _callee54$(_context54) {
            while (1) {
              switch (_context54.prev = _context54.next) {
                case 0:
                  _context54.next = 2;
                  return this.shouldIgnoreMessageEvent(e);

                case 2:
                  _context54.t0 = _context54.sent;

                  if (_context54.t0) {
                    _context54.next = 7;
                    break;
                  }

                  this.events.emit(L$3.message, e);
                  _context54.next = 7;
                  return this.recordMessageEvent(e);

                case 7:
                case "end":
                  return _context54.stop();
              }
            }
          }, _callee54, this);
        }));

        function onMessageEvent(_x59) {
          return _onMessageEvent.apply(this, arguments);
        }

        return onMessageEvent;
      }()
    }, {
      key: "acknowledgePayload",
      value: function () {
        var _acknowledgePayload = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee55(e) {
          var t;
          return regenerator.wrap(function _callee55$(_context55) {
            while (1) {
              switch (_context55.prev = _context55.next) {
                case 0:
                  t = formatJsonRpcResult(e.id, !0);
                  _context55.next = 3;
                  return this.provider.connection.send(t);

                case 3:
                case "end":
                  return _context55.stop();
              }
            }
          }, _callee55, this);
        }));

        function acknowledgePayload(_x60) {
          return _acknowledgePayload.apply(this, arguments);
        }

        return acknowledgePayload;
      }()
    }, {
      key: "registerEventListeners",
      value: function registerEventListeners() {
        var _this15 = this;

        this.provider.on(T$4.payload, function (e) {
          return _this15.onProviderPayload(e);
        }), this.provider.on(T$4.connect, function () {
          _this15.events.emit(L$3.connect);
        }), this.provider.on(T$4.disconnect, function () {
          _this15.events.emit(L$3.disconnect), setTimeout(function () {
            _this15.provider.connect();
          }, cjs$5.toMiliseconds(Me));
        }), this.provider.on(T$4.error, function (e) {
          return _this15.events.emit(L$3.error, e);
        });
      }
    }, {
      key: "isInitialized",
      value: function isInitialized() {
        if (!this.initialized) {
          var _m8 = y$2("NOT_INITIALIZED", this.name),
              e = _m8.message;

          throw new Error(e);
        }
      }
    }]);

    return Qe;
  }(L$5);

  var _i = Object.defineProperty,
      et = Object.getOwnPropertySymbols,
      Si = Object.prototype.hasOwnProperty,
      Ii = Object.prototype.propertyIsEnumerable,
      tt = function tt(s, e, t) {
    return e in s ? _i(s, e, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }) : s[e] = t;
  },
      st$1 = function st(s, e) {
    for (var t in e || (e = {})) {
      Si.call(e, t) && tt(s, t, e[t]);
    }

    if (et) {
      var _iterator4 = _createForOfIteratorHelper(et(e)),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var t = _step4.value;
          Ii.call(e, t) && tt(s, t, e[t]);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }

    return s;
  };

  var Ai = /*#__PURE__*/function (_Dt) {
    _inherits(Ai, _Dt);

    var _super5 = _createSuper(Ai);

    function Ai(e, t, i) {
      var _this16;

      var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : z$3;
      var n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : void 0;

      _classCallCheck(this, Ai);

      _this16 = _super5.call(this, e, t, i, r), _this16.core = e, _this16.logger = t, _this16.name = i, _this16.map = new Map(), _this16.version = ke, _this16.cached = [], _this16.initialized = !1, _this16.storagePrefix = z$3, _this16.init = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee56() {
        return regenerator.wrap(function _callee56$(_context56) {
          while (1) {
            switch (_context56.prev = _context56.next) {
              case 0:
                _context56.t0 = _this16.initialized;

                if (_context56.t0) {
                  _context56.next = 8;
                  break;
                }

                _this16.logger.trace("Initialized");

                _context56.next = 5;
                return _this16.restore();

              case 5:
                _this16.cached.forEach(function (a) {
                  et$1(a) ? _this16.map.set(a.id, a) : nt$2(a) ? _this16.map.set(a.topic, a) : _this16.getKey && a !== null && !E$3(a) && _this16.map.set(_this16.getKey(a), a);
                });

                _this16.cached = [];
                _this16.initialized = !0;

              case 8:
              case "end":
                return _context56.stop();
            }
          }
        }, _callee56);
      })), _this16.set = /*#__PURE__*/function () {
        var _ref35 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee57(a, o) {
          return regenerator.wrap(function _callee57$(_context57) {
            while (1) {
              switch (_context57.prev = _context57.next) {
                case 0:
                  _this16.isInitialized();

                  if (!_this16.map.has(a)) {
                    _context57.next = 6;
                    break;
                  }

                  _context57.next = 4;
                  return _this16.update(a, o);

                case 4:
                  _context57.next = 11;
                  break;

                case 6:
                  _this16.logger.debug("Setting value");

                  _this16.logger.trace({
                    type: "method",
                    method: "set",
                    key: a,
                    value: o
                  });

                  _this16.map.set(a, o);

                  _context57.next = 11;
                  return _this16.persist();

                case 11:
                case "end":
                  return _context57.stop();
              }
            }
          }, _callee57);
        }));

        return function (_x61, _x62) {
          return _ref35.apply(this, arguments);
        };
      }(), _this16.get = function (a) {
        return _this16.isInitialized(), _this16.logger.debug("Getting value"), _this16.logger.trace({
          type: "method",
          method: "get",
          key: a
        }), _this16.getData(a);
      }, _this16.getAll = function (a) {
        return a ? _this16.values.filter(function (o) {
          return Object.keys(a).every(function (u) {
            return Bt(o[u], a[u]);
          });
        }) : _this16.values;
      }, _this16.update = /*#__PURE__*/function () {
        var _ref36 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee58(a, o) {
          var u;
          return regenerator.wrap(function _callee58$(_context58) {
            while (1) {
              switch (_context58.prev = _context58.next) {
                case 0:
                  _this16.isInitialized(), _this16.logger.debug("Updating value"), _this16.logger.trace({
                    type: "method",
                    method: "update",
                    key: a,
                    update: o
                  });
                  u = st$1(st$1({}, _this16.getData(a)), o);

                  _this16.map.set(a, u);

                  _context58.next = 5;
                  return _this16.persist();

                case 5:
                case "end":
                  return _context58.stop();
              }
            }
          }, _callee58);
        }));

        return function (_x63, _x64) {
          return _ref36.apply(this, arguments);
        };
      }(), _this16["delete"] = /*#__PURE__*/function () {
        var _ref37 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee59(a, o) {
          return regenerator.wrap(function _callee59$(_context59) {
            while (1) {
              switch (_context59.prev = _context59.next) {
                case 0:
                  _this16.isInitialized();

                  _context59.t0 = _this16.map.has(a);

                  if (!_context59.t0) {
                    _context59.next = 8;
                    break;
                  }

                  _this16.logger.debug("Deleting value");

                  _this16.logger.trace({
                    type: "method",
                    method: "delete",
                    key: a,
                    reason: o
                  });

                  _this16.map["delete"](a);

                  _context59.next = 8;
                  return _this16.persist();

                case 8:
                case "end":
                  return _context59.stop();
              }
            }
          }, _callee59);
        }));

        return function (_x65, _x66) {
          return _ref37.apply(this, arguments);
        };
      }(), _this16.logger = cjs$4.generateChildLogger(t, _this16.name), _this16.storagePrefix = r, _this16.getKey = n;
      return _this16;
    }

    _createClass(Ai, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "storageKey",
      get: function get() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
    }, {
      key: "length",
      get: function get() {
        return this.map.size;
      }
    }, {
      key: "keys",
      get: function get() {
        return Array.from(this.map.keys());
      }
    }, {
      key: "values",
      get: function get() {
        return Array.from(this.map.values());
      }
    }, {
      key: "setDataStore",
      value: function () {
        var _setDataStore = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee60(e) {
          return regenerator.wrap(function _callee60$(_context60) {
            while (1) {
              switch (_context60.prev = _context60.next) {
                case 0:
                  _context60.next = 2;
                  return this.core.storage.setItem(this.storageKey, e);

                case 2:
                case "end":
                  return _context60.stop();
              }
            }
          }, _callee60, this);
        }));

        function setDataStore(_x67) {
          return _setDataStore.apply(this, arguments);
        }

        return setDataStore;
      }()
    }, {
      key: "getDataStore",
      value: function () {
        var _getDataStore = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee61() {
          return regenerator.wrap(function _callee61$(_context61) {
            while (1) {
              switch (_context61.prev = _context61.next) {
                case 0:
                  _context61.next = 2;
                  return this.core.storage.getItem(this.storageKey);

                case 2:
                  return _context61.abrupt("return", _context61.sent);

                case 3:
                case "end":
                  return _context61.stop();
              }
            }
          }, _callee61, this);
        }));

        function getDataStore() {
          return _getDataStore.apply(this, arguments);
        }

        return getDataStore;
      }()
    }, {
      key: "getData",
      value: function getData(e) {
        var t = this.map.get(e);

        if (!t) {
          var _m9 = y$2("NO_MATCHING_KEY", "".concat(this.name, ": ").concat(e)),
              i = _m9.message;

          throw this.logger.error(i), new Error(i);
        }

        return t;
      }
    }, {
      key: "persist",
      value: function () {
        var _persist4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee62() {
          return regenerator.wrap(function _callee62$(_context62) {
            while (1) {
              switch (_context62.prev = _context62.next) {
                case 0:
                  _context62.next = 2;
                  return this.setDataStore(this.values);

                case 2:
                case "end":
                  return _context62.stop();
              }
            }
          }, _callee62, this);
        }));

        function persist() {
          return _persist4.apply(this, arguments);
        }

        return persist;
      }()
    }, {
      key: "restore",
      value: function () {
        var _restore2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee63() {
          var e, _m10, t;

          return regenerator.wrap(function _callee63$(_context63) {
            while (1) {
              switch (_context63.prev = _context63.next) {
                case 0:
                  _context63.prev = 0;
                  _context63.next = 3;
                  return this.getDataStore();

                case 3:
                  e = _context63.sent;

                  if (!(_typeof$1(e) > "u" || !e.length)) {
                    _context63.next = 6;
                    break;
                  }

                  return _context63.abrupt("return");

                case 6:
                  if (!this.map.size) {
                    _context63.next = 9;
                    break;
                  }

                  _m10 = y$2("RESTORE_WILL_OVERRIDE", this.name), t = _m10.message;
                  throw this.logger.error(t), new Error(t);

                case 9:
                  this.cached = e, this.logger.debug("Successfully Restored value for ".concat(this.name)), this.logger.trace({
                    type: "method",
                    method: "restore",
                    value: this.values
                  });
                  _context63.next = 15;
                  break;

                case 12:
                  _context63.prev = 12;
                  _context63.t0 = _context63["catch"](0);
                  this.logger.debug("Failed to Restore value for ".concat(this.name)), this.logger.error(_context63.t0);

                case 15:
                case "end":
                  return _context63.stop();
              }
            }
          }, _callee63, this, [[0, 12]]);
        }));

        function restore() {
          return _restore2.apply(this, arguments);
        }

        return restore;
      }()
    }, {
      key: "isInitialized",
      value: function isInitialized() {
        if (!this.initialized) {
          var _m11 = y$2("NOT_INITIALIZED", this.name),
              e = _m11.message;

          throw new Error(e);
        }
      }
    }]);

    return Ai;
  }(x$3);

  var Oi = Object.defineProperty,
      it$1 = Object.getOwnPropertySymbols,
      Ri = Object.prototype.hasOwnProperty,
      Ti = Object.prototype.propertyIsEnumerable,
      rt$1 = function rt(s, e, t) {
    return e in s ? Oi(s, e, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: t
    }) : s[e] = t;
  },
      nt$1 = function nt(s, e) {
    for (var t in e || (e = {})) {
      Ri.call(e, t) && rt$1(s, t, e[t]);
    }

    if (it$1) {
      var _iterator5 = _createForOfIteratorHelper(it$1(e)),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var t = _step5.value;
          Ti.call(e, t) && rt$1(s, t, e[t]);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }

    return s;
  };

  var j$2 = /*#__PURE__*/function (_dt) {
    _inherits(j, _dt);

    var _super6 = _createSuper(j);

    function j(e) {
      var _this17;

      _classCallCheck(this, j);

      _this17 = _super6.call(this, e), _this17.protocol = H$3, _this17.version = _e, _this17.name = k$2, _this17.events = new M$2.EventEmitter(), _this17.initialized = !1, _this17.on = function (i, r) {
        return _this17.events.on(i, r);
      }, _this17.once = function (i, r) {
        return _this17.events.once(i, r);
      }, _this17.off = function (i, r) {
        return _this17.events.off(i, r);
      }, _this17.removeListener = function (i, r) {
        return _this17.events.removeListener(i, r);
      }, _this17.projectId = e === null || e === void 0 ? void 0 : e.projectId;
      var t = _typeof$1(e === null || e === void 0 ? void 0 : e.logger) < "u" && typeof (e === null || e === void 0 ? void 0 : e.logger) != "string" ? e.logger : browser$3(cjs$4.getDefaultLoggerOptions({
        level: (e === null || e === void 0 ? void 0 : e.logger) || Se.logger
      }));
      _this17.logger = cjs$4.generateChildLogger(t, _this17.name), _this17.heartbeat = new cjs$6.HeartBeat(), _this17.crypto = new Ge(_assertThisInitialized(_this17), _this17.logger, e === null || e === void 0 ? void 0 : e.keychain), _this17.storage = e != null && e.storage ? e.storage : new _default(nt$1(nt$1({}, Ie), e === null || e === void 0 ? void 0 : e.storageOptions)), _this17.relayer = new Qe({
        core: _assertThisInitialized(_this17),
        logger: _this17.logger,
        relayUrl: e === null || e === void 0 ? void 0 : e.relayUrl,
        projectId: _this17.projectId
      });
      return _this17;
    }

    _createClass(j, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "start",
      value: function () {
        var _start = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee64() {
          return regenerator.wrap(function _callee64$(_context64) {
            while (1) {
              switch (_context64.prev = _context64.next) {
                case 0:
                  _context64.t0 = this.initialized;

                  if (_context64.t0) {
                    _context64.next = 4;
                    break;
                  }

                  _context64.next = 4;
                  return this.initialize();

                case 4:
                case "end":
                  return _context64.stop();
              }
            }
          }, _callee64, this);
        }));

        function start() {
          return _start.apply(this, arguments);
        }

        return start;
      }()
    }, {
      key: "initialize",
      value: function () {
        var _initialize = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee65() {
          return regenerator.wrap(function _callee65$(_context65) {
            while (1) {
              switch (_context65.prev = _context65.next) {
                case 0:
                  this.logger.trace("Initialized");
                  _context65.prev = 1;
                  _context65.next = 4;
                  return this.crypto.init();

                case 4:
                  _context65.next = 6;
                  return this.relayer.init();

                case 6:
                  _context65.next = 8;
                  return this.heartbeat.init();

                case 8:
                  this.initialized = !0;
                  this.logger.info("Core Initilization Success");
                  _context65.next = 15;
                  break;

                case 12:
                  _context65.prev = 12;
                  _context65.t0 = _context65["catch"](1);
                  throw this.logger.info("Core Initilization Failure"), this.logger.error(_context65.t0.message), _context65.t0;

                case 15:
                case "end":
                  return _context65.stop();
              }
            }
          }, _callee65, this, [[1, 12]]);
        }));

        function initialize() {
          return _initialize.apply(this, arguments);
        }

        return initialize;
      }()
    }], [{
      key: "init",
      value: function () {
        var _init2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee66(e) {
          var t;
          return regenerator.wrap(function _callee66$(_context66) {
            while (1) {
              switch (_context66.prev = _context66.next) {
                case 0:
                  t = new j(e);
                  _context66.next = 3;
                  return t.initialize();

                case 3:
                  return _context66.abrupt("return", t);

                case 4:
                case "end":
                  return _context66.stop();
              }
            }
          }, _callee66);
        }));

        function init(_x68) {
          return _init2.apply(this, arguments);
        }

        return init;
      }()
    }]);

    return j;
  }(m$4);

  var zi = j$2;

  function d$2() {
    this._events = this._events || {}, this._maxListeners = this._maxListeners || void 0;
  }

  var C$2 = d$2;
  d$2.EventEmitter = d$2, d$2.prototype._events = void 0, d$2.prototype._maxListeners = void 0, d$2.defaultMaxListeners = 10, d$2.prototype.setMaxListeners = function (o) {
    if (!Ze(o) || o < 0 || isNaN(o)) throw TypeError("n must be a positive number");
    return this._maxListeners = o, this;
  }, d$2.prototype.emit = function (o) {
    var i, e, t, s, r, n;

    if (this._events || (this._events = {}), o === "error" && (!this._events.error || q$2(this._events.error) && !this._events.error.length)) {
      if (i = arguments[1], i instanceof Error) throw i;
      var a = new Error('Uncaught, unspecified "error" event. (' + i + ")");
      throw a.context = i, a;
    }

    if (e = this._events[o], te(e)) return !1;
    if (I$2(e)) switch (arguments.length) {
      case 1:
        e.call(this);
        break;

      case 2:
        e.call(this, arguments[1]);
        break;

      case 3:
        e.call(this, arguments[1], arguments[2]);
        break;

      default:
        s = Array.prototype.slice.call(arguments, 1), e.apply(this, s);
    } else if (q$2(e)) for (s = Array.prototype.slice.call(arguments, 1), n = e.slice(), t = n.length, r = 0; r < t; r++) {
      n[r].apply(this, s);
    }
    return !0;
  }, d$2.prototype.addListener = function (o, i) {
    var e;
    if (!I$2(i)) throw TypeError("listener must be a function");
    return this._events || (this._events = {}), this._events.newListener && this.emit("newListener", o, I$2(i.listener) ? i.listener : i), this._events[o] ? q$2(this._events[o]) ? this._events[o].push(i) : this._events[o] = [this._events[o], i] : this._events[o] = i, q$2(this._events[o]) && !this._events[o].warned && (te(this._maxListeners) ? e = d$2.defaultMaxListeners : e = this._maxListeners, e && e > 0 && this._events[o].length > e && (this._events[o].warned = !0, console.error("(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.", this._events[o].length), typeof console.trace == "function" && console.trace())), this;
  }, d$2.prototype.on = d$2.prototype.addListener, d$2.prototype.once = function (o, i) {
    if (!I$2(i)) throw TypeError("listener must be a function");
    var e = !1;

    function t() {
      this.removeListener(o, t), e || (e = !0, i.apply(this, arguments));
    }

    return t.listener = i, this.on(o, t), this;
  }, d$2.prototype.removeListener = function (o, i) {
    var e, t, s, r;
    if (!I$2(i)) throw TypeError("listener must be a function");
    if (!this._events || !this._events[o]) return this;
    if (e = this._events[o], s = e.length, t = -1, e === i || I$2(e.listener) && e.listener === i) delete this._events[o], this._events.removeListener && this.emit("removeListener", o, i);else if (q$2(e)) {
      for (r = s; r-- > 0;) {
        if (e[r] === i || e[r].listener && e[r].listener === i) {
          t = r;
          break;
        }
      }

      if (t < 0) return this;
      e.length === 1 ? (e.length = 0, delete this._events[o]) : e.splice(t, 1), this._events.removeListener && this.emit("removeListener", o, i);
    }
    return this;
  }, d$2.prototype.removeAllListeners = function (o) {
    var i, e;
    if (!this._events) return this;
    if (!this._events.removeListener) return arguments.length === 0 ? this._events = {} : this._events[o] && delete this._events[o], this;

    if (arguments.length === 0) {
      for (i in this._events) {
        i !== "removeListener" && this.removeAllListeners(i);
      }

      return this.removeAllListeners("removeListener"), this._events = {}, this;
    }

    if (e = this._events[o], I$2(e)) this.removeListener(o, e);else if (e) for (; e.length;) {
      this.removeListener(o, e[e.length - 1]);
    }
    return delete this._events[o], this;
  }, d$2.prototype.listeners = function (o) {
    var i;
    return !this._events || !this._events[o] ? i = [] : I$2(this._events[o]) ? i = [this._events[o]] : i = this._events[o].slice(), i;
  }, d$2.prototype.listenerCount = function (o) {
    if (this._events) {
      var i = this._events[o];
      if (I$2(i)) return 1;
      if (i) return i.length;
    }

    return 0;
  }, d$2.listenerCount = function (o, i) {
    return o.listenerCount(i);
  };

  function I$2(o) {
    return typeof o == "function";
  }

  function Ze(o) {
    return typeof o == "number";
  }

  function q$2(o) {
    return _typeof$1(o) == "object" && o !== null;
  }

  function te(o) {
    return o === void 0;
  }

  var Y$1 = "wc",
      X$1 = 2,
      H$2 = "client",
      T$3 = "".concat(Y$1, "@").concat(X$1, ":").concat(H$2, ":"),
      $$2 = {
    name: H$2,
    logger: "error",
    controller: !1,
    relayUrl: "wss://relay.walletconnect.com"
  },
      se = "expirer",
      m$2 = {
    created: "expirer_created",
    deleted: "expirer_deleted",
    expired: "expirer_expired",
    sync: "expirer_sync"
  },
      ie = "0.3",
      _$3 = {
    created: "history_created",
    updated: "history_updated",
    deleted: "history_deleted",
    sync: "history_sync"
  },
      re = "history",
      ne = "0.3",
      oe = "pairing",
      ae = "proposal",
      F$2 = jn(cjs$5.THIRTY_DAYS),
      ce = "session",
      he = cjs$5.SEVEN_DAYS,
      L$2 = jn(he),
      le = "engine",
      G$1 = {
    wc_pairingDelete: {
      req: {
        prompt: !1,
        tag: 1e3
      },
      res: {
        prompt: !1,
        tag: 1001
      }
    },
    wc_pairingPing: {
      req: {
        prompt: !1,
        tag: 1002
      },
      res: {
        prompt: !1,
        tag: 1003
      }
    },
    wc_sessionPropose: {
      req: {
        prompt: !0,
        tag: 1100
      },
      res: {
        prompt: !1,
        tag: 1101
      }
    },
    wc_sessionSettle: {
      req: {
        prompt: !1,
        tag: 1102
      },
      res: {
        prompt: !1,
        tag: 1103
      }
    },
    wc_sessionUpdate: {
      req: {
        prompt: !1,
        tag: 1104
      },
      res: {
        prompt: !1,
        tag: 1105
      }
    },
    wc_sessionExtend: {
      req: {
        prompt: !1,
        tag: 1106
      },
      res: {
        prompt: !1,
        tag: 1107
      }
    },
    wc_sessionRequest: {
      req: {
        prompt: !0,
        tag: 1108
      },
      res: {
        prompt: !1,
        tag: 1109
      }
    },
    wc_sessionEvent: {
      req: {
        prompt: !0,
        tag: 1110
      },
      res: {
        prompt: !1,
        tag: 1111
      }
    },
    wc_sessionDelete: {
      req: {
        prompt: !1,
        tag: 1112
      },
      res: {
        prompt: !1,
        tag: 1113
      }
    },
    wc_sessionPing: {
      req: {
        prompt: !1,
        tag: 1114
      },
      res: {
        prompt: !1,
        tag: 1115
      }
    }
  };

  var st = Object.defineProperty,
      it = Object.defineProperties,
      rt = Object.getOwnPropertyDescriptors,
      pe = Object.getOwnPropertySymbols,
      nt = Object.prototype.hasOwnProperty,
      ot = Object.prototype.propertyIsEnumerable,
      de$1 = function de(o, i, e) {
    return i in o ? st(o, i, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: e
    }) : o[i] = e;
  },
      R$1 = function R(o, i) {
    for (var e in i || (i = {})) {
      nt.call(i, e) && de$1(o, e, i[e]);
    }

    if (pe) {
      var _iterator = _createForOfIteratorHelper(pe(i)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var e = _step.value;
          ot.call(i, e) && de$1(o, e, i[e]);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return o;
  },
      ge = function ge(o, i) {
    return it(o, rt(i));
  };

  var at = /*#__PURE__*/function (_ye) {
    _inherits(at, _ye);

    var _super = _createSuper(at);

    function at(i) {
      var _this;

      _classCallCheck(this, at);

      _this = _super.call(this, i), _this.events = new C$2(), _this.initialized = !1, _this.name = le, _this.init = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.t0 = _this.initialized;

                if (_context.t0) {
                  _context.next = 7;
                  break;
                }

                _context.next = 4;
                return _this.cleanup();

              case 4:
                _this.registerRelayerEvents();

                _this.registerExpirerEvents();

                _this.initialized = !0;

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })), _this.connect = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(e) {
          var t, s, r, n, a, h, _yield$_this$createPa, v, g, l, w, _N, y, O, M, _c, _v, D, K;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _this.isInitialized();

                  _context3.next = 3;
                  return _this.isValidConnect(e);

                case 3:
                  t = e.pairingTopic, s = e.requiredNamespaces, r = e.relays;
                  n = t, h = !1;

                  if (!(n && (h = _this.client.pairing.get(n).active), !n || !h)) {
                    _context3.next = 12;
                    break;
                  }

                  _context3.next = 8;
                  return _this.createPairing();

                case 8:
                  _yield$_this$createPa = _context3.sent;
                  v = _yield$_this$createPa.topic;
                  g = _yield$_this$createPa.uri;
                  n = v, a = g;

                case 12:
                  _context3.next = 14;
                  return _this.client.core.crypto.generateKeyPair();

                case 14:
                  l = _context3.sent;
                  w = {
                    requiredNamespaces: s,
                    relays: r !== null && r !== void 0 ? r : [{
                      protocol: ci
                    }],
                    proposer: {
                      publicKey: l,
                      metadata: _this.client.metadata
                    }
                  };
                  _N = Vn();
                  y = _N.reject;
                  O = _N.resolve;
                  M = _N.done;

                  if (!(_this.events.once(Ln("session_connect"), /*#__PURE__*/function () {
                    var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(_ref3) {
                      var v, g, V;
                      return regenerator.wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              v = _ref3.error, g = _ref3.session;

                              if (!v) {
                                _context2.next = 5;
                                break;
                              }

                              y(v);
                              _context2.next = 17;
                              break;

                            case 5:
                              if (!g) {
                                _context2.next = 17;
                                break;
                              }

                              g.self.publicKey = l;
                              V = ge(R$1({}, g), {
                                requiredNamespaces: s
                              });
                              _context2.next = 10;
                              return _this.client.session.set(g.topic, V);

                            case 10:
                              _context2.next = 12;
                              return _this.setExpiry(g.topic, g.expiry);

                            case 12:
                              _context2.t0 = n;

                              if (!_context2.t0) {
                                _context2.next = 16;
                                break;
                              }

                              _context2.next = 16;
                              return _this.client.pairing.update(n, {
                                peerMetadata: g.peer.metadata
                              });

                            case 16:
                              O(V);

                            case 17:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2);
                    }));

                    return function (_x2) {
                      return _ref4.apply(this, arguments);
                    };
                  }()), !n)) {
                    _context3.next = 23;
                    break;
                  }

                  _c = y$2("NO_MATCHING_KEY", "connect() pairing topic: ".concat(n)), _v = _c.message;
                  throw new Error(_v);

                case 23:
                  _context3.next = 25;
                  return _this.sendRequest(n, "wc_sessionPropose", w);

                case 25:
                  D = _context3.sent;
                  K = jn(cjs$5.FIVE_MINUTES);
                  _context3.next = 29;
                  return _this.setProposal(D, R$1({
                    id: D,
                    expiry: K
                  }, w));

                case 29:
                  return _context3.abrupt("return", {
                    uri: a,
                    approval: M
                  });

                case 30:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      }(), _this.pair = /*#__PURE__*/function () {
        var _ref5 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(e) {
          var _Ie, t, s, r, n, a;

          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _this.isInitialized(), _this.isValidPair(e);
                  _Ie = Yn(e.uri), t = _Ie.topic, s = _Ie.symKey, r = _Ie.relay, n = jn(cjs$5.FIVE_MINUTES), a = {
                    topic: t,
                    relay: r,
                    expiry: n,
                    active: !1
                  };
                  _context4.next = 4;
                  return _this.client.pairing.set(t, a);

                case 4:
                  _context4.next = 6;
                  return _this.client.core.crypto.setSymKey(s, t);

                case 6:
                  _context4.next = 8;
                  return _this.client.core.relayer.subscribe(t, {
                    relay: r
                  });

                case 8:
                  _context4.next = 10;
                  return _this.setExpiry(t, n);

                case 10:
                  return _context4.abrupt("return", a);

                case 11:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));

        return function (_x3) {
          return _ref5.apply(this, arguments);
        };
      }(), _this.approve = /*#__PURE__*/function () {
        var _ref6 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5(e) {
          var t, s, r, _this$client$proposal, n, a, h, l, w, y, O, M, _N2, D, K, v, g;

          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _this.isInitialized();

                  _context5.next = 3;
                  return _this.isValidApprove(e);

                case 3:
                  t = e.id;
                  s = e.relayProtocol;
                  r = e.namespaces;
                  _this$client$proposal = _this.client.proposal.get(t);
                  n = _this$client$proposal.pairingTopic;
                  a = _this$client$proposal.proposer;
                  h = _this$client$proposal.requiredNamespaces;
                  _context5.next = 12;
                  return _this.client.core.crypto.generateKeyPair();

                case 12:
                  l = _context5.sent;
                  w = a.publicKey;
                  _context5.next = 16;
                  return _this.client.core.crypto.generateSharedKey(l, w);

                case 16:
                  y = _context5.sent;
                  O = {
                    relay: {
                      protocol: s !== null && s !== void 0 ? s : "irn"
                    },
                    namespaces: r,
                    requiredNamespaces: h,
                    controller: {
                      publicKey: l,
                      metadata: _this.client.metadata
                    },
                    expiry: L$2
                  };
                  _context5.next = 20;
                  return _this.client.core.relayer.subscribe(y);

                case 20:
                  _context5.next = 22;
                  return _this.sendRequest(y, "wc_sessionSettle", O);

                case 22:
                  M = _context5.sent;
                  _N2 = Vn();
                  D = _N2.done;
                  K = _N2.resolve;
                  v = _N2.reject;

                  _this.events.once(Ln("session_approve", M), function (_ref7) {
                    var V = _ref7.error;
                    V ? v(V) : K(_this.client.session.get(y));
                  });

                  g = ge(R$1({}, O), {
                    topic: y,
                    acknowledged: !1,
                    self: O.controller,
                    peer: {
                      publicKey: a.publicKey,
                      metadata: a.metadata
                    },
                    controller: l
                  });
                  _context5.next = 31;
                  return _this.client.session.set(y, g);

                case 31:
                  _context5.next = 33;
                  return _this.setExpiry(y, L$2);

                case 33:
                  _context5.t0 = n;

                  if (!_context5.t0) {
                    _context5.next = 37;
                    break;
                  }

                  _context5.next = 37;
                  return _this.client.pairing.update(n, {
                    peerMetadata: g.peer.metadata
                  });

                case 37:
                  _context5.t1 = n && t;

                  if (!_context5.t1) {
                    _context5.next = 45;
                    break;
                  }

                  _context5.next = 41;
                  return _this.sendResult(t, n, {
                    relay: {
                      protocol: s !== null && s !== void 0 ? s : "irn"
                    },
                    responderPublicKey: l
                  });

                case 41:
                  _context5.next = 43;
                  return _this.client.proposal["delete"](t, N$2("USER_DISCONNECTED"));

                case 43:
                  _context5.next = 45;
                  return _this.activatePairing(n);

                case 45:
                  return _context5.abrupt("return", {
                    topic: y,
                    acknowledged: D
                  });

                case 46:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        return function (_x4) {
          return _ref6.apply(this, arguments);
        };
      }(), _this.reject = /*#__PURE__*/function () {
        var _ref8 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6(e) {
          var t, s, _this$client$proposal2, r;

          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _this.isInitialized();

                  _context6.next = 3;
                  return _this.isValidReject(e);

                case 3:
                  t = e.id, s = e.reason, _this$client$proposal2 = _this.client.proposal.get(t), r = _this$client$proposal2.pairingTopic;
                  _context6.t0 = r;

                  if (!_context6.t0) {
                    _context6.next = 10;
                    break;
                  }

                  _context6.next = 8;
                  return _this.sendError(t, r, s);

                case 8:
                  _context6.next = 10;
                  return _this.client.proposal["delete"](t, N$2("USER_DISCONNECTED"));

                case 10:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x5) {
          return _ref8.apply(this, arguments);
        };
      }(), _this.update = /*#__PURE__*/function () {
        var _ref9 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7(e) {
          var t, s, r, _N3, n, a, h;

          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _this.isInitialized();

                  _context7.next = 3;
                  return _this.isValidUpdate(e);

                case 3:
                  t = e.topic;
                  s = e.namespaces;
                  _context7.next = 7;
                  return _this.sendRequest(t, "wc_sessionUpdate", {
                    namespaces: s
                  });

                case 7:
                  r = _context7.sent;
                  _N3 = Vn();
                  n = _N3.done;
                  a = _N3.resolve;
                  h = _N3.reject;

                  _this.events.once(Ln("session_update", r), function (_ref10) {
                    var l = _ref10.error;
                    l ? h(l) : a();
                  });

                  _context7.next = 15;
                  return _this.client.session.update(t, {
                    namespaces: s
                  });

                case 15:
                  return _context7.abrupt("return", {
                    acknowledged: n
                  });

                case 16:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }));

        return function (_x6) {
          return _ref9.apply(this, arguments);
        };
      }(), _this.extend = /*#__PURE__*/function () {
        var _ref11 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8(e) {
          var t, s, _N4, r, n, a;

          return regenerator.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _this.isInitialized();

                  _context8.next = 3;
                  return _this.isValidExtend(e);

                case 3:
                  t = e.topic;
                  _context8.next = 6;
                  return _this.sendRequest(t, "wc_sessionExtend", {});

                case 6:
                  s = _context8.sent;
                  _N4 = Vn();
                  r = _N4.done;
                  n = _N4.resolve;
                  a = _N4.reject;

                  _this.events.once(Ln("session_extend", s), function (_ref12) {
                    var h = _ref12.error;
                    h ? a(h) : n();
                  });

                  _context8.next = 14;
                  return _this.setExpiry(t, L$2);

                case 14:
                  return _context8.abrupt("return", {
                    acknowledged: r
                  });

                case 15:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        }));

        return function (_x7) {
          return _ref11.apply(this, arguments);
        };
      }(), _this.request = /*#__PURE__*/function () {
        var _ref13 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9(e) {
          var t, s, r, n, _N5, a, h, l;

          return regenerator.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  _this.isInitialized();

                  _context9.next = 3;
                  return _this.isValidRequest(e);

                case 3:
                  t = e.chainId;
                  s = e.request;
                  r = e.topic;
                  _context9.next = 8;
                  return _this.sendRequest(r, "wc_sessionRequest", {
                    request: s,
                    chainId: t
                  });

                case 8:
                  n = _context9.sent;
                  _N5 = Vn();
                  a = _N5.done;
                  h = _N5.resolve;
                  l = _N5.reject;

                  _this.events.once(Ln("session_request", n), function (_ref14) {
                    var w = _ref14.error,
                        y = _ref14.result;
                    w ? l(w) : h(y);
                  });

                  _context9.next = 16;
                  return a();

                case 16:
                  return _context9.abrupt("return", _context9.sent);

                case 17:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }));

        return function (_x8) {
          return _ref13.apply(this, arguments);
        };
      }(), _this.respond = /*#__PURE__*/function () {
        var _ref15 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10(e) {
          var t, s, r;
          return regenerator.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _this.isInitialized();

                  _context10.next = 3;
                  return _this.isValidRespond(e);

                case 3:
                  t = e.topic, s = e.response, r = s.id;

                  if (!isJsonRpcResult(s)) {
                    _context10.next = 9;
                    break;
                  }

                  _context10.next = 7;
                  return _this.sendResult(r, t, s.result);

                case 7:
                  _context10.next = 13;
                  break;

                case 9:
                  _context10.t0 = isJsonRpcError(s);

                  if (!_context10.t0) {
                    _context10.next = 13;
                    break;
                  }

                  _context10.next = 13;
                  return _this.sendError(r, t, s.error);

                case 13:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }));

        return function (_x9) {
          return _ref15.apply(this, arguments);
        };
      }(), _this.ping = /*#__PURE__*/function () {
        var _ref16 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11(e) {
          var t, s, _N6, r, n, a, _s, _N7, _r, _n, _a;

          return regenerator.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  _this.isInitialized();

                  _context11.next = 3;
                  return _this.isValidPing(e);

                case 3:
                  t = e.topic;

                  if (!_this.client.session.keys.includes(t)) {
                    _context11.next = 17;
                    break;
                  }

                  _context11.next = 7;
                  return _this.sendRequest(t, "wc_sessionPing", {});

                case 7:
                  s = _context11.sent;
                  _N6 = Vn();
                  r = _N6.done;
                  n = _N6.resolve;
                  a = _N6.reject;

                  _this.events.once(Ln("session_ping", s), function (_ref17) {
                    var h = _ref17.error;
                    h ? a(h) : n();
                  });

                  _context11.next = 15;
                  return r();

                case 15:
                  _context11.next = 28;
                  break;

                case 17:
                  if (!_this.client.pairing.keys.includes(t)) {
                    _context11.next = 28;
                    break;
                  }

                  _context11.next = 20;
                  return _this.sendRequest(t, "wc_pairingPing", {});

                case 20:
                  _s = _context11.sent;
                  _N7 = Vn();
                  _r = _N7.done;
                  _n = _N7.resolve;
                  _a = _N7.reject;

                  _this.events.once(Ln("pairing_ping", _s), function (_ref18) {
                    var h = _ref18.error;
                    h ? _a(h) : _n();
                  });

                  _context11.next = 28;
                  return _r();

                case 28:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11);
        }));

        return function (_x10) {
          return _ref16.apply(this, arguments);
        };
      }(), _this.emit = /*#__PURE__*/function () {
        var _ref19 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12(e) {
          var t, s, r;
          return regenerator.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  _this.isInitialized();

                  _context12.next = 3;
                  return _this.isValidEmit(e);

                case 3:
                  t = e.topic, s = e.event, r = e.chainId;
                  _context12.next = 6;
                  return _this.sendRequest(t, "wc_sessionEvent", {
                    event: s,
                    chainId: r
                  });

                case 6:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12);
        }));

        return function (_x11) {
          return _ref19.apply(this, arguments);
        };
      }(), _this.disconnect = /*#__PURE__*/function () {
        var _ref20 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13(e) {
          var t;
          return regenerator.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  _this.isInitialized();

                  _context13.next = 3;
                  return _this.isValidDisconnect(e);

                case 3:
                  t = e.topic;

                  if (!_this.client.session.keys.includes(t)) {
                    _context13.next = 11;
                    break;
                  }

                  _context13.next = 7;
                  return _this.sendRequest(t, "wc_sessionDelete", N$2("USER_DISCONNECTED"));

                case 7:
                  _context13.next = 9;
                  return _this.deleteSession(t);

                case 9:
                  _context13.next = 17;
                  break;

                case 11:
                  _context13.t0 = _this.client.pairing.keys.includes(t);

                  if (!_context13.t0) {
                    _context13.next = 17;
                    break;
                  }

                  _context13.next = 15;
                  return _this.sendRequest(t, "wc_pairingDelete", N$2("USER_DISCONNECTED"));

                case 15:
                  _context13.next = 17;
                  return _this.deletePairing(t);

                case 17:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13);
        }));

        return function (_x12) {
          return _ref20.apply(this, arguments);
        };
      }(), _this.find = function (e) {
        return _this.isInitialized(), _this.client.session.getAll().filter(function (t) {
          return Zn(t, e);
        });
      }, _this.activatePairing = /*#__PURE__*/function () {
        var _ref21 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14(e) {
          return regenerator.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  _context14.next = 2;
                  return _this.client.pairing.update(e, {
                    active: !0,
                    expiry: F$2
                  });

                case 2:
                  _context14.next = 4;
                  return _this.setExpiry(e, F$2);

                case 4:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14);
        }));

        return function (_x13) {
          return _ref21.apply(this, arguments);
        };
      }(), _this.deleteSession = /*#__PURE__*/function () {
        var _ref22 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee15(e) {
          var _this$client$session$, t;

          return regenerator.wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  _this$client$session$ = _this.client.session.get(e), t = _this$client$session$.self;
                  _context15.next = 3;
                  return Promise.all([_this.client.core.relayer.unsubscribe(e), _this.client.session["delete"](e, N$2("USER_DISCONNECTED")), _this.client.core.crypto.deleteKeyPair(t.publicKey), _this.client.core.crypto.deleteSymKey(e), _this.client.expirer.del(e)]);

                case 3:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15);
        }));

        return function (_x14) {
          return _ref22.apply(this, arguments);
        };
      }(), _this.deletePairing = /*#__PURE__*/function () {
        var _ref23 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee16(e) {
          return regenerator.wrap(function _callee16$(_context16) {
            while (1) {
              switch (_context16.prev = _context16.next) {
                case 0:
                  _context16.next = 2;
                  return Promise.all([_this.client.core.relayer.unsubscribe(e), _this.client.pairing["delete"](e, N$2("USER_DISCONNECTED")), _this.client.core.crypto.deleteSymKey(e), _this.client.expirer.del(e)]);

                case 2:
                case "end":
                  return _context16.stop();
              }
            }
          }, _callee16);
        }));

        return function (_x15) {
          return _ref23.apply(this, arguments);
        };
      }(), _this.deleteProposal = /*#__PURE__*/function () {
        var _ref24 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee17(e) {
          return regenerator.wrap(function _callee17$(_context17) {
            while (1) {
              switch (_context17.prev = _context17.next) {
                case 0:
                  _context17.next = 2;
                  return Promise.all([_this.client.proposal["delete"](e, N$2("USER_DISCONNECTED")), _this.client.expirer.del(e)]);

                case 2:
                case "end":
                  return _context17.stop();
              }
            }
          }, _callee17);
        }));

        return function (_x16) {
          return _ref24.apply(this, arguments);
        };
      }(), _this.setExpiry = /*#__PURE__*/function () {
        var _ref25 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee18(e, t) {
          return regenerator.wrap(function _callee18$(_context18) {
            while (1) {
              switch (_context18.prev = _context18.next) {
                case 0:
                  if (!_this.client.pairing.keys.includes(e)) {
                    _context18.next = 5;
                    break;
                  }

                  _context18.next = 3;
                  return _this.client.pairing.update(e, {
                    expiry: t
                  });

                case 3:
                  _context18.next = 9;
                  break;

                case 5:
                  _context18.t0 = _this.client.session.keys.includes(e);

                  if (!_context18.t0) {
                    _context18.next = 9;
                    break;
                  }

                  _context18.next = 9;
                  return _this.client.session.update(e, {
                    expiry: t
                  });

                case 9:
                  _this.client.expirer.set(e, t);

                case 10:
                case "end":
                  return _context18.stop();
              }
            }
          }, _callee18);
        }));

        return function (_x17, _x18) {
          return _ref25.apply(this, arguments);
        };
      }(), _this.setProposal = /*#__PURE__*/function () {
        var _ref26 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee19(e, t) {
          return regenerator.wrap(function _callee19$(_context19) {
            while (1) {
              switch (_context19.prev = _context19.next) {
                case 0:
                  _context19.next = 2;
                  return _this.client.proposal.set(e, t);

                case 2:
                  _this.client.expirer.set(e, t.expiry);

                case 3:
                case "end":
                  return _context19.stop();
              }
            }
          }, _callee19);
        }));

        return function (_x19, _x20) {
          return _ref26.apply(this, arguments);
        };
      }(), _this.sendRequest = /*#__PURE__*/function () {
        var _ref27 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee20(e, t, s) {
          var r, n, a;
          return regenerator.wrap(function _callee20$(_context20) {
            while (1) {
              switch (_context20.prev = _context20.next) {
                case 0:
                  r = formatJsonRpcRequest(t, s);
                  _context20.next = 3;
                  return _this.client.core.crypto.encode(e, r);

                case 3:
                  n = _context20.sent;
                  a = G$1[t].req;
                  _context20.next = 7;
                  return _this.client.core.relayer.publish(e, n, a);

                case 7:
                  _this.client.history.set(e, r);

                  return _context20.abrupt("return", r.id);

                case 9:
                case "end":
                  return _context20.stop();
              }
            }
          }, _callee20);
        }));

        return function (_x21, _x22, _x23) {
          return _ref27.apply(this, arguments);
        };
      }(), _this.sendResult = /*#__PURE__*/function () {
        var _ref28 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee21(e, t, s) {
          var r, n, a, h;
          return regenerator.wrap(function _callee21$(_context21) {
            while (1) {
              switch (_context21.prev = _context21.next) {
                case 0:
                  r = formatJsonRpcResult(e, s);
                  _context21.next = 3;
                  return _this.client.core.crypto.encode(t, r);

                case 3:
                  n = _context21.sent;
                  _context21.next = 6;
                  return _this.client.history.get(t, e);

                case 6:
                  a = _context21.sent;
                  h = G$1[a.request.method].res;
                  _context21.next = 10;
                  return _this.client.core.relayer.publish(t, n, h);

                case 10:
                  _context21.next = 12;
                  return _this.client.history.resolve(r);

                case 12:
                case "end":
                  return _context21.stop();
              }
            }
          }, _callee21);
        }));

        return function (_x24, _x25, _x26) {
          return _ref28.apply(this, arguments);
        };
      }(), _this.sendError = /*#__PURE__*/function () {
        var _ref29 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee22(e, t, s) {
          var r, n, a, h;
          return regenerator.wrap(function _callee22$(_context22) {
            while (1) {
              switch (_context22.prev = _context22.next) {
                case 0:
                  r = formatJsonRpcError(e, s);
                  _context22.next = 3;
                  return _this.client.core.crypto.encode(t, r);

                case 3:
                  n = _context22.sent;
                  _context22.next = 6;
                  return _this.client.history.get(t, e);

                case 6:
                  a = _context22.sent;
                  h = G$1[a.request.method].res;
                  _context22.next = 10;
                  return _this.client.core.relayer.publish(t, n, h);

                case 10:
                  _context22.next = 12;
                  return _this.client.history.resolve(r);

                case 12:
                case "end":
                  return _context22.stop();
              }
            }
          }, _callee22);
        }));

        return function (_x27, _x28, _x29) {
          return _ref29.apply(this, arguments);
        };
      }(), _this.cleanup = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee23() {
        var e, t, s;
        return regenerator.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                e = [], t = [], s = [];

                _this.client.session.getAll().forEach(function (r) {
                  xn(r.expiry) && e.push(r.topic);
                });

                _this.client.pairing.getAll().forEach(function (r) {
                  xn(r.expiry) && t.push(r.topic);
                });

                _this.client.proposal.getAll().forEach(function (r) {
                  xn(r.expiry) && s.push(r.id);
                });

                _context23.next = 6;
                return Promise.all([].concat(_toConsumableArray(e.map(_this.deleteSession)), _toConsumableArray(t.map(_this.deletePairing)), _toConsumableArray(s.map(_this.deleteProposal))));

              case 6:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23);
      })), _this.onRelayEventRequest = function (e) {
        var t = e.topic,
            s = e.payload,
            r = s.method;

        switch (r) {
          case "wc_sessionPropose":
            return _this.onSessionProposeRequest(t, s);

          case "wc_sessionSettle":
            return _this.onSessionSettleRequest(t, s);

          case "wc_sessionUpdate":
            return _this.onSessionUpdateRequest(t, s);

          case "wc_sessionExtend":
            return _this.onSessionExtendRequest(t, s);

          case "wc_sessionPing":
            return _this.onSessionPingRequest(t, s);

          case "wc_pairingPing":
            return _this.onPairingPingRequest(t, s);

          case "wc_sessionDelete":
            return _this.onSessionDeleteRequest(t, s);

          case "wc_pairingDelete":
            return _this.onPairingDeleteRequest(t, s);

          case "wc_sessionRequest":
            return _this.onSessionRequest(t, s);

          case "wc_sessionEvent":
            return _this.onSessionEventRequest(t, s);

          default:
            return _this.client.logger.info("Unsupported request method ".concat(r));
        }
      }, _this.onRelayEventResponse = /*#__PURE__*/function () {
        var _ref31 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee24(e) {
          var t, s, r;
          return regenerator.wrap(function _callee24$(_context24) {
            while (1) {
              switch (_context24.prev = _context24.next) {
                case 0:
                  t = e.topic;
                  s = e.payload;
                  _context24.next = 4;
                  return _this.client.history.get(t, s.id);

                case 4:
                  r = _context24.sent.request.method;
                  _context24.t0 = r;
                  _context24.next = _context24.t0 === "wc_sessionPropose" ? 8 : _context24.t0 === "wc_sessionSettle" ? 9 : _context24.t0 === "wc_sessionUpdate" ? 10 : _context24.t0 === "wc_sessionExtend" ? 11 : _context24.t0 === "wc_sessionPing" ? 12 : _context24.t0 === "wc_pairingPing" ? 13 : _context24.t0 === "wc_sessionRequest" ? 14 : 15;
                  break;

                case 8:
                  return _context24.abrupt("return", _this.onSessionProposeResponse(t, s));

                case 9:
                  return _context24.abrupt("return", _this.onSessionSettleResponse(t, s));

                case 10:
                  return _context24.abrupt("return", _this.onSessionUpdateResponse(t, s));

                case 11:
                  return _context24.abrupt("return", _this.onSessionExtendResponse(t, s));

                case 12:
                  return _context24.abrupt("return", _this.onSessionPingResponse(t, s));

                case 13:
                  return _context24.abrupt("return", _this.onPairingPingResponse(t, s));

                case 14:
                  return _context24.abrupt("return", _this.onSessionRequestResponse(t, s));

                case 15:
                  return _context24.abrupt("return", _this.client.logger.info("Unsupported response method ".concat(r)));

                case 16:
                case "end":
                  return _context24.stop();
              }
            }
          }, _callee24);
        }));

        return function (_x30) {
          return _ref31.apply(this, arguments);
        };
      }(), _this.onSessionProposeRequest = /*#__PURE__*/function () {
        var _ref32 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee25(e, t) {
          var s, r, n, a;
          return regenerator.wrap(function _callee25$(_context25) {
            while (1) {
              switch (_context25.prev = _context25.next) {
                case 0:
                  s = t.params, r = t.id;
                  _context25.prev = 1;

                  _this.isValidConnect(R$1({}, t.params));

                  n = jn(cjs$5.FIVE_MINUTES), a = R$1({
                    id: r,
                    pairingTopic: e,
                    expiry: n
                  }, s);
                  _context25.next = 6;
                  return _this.setProposal(r, a);

                case 6:
                  _this.client.events.emit("session_proposal", {
                    id: r,
                    params: a
                  });

                  _context25.next = 14;
                  break;

                case 9:
                  _context25.prev = 9;
                  _context25.t0 = _context25["catch"](1);
                  _context25.next = 13;
                  return _this.sendError(r, e, _context25.t0);

                case 13:
                  _this.client.logger.error(_context25.t0);

                case 14:
                case "end":
                  return _context25.stop();
              }
            }
          }, _callee25, null, [[1, 9]]);
        }));

        return function (_x31, _x32) {
          return _ref32.apply(this, arguments);
        };
      }(), _this.onSessionProposeResponse = /*#__PURE__*/function () {
        var _ref33 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee26(e, t) {
          var s, r, n, a, h, l, w;
          return regenerator.wrap(function _callee26$(_context26) {
            while (1) {
              switch (_context26.prev = _context26.next) {
                case 0:
                  s = t.id;

                  if (!isJsonRpcResult(t)) {
                    _context26.next = 22;
                    break;
                  }

                  r = t.result;

                  _this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    result: r
                  });

                  n = _this.client.proposal.get(s);

                  _this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    proposal: n
                  });

                  a = n.proposer.publicKey;

                  _this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    selfPublicKey: a
                  });

                  h = r.responderPublicKey;

                  _this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    peerPublicKey: h
                  });

                  _context26.next = 12;
                  return _this.client.core.crypto.generateSharedKey(a, h);

                case 12:
                  l = _context26.sent;

                  _this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    sessionTopic: l
                  });

                  _context26.next = 16;
                  return _this.client.core.relayer.subscribe(l);

                case 16:
                  w = _context26.sent;

                  _this.client.logger.trace({
                    type: "method",
                    method: "onSessionProposeResponse",
                    subscriptionId: w
                  });

                  _context26.next = 20;
                  return _this.activatePairing(e);

                case 20:
                  _context26.next = 27;
                  break;

                case 22:
                  _context26.t0 = isJsonRpcError(t);

                  if (!_context26.t0) {
                    _context26.next = 27;
                    break;
                  }

                  _context26.next = 26;
                  return _this.client.proposal["delete"](s, N$2("USER_DISCONNECTED"));

                case 26:
                  _this.events.emit(Ln("session_connect"), {
                    error: t.error
                  });

                case 27:
                case "end":
                  return _context26.stop();
              }
            }
          }, _callee26);
        }));

        return function (_x33, _x34) {
          return _ref33.apply(this, arguments);
        };
      }(), _this.onSessionSettleRequest = /*#__PURE__*/function () {
        var _ref34 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee27(e, t) {
          var s, r, _t$params, n, a, h, l, w;

          return regenerator.wrap(function _callee27$(_context27) {
            while (1) {
              switch (_context27.prev = _context27.next) {
                case 0:
                  s = t.id, r = t.params;
                  _context27.prev = 1;

                  _this.isValidSessionSettleRequest(r);

                  _t$params = t.params, n = _t$params.relay, a = _t$params.controller, h = _t$params.expiry, l = _t$params.namespaces, w = {
                    topic: e,
                    relay: n,
                    expiry: h,
                    namespaces: l,
                    acknowledged: !0,
                    controller: a.publicKey,
                    self: {
                      publicKey: "",
                      metadata: _this.client.metadata
                    },
                    peer: {
                      publicKey: a.publicKey,
                      metadata: a.metadata
                    }
                  };
                  _context27.next = 6;
                  return _this.sendResult(t.id, e, !0);

                case 6:
                  _this.events.emit(Ln("session_connect"), {
                    session: w
                  });

                  _context27.next = 14;
                  break;

                case 9:
                  _context27.prev = 9;
                  _context27.t0 = _context27["catch"](1);
                  _context27.next = 13;
                  return _this.sendError(s, e, _context27.t0);

                case 13:
                  _this.client.logger.error(_context27.t0);

                case 14:
                case "end":
                  return _context27.stop();
              }
            }
          }, _callee27, null, [[1, 9]]);
        }));

        return function (_x35, _x36) {
          return _ref34.apply(this, arguments);
        };
      }(), _this.onSessionSettleResponse = /*#__PURE__*/function () {
        var _ref35 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee28(e, t) {
          var s;
          return regenerator.wrap(function _callee28$(_context28) {
            while (1) {
              switch (_context28.prev = _context28.next) {
                case 0:
                  s = t.id;

                  if (!isJsonRpcResult(t)) {
                    _context28.next = 7;
                    break;
                  }

                  _context28.next = 4;
                  return _this.client.session.update(e, {
                    acknowledged: !0
                  });

                case 4:
                  _this.events.emit(Ln("session_approve", s), {});

                  _context28.next = 12;
                  break;

                case 7:
                  _context28.t0 = isJsonRpcError(t);

                  if (!_context28.t0) {
                    _context28.next = 12;
                    break;
                  }

                  _context28.next = 11;
                  return _this.client.session["delete"](e, N$2("USER_DISCONNECTED"));

                case 11:
                  _this.events.emit(Ln("session_approve", s), {
                    error: t.error
                  });

                case 12:
                case "end":
                  return _context28.stop();
              }
            }
          }, _callee28);
        }));

        return function (_x37, _x38) {
          return _ref35.apply(this, arguments);
        };
      }(), _this.onSessionUpdateRequest = /*#__PURE__*/function () {
        var _ref36 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee29(e, t) {
          var s, r;
          return regenerator.wrap(function _callee29$(_context29) {
            while (1) {
              switch (_context29.prev = _context29.next) {
                case 0:
                  s = t.params, r = t.id;
                  _context29.prev = 1;

                  _this.isValidUpdate(R$1({
                    topic: e
                  }, s));

                  _context29.next = 5;
                  return _this.client.session.update(e, {
                    namespaces: s.namespaces
                  });

                case 5:
                  _context29.next = 7;
                  return _this.sendResult(r, e, !0);

                case 7:
                  _this.client.events.emit("session_update", {
                    id: r,
                    topic: e,
                    params: s
                  });

                  _context29.next = 15;
                  break;

                case 10:
                  _context29.prev = 10;
                  _context29.t0 = _context29["catch"](1);
                  _context29.next = 14;
                  return _this.sendError(r, e, _context29.t0);

                case 14:
                  _this.client.logger.error(_context29.t0);

                case 15:
                case "end":
                  return _context29.stop();
              }
            }
          }, _callee29, null, [[1, 10]]);
        }));

        return function (_x39, _x40) {
          return _ref36.apply(this, arguments);
        };
      }(), _this.onSessionUpdateResponse = function (e, t) {
        var s = t.id;
        isJsonRpcResult(t) ? _this.events.emit(Ln("session_update", s), {}) : isJsonRpcError(t) && _this.events.emit(Ln("session_update", s), {
          error: t.error
        });
      }, _this.onSessionExtendRequest = /*#__PURE__*/function () {
        var _ref37 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee30(e, t) {
          var s;
          return regenerator.wrap(function _callee30$(_context30) {
            while (1) {
              switch (_context30.prev = _context30.next) {
                case 0:
                  s = t.id;
                  _context30.prev = 1;

                  _this.isValidExtend({
                    topic: e
                  });

                  _context30.next = 5;
                  return _this.setExpiry(e, L$2);

                case 5:
                  _context30.next = 7;
                  return _this.sendResult(s, e, !0);

                case 7:
                  _this.client.events.emit("session_extend", {
                    id: s,
                    topic: e
                  });

                  _context30.next = 15;
                  break;

                case 10:
                  _context30.prev = 10;
                  _context30.t0 = _context30["catch"](1);
                  _context30.next = 14;
                  return _this.sendError(s, e, _context30.t0);

                case 14:
                  _this.client.logger.error(_context30.t0);

                case 15:
                case "end":
                  return _context30.stop();
              }
            }
          }, _callee30, null, [[1, 10]]);
        }));

        return function (_x41, _x42) {
          return _ref37.apply(this, arguments);
        };
      }(), _this.onSessionExtendResponse = function (e, t) {
        var s = t.id;
        isJsonRpcResult(t) ? _this.events.emit(Ln("session_extend", s), {}) : isJsonRpcError(t) && _this.events.emit(Ln("session_extend", s), {
          error: t.error
        });
      }, _this.onSessionPingRequest = /*#__PURE__*/function () {
        var _ref38 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee31(e, t) {
          var s;
          return regenerator.wrap(function _callee31$(_context31) {
            while (1) {
              switch (_context31.prev = _context31.next) {
                case 0:
                  s = t.id;
                  _context31.prev = 1;

                  _this.isValidPing({
                    topic: e
                  });

                  _context31.next = 5;
                  return _this.sendResult(s, e, !0);

                case 5:
                  _this.client.events.emit("session_ping", {
                    id: s,
                    topic: e
                  });

                  _context31.next = 13;
                  break;

                case 8:
                  _context31.prev = 8;
                  _context31.t0 = _context31["catch"](1);
                  _context31.next = 12;
                  return _this.sendError(s, e, _context31.t0);

                case 12:
                  _this.client.logger.error(_context31.t0);

                case 13:
                case "end":
                  return _context31.stop();
              }
            }
          }, _callee31, null, [[1, 8]]);
        }));

        return function (_x43, _x44) {
          return _ref38.apply(this, arguments);
        };
      }(), _this.onSessionPingResponse = function (e, t) {
        var s = t.id;
        isJsonRpcResult(t) ? _this.events.emit(Ln("session_ping", s), {}) : isJsonRpcError(t) && _this.events.emit(Ln("session_ping", s), {
          error: t.error
        });
      }, _this.onPairingPingRequest = /*#__PURE__*/function () {
        var _ref39 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee32(e, t) {
          var s;
          return regenerator.wrap(function _callee32$(_context32) {
            while (1) {
              switch (_context32.prev = _context32.next) {
                case 0:
                  s = t.id;
                  _context32.prev = 1;

                  _this.isValidPing({
                    topic: e
                  });

                  _context32.next = 5;
                  return _this.sendResult(s, e, !0);

                case 5:
                  _this.client.events.emit("pairing_ping", {
                    id: s,
                    topic: e
                  });

                  _context32.next = 13;
                  break;

                case 8:
                  _context32.prev = 8;
                  _context32.t0 = _context32["catch"](1);
                  _context32.next = 12;
                  return _this.sendError(s, e, _context32.t0);

                case 12:
                  _this.client.logger.error(_context32.t0);

                case 13:
                case "end":
                  return _context32.stop();
              }
            }
          }, _callee32, null, [[1, 8]]);
        }));

        return function (_x45, _x46) {
          return _ref39.apply(this, arguments);
        };
      }(), _this.onPairingPingResponse = function (e, t) {
        var s = t.id;
        isJsonRpcResult(t) ? _this.events.emit(Ln("pairing_ping", s), {}) : isJsonRpcError(t) && _this.events.emit(Ln("pairing_ping", s), {
          error: t.error
        });
      }, _this.onSessionDeleteRequest = /*#__PURE__*/function () {
        var _ref40 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee33(e, t) {
          var s;
          return regenerator.wrap(function _callee33$(_context33) {
            while (1) {
              switch (_context33.prev = _context33.next) {
                case 0:
                  s = t.id;
                  _context33.prev = 1;

                  _this.isValidDisconnect({
                    topic: e,
                    reason: t.params
                  });

                  _context33.next = 5;
                  return _this.sendResult(s, e, !0);

                case 5:
                  _context33.next = 7;
                  return _this.deleteSession(e);

                case 7:
                  _this.client.events.emit("session_delete", {
                    id: s,
                    topic: e
                  });

                  _context33.next = 15;
                  break;

                case 10:
                  _context33.prev = 10;
                  _context33.t0 = _context33["catch"](1);
                  _context33.next = 14;
                  return _this.sendError(s, e, _context33.t0);

                case 14:
                  _this.client.logger.error(_context33.t0);

                case 15:
                case "end":
                  return _context33.stop();
              }
            }
          }, _callee33, null, [[1, 10]]);
        }));

        return function (_x47, _x48) {
          return _ref40.apply(this, arguments);
        };
      }(), _this.onPairingDeleteRequest = /*#__PURE__*/function () {
        var _ref41 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee34(e, t) {
          var s;
          return regenerator.wrap(function _callee34$(_context34) {
            while (1) {
              switch (_context34.prev = _context34.next) {
                case 0:
                  s = t.id;
                  _context34.prev = 1;

                  _this.isValidDisconnect({
                    topic: e,
                    reason: t.params
                  });

                  _context34.next = 5;
                  return _this.sendResult(s, e, !0);

                case 5:
                  _context34.next = 7;
                  return _this.deletePairing(e);

                case 7:
                  _this.client.events.emit("pairing_delete", {
                    id: s,
                    topic: e
                  });

                  _context34.next = 15;
                  break;

                case 10:
                  _context34.prev = 10;
                  _context34.t0 = _context34["catch"](1);
                  _context34.next = 14;
                  return _this.sendError(s, e, _context34.t0);

                case 14:
                  _this.client.logger.error(_context34.t0);

                case 15:
                case "end":
                  return _context34.stop();
              }
            }
          }, _callee34, null, [[1, 10]]);
        }));

        return function (_x49, _x50) {
          return _ref41.apply(this, arguments);
        };
      }(), _this.onSessionRequest = /*#__PURE__*/function () {
        var _ref42 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee35(e, t) {
          var s, r;
          return regenerator.wrap(function _callee35$(_context35) {
            while (1) {
              switch (_context35.prev = _context35.next) {
                case 0:
                  s = t.id, r = t.params;
                  _context35.prev = 1;
                  _this.isValidRequest(R$1({
                    topic: e
                  }, r)), _this.client.events.emit("session_request", {
                    id: s,
                    topic: e,
                    params: r
                  });
                  _context35.next = 10;
                  break;

                case 5:
                  _context35.prev = 5;
                  _context35.t0 = _context35["catch"](1);
                  _context35.next = 9;
                  return _this.sendError(s, e, _context35.t0);

                case 9:
                  _this.client.logger.error(_context35.t0);

                case 10:
                case "end":
                  return _context35.stop();
              }
            }
          }, _callee35, null, [[1, 5]]);
        }));

        return function (_x51, _x52) {
          return _ref42.apply(this, arguments);
        };
      }(), _this.onSessionRequestResponse = function (e, t) {
        var s = t.id;
        isJsonRpcResult(t) ? _this.events.emit(Ln("session_request", s), {
          result: t.result
        }) : isJsonRpcError(t) && _this.events.emit(Ln("session_request", s), {
          error: t.error
        });
      }, _this.onSessionEventRequest = /*#__PURE__*/function () {
        var _ref43 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee36(e, t) {
          var s, r;
          return regenerator.wrap(function _callee36$(_context36) {
            while (1) {
              switch (_context36.prev = _context36.next) {
                case 0:
                  s = t.id, r = t.params;
                  _context36.prev = 1;
                  _this.isValidEmit(R$1({
                    topic: e
                  }, r)), _this.client.events.emit("session_event", {
                    id: s,
                    topic: e,
                    params: r
                  });
                  _context36.next = 10;
                  break;

                case 5:
                  _context36.prev = 5;
                  _context36.t0 = _context36["catch"](1);
                  _context36.next = 9;
                  return _this.sendError(s, e, _context36.t0);

                case 9:
                  _this.client.logger.error(_context36.t0);

                case 10:
                case "end":
                  return _context36.stop();
              }
            }
          }, _callee36, null, [[1, 5]]);
        }));

        return function (_x53, _x54) {
          return _ref43.apply(this, arguments);
        };
      }(), _this.isValidConnect = /*#__PURE__*/function () {
        var _ref44 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee37(e) {
          var _c2, a, t, s, r, n, _c3, _a2;

          return regenerator.wrap(function _callee37$(_context37) {
            while (1) {
              switch (_context37.prev = _context37.next) {
                case 0:
                  if (ct$1(e)) {
                    _context37.next = 3;
                    break;
                  }

                  _c2 = y$2("MISSING_OR_INVALID", "connect() params: ".concat(JSON.stringify(e))), a = _c2.message;
                  throw new Error(a);

                case 3:
                  t = e.pairingTopic, s = e.requiredNamespaces, r = e.relays;
                  _context37.t0 = E$3(t);

                  if (_context37.t0) {
                    _context37.next = 8;
                    break;
                  }

                  _context37.next = 8;
                  return _this.isValidPairingTopic(t);

                case 8:
                  n = rt$2(s, "connect()");

                  if (!n) {
                    _context37.next = 11;
                    break;
                  }

                  throw new Error(n.message);

                case 11:
                  if (st$2(r, !0)) {
                    _context37.next = 14;
                    break;
                  }

                  _c3 = y$2("MISSING_OR_INVALID", "connect() relays: ".concat(r)), _a2 = _c3.message;
                  throw new Error(_a2);

                case 14:
                case "end":
                  return _context37.stop();
              }
            }
          }, _callee37);
        }));

        return function (_x55) {
          return _ref44.apply(this, arguments);
        };
      }(), _this.isValidPair = function (e) {
        if (!ct$1(e)) {
          var _c4 = y$2("MISSING_OR_INVALID", "pair() params: ".concat(e)),
              t = _c4.message;

          throw new Error(t);
        }

        if (!Xn(e.uri)) {
          var _c5 = y$2("MISSING_OR_INVALID", "pair() uri: ".concat(e.uri)),
              _t = _c5.message;

          throw new Error(_t);
        }
      }, _this.isValidApprove = /*#__PURE__*/function () {
        var _ref45 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee38(e) {
          var t, s, r, n, a, h, _c6, l;

          return regenerator.wrap(function _callee38$(_context38) {
            while (1) {
              switch (_context38.prev = _context38.next) {
                case 0:
                  if (ct$1(e)) {
                    _context38.next = 2;
                    break;
                  }

                  throw new Error(y$2("MISSING_OR_INVALID", "approve() params: ".concat(e)).message);

                case 2:
                  t = e.id, s = e.namespaces, r = e.relayProtocol;
                  _context38.next = 5;
                  return _this.isValidProposalId(t);

                case 5:
                  n = _this.client.proposal.get(t), a = ot$1(s, "approve()");

                  if (!a) {
                    _context38.next = 8;
                    break;
                  }

                  throw new Error(a.message);

                case 8:
                  h = yt(n.requiredNamespaces, s, "update()");

                  if (!h) {
                    _context38.next = 11;
                    break;
                  }

                  throw new Error(h.message);

                case 11:
                  if (d$4(r, !0)) {
                    _context38.next = 14;
                    break;
                  }

                  _c6 = y$2("MISSING_OR_INVALID", "approve() relayProtocol: ".concat(r)), l = _c6.message;
                  throw new Error(l);

                case 14:
                case "end":
                  return _context38.stop();
              }
            }
          }, _callee38);
        }));

        return function (_x56) {
          return _ref45.apply(this, arguments);
        };
      }(), _this.isValidReject = /*#__PURE__*/function () {
        var _ref46 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee39(e) {
          var _c7, r, t, s, _c8, _r2;

          return regenerator.wrap(function _callee39$(_context39) {
            while (1) {
              switch (_context39.prev = _context39.next) {
                case 0:
                  if (ct$1(e)) {
                    _context39.next = 3;
                    break;
                  }

                  _c7 = y$2("MISSING_OR_INVALID", "reject() params: ".concat(e)), r = _c7.message;
                  throw new Error(r);

                case 3:
                  t = e.id, s = e.reason;
                  _context39.next = 6;
                  return _this.isValidProposalId(t);

                case 6:
                  if (at$1(s)) {
                    _context39.next = 9;
                    break;
                  }

                  _c8 = y$2("MISSING_OR_INVALID", "reject() reason: ".concat(JSON.stringify(s))), _r2 = _c8.message;
                  throw new Error(_r2);

                case 9:
                case "end":
                  return _context39.stop();
              }
            }
          }, _callee39);
        }));

        return function (_x57) {
          return _ref46.apply(this, arguments);
        };
      }(), _this.isValidSessionSettleRequest = function (e) {
        if (!ct$1(e)) {
          var _c9 = y$2("MISSING_OR_INVALID", "onSessionSettleRequest() params: ".concat(e)),
              l = _c9.message;

          throw new Error(l);
        }

        var t = e.relay,
            s = e.controller,
            r = e.namespaces,
            n = e.expiry;

        if (!Be$1(t)) {
          var _c10 = y$2("MISSING_OR_INVALID", "onSessionSettleRequest() relay protocol should be a string"),
              _l = _c10.message;

          throw new Error(_l);
        }

        var a = tt$1(s, "onSessionSettleRequest()");
        if (a) throw new Error(a.message);
        var h = ot$1(r, "onSessionSettleRequest()");
        if (h) throw new Error(h.message);

        if (xn(n)) {
          var _c11 = y$2("EXPIRED", "onSessionSettleRequest()"),
              _l2 = _c11.message;

          throw new Error(_l2);
        }
      }, _this.isValidUpdate = /*#__PURE__*/function () {
        var _ref47 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee40(e) {
          var _c12, h, t, s, r, n, a;

          return regenerator.wrap(function _callee40$(_context40) {
            while (1) {
              switch (_context40.prev = _context40.next) {
                case 0:
                  if (ct$1(e)) {
                    _context40.next = 3;
                    break;
                  }

                  _c12 = y$2("MISSING_OR_INVALID", "update() params: ".concat(e)), h = _c12.message;
                  throw new Error(h);

                case 3:
                  t = e.topic, s = e.namespaces;
                  _context40.next = 6;
                  return _this.isValidSessionTopic(t);

                case 6:
                  r = _this.client.session.get(t), n = ot$1(s, "update()");

                  if (!n) {
                    _context40.next = 9;
                    break;
                  }

                  throw new Error(n.message);

                case 9:
                  a = yt(r.requiredNamespaces, s, "update()");

                  if (!a) {
                    _context40.next = 12;
                    break;
                  }

                  throw new Error(a.message);

                case 12:
                case "end":
                  return _context40.stop();
              }
            }
          }, _callee40);
        }));

        return function (_x58) {
          return _ref47.apply(this, arguments);
        };
      }(), _this.isValidExtend = /*#__PURE__*/function () {
        var _ref48 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee41(e) {
          var _c13, s, t;

          return regenerator.wrap(function _callee41$(_context41) {
            while (1) {
              switch (_context41.prev = _context41.next) {
                case 0:
                  if (ct$1(e)) {
                    _context41.next = 3;
                    break;
                  }

                  _c13 = y$2("MISSING_OR_INVALID", "extend() params: ".concat(e)), s = _c13.message;
                  throw new Error(s);

                case 3:
                  t = e.topic;
                  _context41.next = 6;
                  return _this.isValidSessionTopic(t);

                case 6:
                case "end":
                  return _context41.stop();
              }
            }
          }, _callee41);
        }));

        return function (_x59) {
          return _ref48.apply(this, arguments);
        };
      }(), _this.isValidRequest = /*#__PURE__*/function () {
        var _ref49 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee42(e) {
          var _c14, a, t, s, r, _this$client$session$2, n, _c15, _a3, _c16, _a4, _c17, _a5;

          return regenerator.wrap(function _callee42$(_context42) {
            while (1) {
              switch (_context42.prev = _context42.next) {
                case 0:
                  if (ct$1(e)) {
                    _context42.next = 3;
                    break;
                  }

                  _c14 = y$2("MISSING_OR_INVALID", "request() params: ".concat(e)), a = _c14.message;
                  throw new Error(a);

                case 3:
                  t = e.topic, s = e.request, r = e.chainId;
                  _context42.next = 6;
                  return _this.isValidSessionTopic(t);

                case 6:
                  _this$client$session$2 = _this.client.session.get(t), n = _this$client$session$2.namespaces;

                  if (ft(n, r)) {
                    _context42.next = 10;
                    break;
                  }

                  _c15 = y$2("MISSING_OR_INVALID", "request() chainId: ".concat(r)), _a3 = _c15.message;
                  throw new Error(_a3);

                case 10:
                  if (ut(s)) {
                    _context42.next = 13;
                    break;
                  }

                  _c16 = y$2("MISSING_OR_INVALID", "request() ".concat(JSON.stringify(s))), _a4 = _c16.message;
                  throw new Error(_a4);

                case 13:
                  if (pt$2(n, r, s.method)) {
                    _context42.next = 16;
                    break;
                  }

                  _c17 = y$2("MISSING_OR_INVALID", "request() method: ".concat(s.method)), _a5 = _c17.message;
                  throw new Error(_a5);

                case 16:
                case "end":
                  return _context42.stop();
              }
            }
          }, _callee42);
        }));

        return function (_x60) {
          return _ref49.apply(this, arguments);
        };
      }(), _this.isValidRespond = /*#__PURE__*/function () {
        var _ref50 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee43(e) {
          var _c18, r, t, s, _c19, _r3;

          return regenerator.wrap(function _callee43$(_context43) {
            while (1) {
              switch (_context43.prev = _context43.next) {
                case 0:
                  if (ct$1(e)) {
                    _context43.next = 3;
                    break;
                  }

                  _c18 = y$2("MISSING_OR_INVALID", "respond() params: ".concat(e)), r = _c18.message;
                  throw new Error(r);

                case 3:
                  t = e.topic, s = e.response;
                  _context43.next = 6;
                  return _this.isValidSessionTopic(t);

                case 6:
                  if (dt$1(s)) {
                    _context43.next = 9;
                    break;
                  }

                  _c19 = y$2("MISSING_OR_INVALID", "respond() response: ".concat(JSON.stringify(s))), _r3 = _c19.message;
                  throw new Error(_r3);

                case 9:
                case "end":
                  return _context43.stop();
              }
            }
          }, _callee43);
        }));

        return function (_x61) {
          return _ref50.apply(this, arguments);
        };
      }(), _this.isValidPing = /*#__PURE__*/function () {
        var _ref51 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee44(e) {
          var _c20, s, t;

          return regenerator.wrap(function _callee44$(_context44) {
            while (1) {
              switch (_context44.prev = _context44.next) {
                case 0:
                  if (ct$1(e)) {
                    _context44.next = 3;
                    break;
                  }

                  _c20 = y$2("MISSING_OR_INVALID", "ping() params: ".concat(e)), s = _c20.message;
                  throw new Error(s);

                case 3:
                  t = e.topic;
                  _context44.next = 6;
                  return _this.isValidSessionOrPairingTopic(t);

                case 6:
                case "end":
                  return _context44.stop();
              }
            }
          }, _callee44);
        }));

        return function (_x62) {
          return _ref51.apply(this, arguments);
        };
      }(), _this.isValidEmit = /*#__PURE__*/function () {
        var _ref52 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee45(e) {
          var _c21, a, t, s, r, _this$client$session$3, n, _c22, _a6, _c23, _a7, _c24, _a8;

          return regenerator.wrap(function _callee45$(_context45) {
            while (1) {
              switch (_context45.prev = _context45.next) {
                case 0:
                  if (ct$1(e)) {
                    _context45.next = 3;
                    break;
                  }

                  _c21 = y$2("MISSING_OR_INVALID", "emit() params: ".concat(e)), a = _c21.message;
                  throw new Error(a);

                case 3:
                  t = e.topic, s = e.event, r = e.chainId;
                  _context45.next = 6;
                  return _this.isValidSessionTopic(t);

                case 6:
                  _this$client$session$3 = _this.client.session.get(t), n = _this$client$session$3.namespaces;

                  if (ft(n, r)) {
                    _context45.next = 10;
                    break;
                  }

                  _c22 = y$2("MISSING_OR_INVALID", "emit() chainId: ".concat(r)), _a6 = _c22.message;
                  throw new Error(_a6);

                case 10:
                  if (lt$1(s)) {
                    _context45.next = 13;
                    break;
                  }

                  _c23 = y$2("MISSING_OR_INVALID", "emit() event: ".concat(JSON.stringify(s))), _a7 = _c23.message;
                  throw new Error(_a7);

                case 13:
                  if (mt(n, r, s.name)) {
                    _context45.next = 16;
                    break;
                  }

                  _c24 = y$2("MISSING_OR_INVALID", "emit() event: ".concat(JSON.stringify(s))), _a8 = _c24.message;
                  throw new Error(_a8);

                case 16:
                case "end":
                  return _context45.stop();
              }
            }
          }, _callee45);
        }));

        return function (_x63) {
          return _ref52.apply(this, arguments);
        };
      }(), _this.isValidDisconnect = /*#__PURE__*/function () {
        var _ref53 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee46(e) {
          var _c25, s, t;

          return regenerator.wrap(function _callee46$(_context46) {
            while (1) {
              switch (_context46.prev = _context46.next) {
                case 0:
                  if (ct$1(e)) {
                    _context46.next = 3;
                    break;
                  }

                  _c25 = y$2("MISSING_OR_INVALID", "disconnect() params: ".concat(e)), s = _c25.message;
                  throw new Error(s);

                case 3:
                  t = e.topic;
                  _context46.next = 6;
                  return _this.isValidSessionOrPairingTopic(t);

                case 6:
                case "end":
                  return _context46.stop();
              }
            }
          }, _callee46);
        }));

        return function (_x64) {
          return _ref53.apply(this, arguments);
        };
      }();
      return _this;
    }

    _createClass(at, [{
      key: "createPairing",
      value: function () {
        var _createPairing = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee47() {
          var i, e, t, s, r, n;
          return regenerator.wrap(function _callee47$(_context47) {
            while (1) {
              switch (_context47.prev = _context47.next) {
                case 0:
                  i = ln();
                  _context47.next = 3;
                  return this.client.core.crypto.setSymKey(i);

                case 3:
                  e = _context47.sent;
                  t = jn(cjs$5.FIVE_MINUTES);
                  s = {
                    protocol: ci
                  };
                  r = {
                    topic: e,
                    expiry: t,
                    relay: s,
                    active: !1
                  };
                  n = Jn({
                    protocol: this.client.protocol,
                    version: this.client.version,
                    topic: e,
                    symKey: i,
                    relay: s
                  });
                  _context47.next = 10;
                  return this.client.pairing.set(e, r);

                case 10:
                  _context47.next = 12;
                  return this.client.core.relayer.subscribe(e);

                case 12:
                  _context47.next = 14;
                  return this.setExpiry(e, t);

                case 14:
                  return _context47.abrupt("return", {
                    topic: e,
                    uri: n
                  });

                case 15:
                case "end":
                  return _context47.stop();
              }
            }
          }, _callee47, this);
        }));

        function createPairing() {
          return _createPairing.apply(this, arguments);
        }

        return createPairing;
      }()
    }, {
      key: "isInitialized",
      value: function isInitialized() {
        if (!this.initialized) {
          var _c26 = y$2("NOT_INITIALIZED", this.name),
              i = _c26.message;

          throw new Error(i);
        }
      }
    }, {
      key: "registerRelayerEvents",
      value: function registerRelayerEvents() {
        var _this2 = this;

        this.client.core.relayer.on(L$3.message, /*#__PURE__*/function () {
          var _ref54 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee48(i) {
            var e, t, s;
            return regenerator.wrap(function _callee48$(_context48) {
              while (1) {
                switch (_context48.prev = _context48.next) {
                  case 0:
                    e = i.topic;
                    t = i.message;
                    _context48.next = 4;
                    return _this2.client.core.crypto.decode(e, t);

                  case 4:
                    s = _context48.sent;

                    if (!isJsonRpcRequest(s)) {
                      _context48.next = 9;
                      break;
                    }

                    _this2.client.history.set(e, s), _this2.onRelayEventRequest({
                      topic: e,
                      payload: s
                    });
                    _context48.next = 14;
                    break;

                  case 9:
                    _context48.t0 = isJsonRpcResponse(s);

                    if (!_context48.t0) {
                      _context48.next = 14;
                      break;
                    }

                    _context48.next = 13;
                    return _this2.client.history.resolve(s);

                  case 13:
                    _this2.onRelayEventResponse({
                      topic: e,
                      payload: s
                    });

                  case 14:
                  case "end":
                    return _context48.stop();
                }
              }
            }, _callee48);
          }));

          return function (_x65) {
            return _ref54.apply(this, arguments);
          };
        }());
      }
    }, {
      key: "registerExpirerEvents",
      value: function registerExpirerEvents() {
        var _this3 = this;

        this.client.expirer.on(m$2.expired, /*#__PURE__*/function () {
          var _ref55 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee49(i) {
            var _$e, e, t;

            return regenerator.wrap(function _callee49$(_context49) {
              while (1) {
                switch (_context49.prev = _context49.next) {
                  case 0:
                    _$e = kn(i.target), e = _$e.topic, t = _$e.id;

                    if (!e) {
                      _context49.next = 15;
                      break;
                    }

                    if (!_this3.client.session.keys.includes(e)) {
                      _context49.next = 8;
                      break;
                    }

                    _context49.next = 5;
                    return _this3.deleteSession(e);

                  case 5:
                    _this3.client.events.emit("session_expire", {
                      topic: e
                    });

                    _context49.next = 13;
                    break;

                  case 8:
                    _context49.t0 = _this3.client.pairing.keys.includes(e);

                    if (!_context49.t0) {
                      _context49.next = 13;
                      break;
                    }

                    _context49.next = 12;
                    return _this3.deletePairing(e);

                  case 12:
                    _this3.client.events.emit("pairing_expire", {
                      topic: e
                    });

                  case 13:
                    _context49.next = 19;
                    break;

                  case 15:
                    _context49.t1 = t;

                    if (!_context49.t1) {
                      _context49.next = 19;
                      break;
                    }

                    _context49.next = 19;
                    return _this3.deleteProposal(t);

                  case 19:
                  case "end":
                    return _context49.stop();
                }
              }
            }, _callee49);
          }));

          return function (_x66) {
            return _ref55.apply(this, arguments);
          };
        }());
      }
    }, {
      key: "isValidPairingTopic",
      value: function () {
        var _isValidPairingTopic = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee50(i) {
          var _c27, e, _c28, _e2, _c29, _e3;

          return regenerator.wrap(function _callee50$(_context50) {
            while (1) {
              switch (_context50.prev = _context50.next) {
                case 0:
                  if (d$4(i, !1)) {
                    _context50.next = 3;
                    break;
                  }

                  _c27 = y$2("MISSING_OR_INVALID", "pairing topic should be a string: ".concat(i)), e = _c27.message;
                  throw new Error(e);

                case 3:
                  if (this.client.pairing.keys.includes(i)) {
                    _context50.next = 6;
                    break;
                  }

                  _c28 = y$2("NO_MATCHING_KEY", "pairing topic doesn't exist: ".concat(i)), _e2 = _c28.message;
                  throw new Error(_e2);

                case 6:
                  if (!xn(this.client.pairing.get(i).expiry)) {
                    _context50.next = 11;
                    break;
                  }

                  _context50.next = 9;
                  return this.deletePairing(i);

                case 9:
                  _c29 = y$2("EXPIRED", "pairing topic: ".concat(i)), _e3 = _c29.message;
                  throw new Error(_e3);

                case 11:
                case "end":
                  return _context50.stop();
              }
            }
          }, _callee50, this);
        }));

        function isValidPairingTopic(_x67) {
          return _isValidPairingTopic.apply(this, arguments);
        }

        return isValidPairingTopic;
      }()
    }, {
      key: "isValidSessionTopic",
      value: function () {
        var _isValidSessionTopic = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee51(i) {
          var _c30, e, _c31, _e4, _c32, _e5;

          return regenerator.wrap(function _callee51$(_context51) {
            while (1) {
              switch (_context51.prev = _context51.next) {
                case 0:
                  if (d$4(i, !1)) {
                    _context51.next = 3;
                    break;
                  }

                  _c30 = y$2("MISSING_OR_INVALID", "session topic should be a string: ".concat(i)), e = _c30.message;
                  throw new Error(e);

                case 3:
                  if (this.client.session.keys.includes(i)) {
                    _context51.next = 6;
                    break;
                  }

                  _c31 = y$2("NO_MATCHING_KEY", "session topic doesn't exist: ".concat(i)), _e4 = _c31.message;
                  throw new Error(_e4);

                case 6:
                  if (!xn(this.client.session.get(i).expiry)) {
                    _context51.next = 11;
                    break;
                  }

                  _context51.next = 9;
                  return this.deleteSession(i);

                case 9:
                  _c32 = y$2("EXPIRED", "session topic: ".concat(i)), _e5 = _c32.message;
                  throw new Error(_e5);

                case 11:
                case "end":
                  return _context51.stop();
              }
            }
          }, _callee51, this);
        }));

        function isValidSessionTopic(_x68) {
          return _isValidSessionTopic.apply(this, arguments);
        }

        return isValidSessionTopic;
      }()
    }, {
      key: "isValidSessionOrPairingTopic",
      value: function () {
        var _isValidSessionOrPairingTopic = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee52(i) {
          var _c33, e, _c34, _e6;

          return regenerator.wrap(function _callee52$(_context52) {
            while (1) {
              switch (_context52.prev = _context52.next) {
                case 0:
                  if (!this.client.session.keys.includes(i)) {
                    _context52.next = 5;
                    break;
                  }

                  _context52.next = 3;
                  return this.isValidSessionTopic(i);

                case 3:
                  _context52.next = 17;
                  break;

                case 5:
                  if (!this.client.pairing.keys.includes(i)) {
                    _context52.next = 10;
                    break;
                  }

                  _context52.next = 8;
                  return this.isValidPairingTopic(i);

                case 8:
                  _context52.next = 17;
                  break;

                case 10:
                  if (!d$4(i, !1)) {
                    _context52.next = 15;
                    break;
                  }

                  _c33 = y$2("NO_MATCHING_KEY", "session or pairing topic doesn't exist: ".concat(i)), e = _c33.message;
                  throw new Error(e);

                case 15:
                  _c34 = y$2("MISSING_OR_INVALID", "session or pairing topic should be a string: ".concat(i)), _e6 = _c34.message;
                  throw new Error(_e6);

                case 17:
                case "end":
                  return _context52.stop();
              }
            }
          }, _callee52, this);
        }));

        function isValidSessionOrPairingTopic(_x69) {
          return _isValidSessionOrPairingTopic.apply(this, arguments);
        }

        return isValidSessionOrPairingTopic;
      }()
    }, {
      key: "isValidProposalId",
      value: function () {
        var _isValidProposalId = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee53(i) {
          var _c35, e, _c36, _e7, _c37, _e8;

          return regenerator.wrap(function _callee53$(_context53) {
            while (1) {
              switch (_context53.prev = _context53.next) {
                case 0:
                  if (it$2(i)) {
                    _context53.next = 3;
                    break;
                  }

                  _c35 = y$2("MISSING_OR_INVALID", "proposal id should be a number: ".concat(i)), e = _c35.message;
                  throw new Error(e);

                case 3:
                  if (this.client.proposal.keys.includes(i)) {
                    _context53.next = 6;
                    break;
                  }

                  _c36 = y$2("NO_MATCHING_KEY", "proposal id doesn't exist: ".concat(i)), _e7 = _c36.message;
                  throw new Error(_e7);

                case 6:
                  if (!xn(this.client.proposal.get(i).expiry)) {
                    _context53.next = 11;
                    break;
                  }

                  _context53.next = 9;
                  return this.deleteProposal(i);

                case 9:
                  _c37 = y$2("EXPIRED", "proposal id: ".concat(i)), _e8 = _c37.message;
                  throw new Error(_e8);

                case 11:
                case "end":
                  return _context53.stop();
              }
            }
          }, _callee53, this);
        }));

        function isValidProposalId(_x70) {
          return _isValidProposalId.apply(this, arguments);
        }

        return isValidProposalId;
      }()
    }]);

    return at;
  }(k$4);

  var ct = /*#__PURE__*/function (_e9) {
    _inherits(ct, _e9);

    var _super2 = _createSuper(ct);

    function ct(i, e) {
      var _this4;

      _classCallCheck(this, ct);

      _this4 = _super2.call(this, i, e), _this4.core = i, _this4.logger = e, _this4.expirations = new Map(), _this4.events = new C$2.EventEmitter(), _this4.name = se, _this4.version = ie, _this4.cached = [], _this4.initialized = !1, _this4.storagePrefix = T$3, _this4.init = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee54() {
        return regenerator.wrap(function _callee54$(_context54) {
          while (1) {
            switch (_context54.prev = _context54.next) {
              case 0:
                _context54.t0 = _this4.initialized;

                if (_context54.t0) {
                  _context54.next = 9;
                  break;
                }

                _this4.logger.trace("Initialized");

                _context54.next = 5;
                return _this4.restore();

              case 5:
                _this4.cached.forEach(function (t) {
                  return _this4.expirations.set(t.target, t);
                });

                _this4.cached = [];

                _this4.registerEventListeners();

                _this4.initialized = !0;

              case 9:
              case "end":
                return _context54.stop();
            }
          }
        }, _callee54);
      })), _this4.has = function (t) {
        try {
          var s = _this4.formatTarget(t);

          return _typeof$1(_this4.getExpiration(s)) < "u";
        } catch (_unused) {
          return !1;
        }
      }, _this4.set = function (t, s) {
        _this4.isInitialized();

        var r = _this4.formatTarget(t),
            n = {
          target: r,
          expiry: s
        };

        _this4.expirations.set(r, n), _this4.checkExpiry(r, n), _this4.events.emit(m$2.created, {
          target: r,
          expiration: n
        });
      }, _this4.get = function (t) {
        _this4.isInitialized();

        var s = _this4.formatTarget(t);

        return _this4.getExpiration(s);
      }, _this4.del = function (t) {
        _this4.isInitialized();

        var s = _this4.formatTarget(t);

        if (_this4.has(s)) {
          var r = _this4.getExpiration(s);

          _this4.expirations["delete"](s), _this4.events.emit(m$2.deleted, {
            target: s,
            expiration: r
          });
        }
      }, _this4.on = function (t, s) {
        _this4.events.on(t, s);
      }, _this4.once = function (t, s) {
        _this4.events.once(t, s);
      }, _this4.off = function (t, s) {
        _this4.events.off(t, s);
      }, _this4.removeListener = function (t, s) {
        _this4.events.removeListener(t, s);
      }, _this4.logger = cjs$4.generateChildLogger(e, _this4.name);
      return _this4;
    }

    _createClass(ct, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "storageKey",
      get: function get() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
    }, {
      key: "length",
      get: function get() {
        return this.expirations.size;
      }
    }, {
      key: "keys",
      get: function get() {
        return Array.from(this.expirations.keys());
      }
    }, {
      key: "values",
      get: function get() {
        return Array.from(this.expirations.values());
      }
    }, {
      key: "formatTarget",
      value: function formatTarget(i) {
        if (typeof i == "string") return Mn(i);
        if (typeof i == "number") return Kn(i);

        var _c38 = y$2("UNKNOWN_TYPE", "Target type: ".concat(_typeof$1(i))),
            e = _c38.message;

        throw new Error(e);
      }
    }, {
      key: "setExpirations",
      value: function () {
        var _setExpirations = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee55(i) {
          return regenerator.wrap(function _callee55$(_context55) {
            while (1) {
              switch (_context55.prev = _context55.next) {
                case 0:
                  _context55.next = 2;
                  return this.core.storage.setItem(this.storageKey, i);

                case 2:
                case "end":
                  return _context55.stop();
              }
            }
          }, _callee55, this);
        }));

        function setExpirations(_x71) {
          return _setExpirations.apply(this, arguments);
        }

        return setExpirations;
      }()
    }, {
      key: "getExpirations",
      value: function () {
        var _getExpirations = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee56() {
          return regenerator.wrap(function _callee56$(_context56) {
            while (1) {
              switch (_context56.prev = _context56.next) {
                case 0:
                  _context56.next = 2;
                  return this.core.storage.getItem(this.storageKey);

                case 2:
                  return _context56.abrupt("return", _context56.sent);

                case 3:
                case "end":
                  return _context56.stop();
              }
            }
          }, _callee56, this);
        }));

        function getExpirations() {
          return _getExpirations.apply(this, arguments);
        }

        return getExpirations;
      }()
    }, {
      key: "persist",
      value: function () {
        var _persist = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee57() {
          return regenerator.wrap(function _callee57$(_context57) {
            while (1) {
              switch (_context57.prev = _context57.next) {
                case 0:
                  _context57.next = 2;
                  return this.setExpirations(this.values);

                case 2:
                  this.events.emit(m$2.sync);

                case 3:
                case "end":
                  return _context57.stop();
              }
            }
          }, _callee57, this);
        }));

        function persist() {
          return _persist.apply(this, arguments);
        }

        return persist;
      }()
    }, {
      key: "restore",
      value: function () {
        var _restore = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee58() {
          var i, _c39, e;

          return regenerator.wrap(function _callee58$(_context58) {
            while (1) {
              switch (_context58.prev = _context58.next) {
                case 0:
                  _context58.prev = 0;
                  _context58.next = 3;
                  return this.getExpirations();

                case 3:
                  i = _context58.sent;

                  if (!(_typeof$1(i) > "u" || !i.length)) {
                    _context58.next = 6;
                    break;
                  }

                  return _context58.abrupt("return");

                case 6:
                  if (!this.expirations.size) {
                    _context58.next = 9;
                    break;
                  }

                  _c39 = y$2("RESTORE_WILL_OVERRIDE", this.name), e = _c39.message;
                  throw this.logger.error(e), new Error(e);

                case 9:
                  this.cached = i, this.logger.debug("Successfully Restored expirations for ".concat(this.name)), this.logger.trace({
                    type: "method",
                    method: "restore",
                    expirations: this.values
                  });
                  _context58.next = 15;
                  break;

                case 12:
                  _context58.prev = 12;
                  _context58.t0 = _context58["catch"](0);
                  this.logger.debug("Failed to Restore expirations for ".concat(this.name)), this.logger.error(_context58.t0);

                case 15:
                case "end":
                  return _context58.stop();
              }
            }
          }, _callee58, this, [[0, 12]]);
        }));

        function restore() {
          return _restore.apply(this, arguments);
        }

        return restore;
      }()
    }, {
      key: "getExpiration",
      value: function getExpiration(i) {
        var e = this.expirations.get(i);

        if (!e) {
          var _c40 = y$2("NO_MATCHING_KEY", "".concat(this.name, ": ").concat(i)),
              t = _c40.message;

          throw this.logger.error(t), new Error(t);
        }

        return e;
      }
    }, {
      key: "checkExpiry",
      value: function checkExpiry(i, e) {
        var t = e.expiry;
        cjs$5.toMiliseconds(t) - Date.now() <= 0 && this.expire(i, e);
      }
    }, {
      key: "expire",
      value: function expire(i, e) {
        this.expirations["delete"](i), this.events.emit(m$2.expired, {
          target: i,
          expiration: e
        });
      }
    }, {
      key: "checkExpirations",
      value: function checkExpirations() {
        var _this5 = this;

        this.expirations.forEach(function (i, e) {
          return _this5.checkExpiry(e, i);
        });
      }
    }, {
      key: "registerEventListeners",
      value: function registerEventListeners() {
        var _this6 = this;

        this.core.heartbeat.on(cjs$6.HEARTBEAT_EVENTS.pulse, function () {
          return _this6.checkExpirations();
        }), this.events.on(m$2.created, function (i) {
          var e = m$2.created;
          _this6.logger.info("Emitting ".concat(e)), _this6.logger.debug({
            type: "event",
            event: e,
            data: i
          }), _this6.persist();
        }), this.events.on(m$2.expired, function (i) {
          var e = m$2.expired;
          _this6.logger.info("Emitting ".concat(e)), _this6.logger.debug({
            type: "event",
            event: e,
            data: i
          }), _this6.persist();
        }), this.events.on(m$2.deleted, function (i) {
          var e = m$2.deleted;
          _this6.logger.info("Emitting ".concat(e)), _this6.logger.debug({
            type: "event",
            event: e,
            data: i
          }), _this6.persist();
        });
      }
    }, {
      key: "isInitialized",
      value: function isInitialized() {
        if (!this.initialized) {
          var _c41 = y$2("NOT_INITIALIZED", this.name),
              i = _c41.message;

          throw new Error(i);
        }
      }
    }]);

    return ct;
  }(T$6);

  var ht = /*#__PURE__*/function (_Ee) {
    _inherits(ht, _Ee);

    var _super3 = _createSuper(ht);

    function ht(i, e) {
      var _this7;

      _classCallCheck(this, ht);

      _this7 = _super3.call(this, i, e), _this7.core = i, _this7.logger = e, _this7.records = new Map(), _this7.events = new C$2.EventEmitter(), _this7.name = re, _this7.version = ne, _this7.cached = [], _this7.initialized = !1, _this7.storagePrefix = T$3, _this7.init = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee59() {
        return regenerator.wrap(function _callee59$(_context59) {
          while (1) {
            switch (_context59.prev = _context59.next) {
              case 0:
                _context59.t0 = _this7.initialized;

                if (_context59.t0) {
                  _context59.next = 9;
                  break;
                }

                _this7.logger.trace("Initialized");

                _context59.next = 5;
                return _this7.restore();

              case 5:
                _this7.cached.forEach(function (t) {
                  return _this7.records.set(t.id, t);
                });

                _this7.cached = [];

                _this7.registerEventListeners();

                _this7.initialized = !0;

              case 9:
              case "end":
                return _context59.stop();
            }
          }
        }, _callee59);
      })), _this7.set = function (t, s, r) {
        if (_this7.isInitialized(), _this7.logger.debug("Setting JSON-RPC request history record"), _this7.logger.trace({
          type: "method",
          method: "set",
          topic: t,
          request: s,
          chainId: r
        }), _this7.records.has(s.id)) return;
        var n = {
          id: s.id,
          topic: t,
          request: {
            method: s.method,
            params: s.params || null
          },
          chainId: r
        };
        _this7.records.set(n.id, n), _this7.events.emit(_$3.created, n);
      }, _this7.resolve = /*#__PURE__*/function () {
        var _ref58 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee60(t) {
          var s;
          return regenerator.wrap(function _callee60$(_context60) {
            while (1) {
              switch (_context60.prev = _context60.next) {
                case 0:
                  if (!(_this7.isInitialized(), _this7.logger.debug("Updating JSON-RPC response history record"), _this7.logger.trace({
                    type: "method",
                    method: "update",
                    response: t
                  }), !_this7.records.has(t.id))) {
                    _context60.next = 2;
                    break;
                  }

                  return _context60.abrupt("return");

                case 2:
                  _context60.next = 4;
                  return _this7.getRecord(t.id);

                case 4:
                  s = _context60.sent;
                  _typeof$1(s.response) > "u" && (s.response = isJsonRpcError(t) ? {
                    error: t.error
                  } : {
                    result: t.result
                  }, _this7.records.set(s.id, s), _this7.events.emit(_$3.updated, s));

                case 6:
                case "end":
                  return _context60.stop();
              }
            }
          }, _callee60);
        }));

        return function (_x72) {
          return _ref58.apply(this, arguments);
        };
      }(), _this7.get = /*#__PURE__*/function () {
        var _ref59 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee61(t, s) {
          var r, _c42, n;

          return regenerator.wrap(function _callee61$(_context61) {
            while (1) {
              switch (_context61.prev = _context61.next) {
                case 0:
                  _this7.isInitialized(), _this7.logger.debug("Getting record"), _this7.logger.trace({
                    type: "method",
                    method: "get",
                    topic: t,
                    id: s
                  });
                  _context61.next = 3;
                  return _this7.getRecord(s);

                case 3:
                  r = _context61.sent;

                  if (!(r.topic !== t)) {
                    _context61.next = 7;
                    break;
                  }

                  _c42 = y$2("MISMATCHED_TOPIC", "".concat(_this7.name, ", ").concat(s)), n = _c42.message;
                  throw _this7.logger.error(n), new Error(n);

                case 7:
                  return _context61.abrupt("return", r);

                case 8:
                case "end":
                  return _context61.stop();
              }
            }
          }, _callee61);
        }));

        return function (_x73, _x74) {
          return _ref59.apply(this, arguments);
        };
      }(), _this7["delete"] = function (t, s) {
        _this7.isInitialized(), _this7.logger.debug("Deleting record"), _this7.logger.trace({
          type: "method",
          method: "delete",
          id: s
        }), _this7.values.forEach(function (r) {
          if (r.topic === t) {
            if (_typeof$1(s) < "u" && r.id !== s) return;
            _this7.records["delete"](r.id), _this7.events.emit(_$3.deleted, r);
          }
        });
      }, _this7.exists = /*#__PURE__*/function () {
        var _ref60 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee62(t, s) {
          return regenerator.wrap(function _callee62$(_context62) {
            while (1) {
              switch (_context62.prev = _context62.next) {
                case 0:
                  _this7.isInitialized();

                  if (!_this7.records.has(s)) {
                    _context62.next = 9;
                    break;
                  }

                  _context62.next = 4;
                  return _this7.getRecord(s);

                case 4:
                  _context62.t1 = _context62.sent.topic;
                  _context62.t2 = t;
                  _context62.t0 = _context62.t1 === _context62.t2;
                  _context62.next = 10;
                  break;

                case 9:
                  _context62.t0 = !1;

                case 10:
                  return _context62.abrupt("return", _context62.t0);

                case 11:
                case "end":
                  return _context62.stop();
              }
            }
          }, _callee62);
        }));

        return function (_x75, _x76) {
          return _ref60.apply(this, arguments);
        };
      }(), _this7.on = function (t, s) {
        _this7.events.on(t, s);
      }, _this7.once = function (t, s) {
        _this7.events.once(t, s);
      }, _this7.off = function (t, s) {
        _this7.events.off(t, s);
      }, _this7.removeListener = function (t, s) {
        _this7.events.removeListener(t, s);
      }, _this7.logger = cjs$4.generateChildLogger(e, _this7.name);
      return _this7;
    }

    _createClass(ht, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "storageKey",
      get: function get() {
        return this.storagePrefix + this.version + "//" + this.name;
      }
    }, {
      key: "size",
      get: function get() {
        return this.records.size;
      }
    }, {
      key: "keys",
      get: function get() {
        return Array.from(this.records.keys());
      }
    }, {
      key: "values",
      get: function get() {
        return Array.from(this.records.values());
      }
    }, {
      key: "pending",
      get: function get() {
        var i = [];
        return this.values.forEach(function (e) {
          if (_typeof$1(e.response) < "u") return;
          var t = {
            topic: e.topic,
            request: formatJsonRpcRequest(e.request.method, e.request.params, e.id),
            chainId: e.chainId
          };
          return i.push(t);
        }), i;
      }
    }, {
      key: "setJsonRpcRecords",
      value: function () {
        var _setJsonRpcRecords = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee63(i) {
          return regenerator.wrap(function _callee63$(_context63) {
            while (1) {
              switch (_context63.prev = _context63.next) {
                case 0:
                  _context63.next = 2;
                  return this.core.storage.setItem(this.storageKey, i);

                case 2:
                case "end":
                  return _context63.stop();
              }
            }
          }, _callee63, this);
        }));

        function setJsonRpcRecords(_x77) {
          return _setJsonRpcRecords.apply(this, arguments);
        }

        return setJsonRpcRecords;
      }()
    }, {
      key: "getJsonRpcRecords",
      value: function () {
        var _getJsonRpcRecords = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee64() {
          return regenerator.wrap(function _callee64$(_context64) {
            while (1) {
              switch (_context64.prev = _context64.next) {
                case 0:
                  _context64.next = 2;
                  return this.core.storage.getItem(this.storageKey);

                case 2:
                  return _context64.abrupt("return", _context64.sent);

                case 3:
                case "end":
                  return _context64.stop();
              }
            }
          }, _callee64, this);
        }));

        function getJsonRpcRecords() {
          return _getJsonRpcRecords.apply(this, arguments);
        }

        return getJsonRpcRecords;
      }()
    }, {
      key: "getRecord",
      value: function getRecord(i) {
        this.isInitialized();
        var e = this.records.get(i);

        if (!e) {
          var _c43 = y$2("NO_MATCHING_KEY", "".concat(this.name, ": ").concat(i)),
              t = _c43.message;

          throw new Error(t);
        }

        return e;
      }
    }, {
      key: "persist",
      value: function () {
        var _persist2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee65() {
          return regenerator.wrap(function _callee65$(_context65) {
            while (1) {
              switch (_context65.prev = _context65.next) {
                case 0:
                  _context65.next = 2;
                  return this.setJsonRpcRecords(this.values);

                case 2:
                  this.events.emit(_$3.sync);

                case 3:
                case "end":
                  return _context65.stop();
              }
            }
          }, _callee65, this);
        }));

        function persist() {
          return _persist2.apply(this, arguments);
        }

        return persist;
      }()
    }, {
      key: "restore",
      value: function () {
        var _restore2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee66() {
          var i, _c44, e;

          return regenerator.wrap(function _callee66$(_context66) {
            while (1) {
              switch (_context66.prev = _context66.next) {
                case 0:
                  _context66.prev = 0;
                  _context66.next = 3;
                  return this.getJsonRpcRecords();

                case 3:
                  i = _context66.sent;

                  if (!(_typeof$1(i) > "u" || !i.length)) {
                    _context66.next = 6;
                    break;
                  }

                  return _context66.abrupt("return");

                case 6:
                  if (!this.records.size) {
                    _context66.next = 9;
                    break;
                  }

                  _c44 = y$2("RESTORE_WILL_OVERRIDE", this.name), e = _c44.message;
                  throw this.logger.error(e), new Error(e);

                case 9:
                  this.cached = i, this.logger.debug("Successfully Restored records for ".concat(this.name)), this.logger.trace({
                    type: "method",
                    method: "restore",
                    records: this.values
                  });
                  _context66.next = 15;
                  break;

                case 12:
                  _context66.prev = 12;
                  _context66.t0 = _context66["catch"](0);
                  this.logger.debug("Failed to Restore records for ".concat(this.name)), this.logger.error(_context66.t0);

                case 15:
                case "end":
                  return _context66.stop();
              }
            }
          }, _callee66, this, [[0, 12]]);
        }));

        function restore() {
          return _restore2.apply(this, arguments);
        }

        return restore;
      }()
    }, {
      key: "registerEventListeners",
      value: function registerEventListeners() {
        var _this8 = this;

        this.events.on(_$3.created, function (i) {
          var e = _$3.created;
          _this8.logger.info("Emitting ".concat(e)), _this8.logger.debug({
            type: "event",
            event: e,
            record: i
          }), _this8.persist();
        }), this.events.on(_$3.updated, function (i) {
          var e = _$3.updated;
          _this8.logger.info("Emitting ".concat(e)), _this8.logger.debug({
            type: "event",
            event: e,
            record: i
          }), _this8.persist();
        }), this.events.on(_$3.deleted, function (i) {
          var e = _$3.deleted;
          _this8.logger.info("Emitting ".concat(e)), _this8.logger.debug({
            type: "event",
            event: e,
            record: i
          }), _this8.persist();
        });
      }
    }, {
      key: "isInitialized",
      value: function isInitialized() {
        if (!this.initialized) {
          var _c45 = y$2("NOT_INITIALIZED", this.name),
              i = _c45.message;

          throw new Error(i);
        }
      }
    }]);

    return ht;
  }(g$2);

  var lt = /*#__PURE__*/function (_U) {
    _inherits(lt, _U);

    var _super4 = _createSuper(lt);

    function lt(i, e) {
      var _this9;

      _classCallCheck(this, lt);

      _this9 = _super4.call(this, i, e, oe, T$3), _this9.core = i, _this9.logger = e;
      return _this9;
    }

    return _createClass(lt);
  }(Ai);

  var pt$1 = /*#__PURE__*/function (_U2) {
    _inherits(pt, _U2);

    var _super5 = _createSuper(pt);

    function pt(i, e) {
      var _this10;

      _classCallCheck(this, pt);

      _this10 = _super5.call(this, i, e, ae, T$3), _this10.core = i, _this10.logger = e;
      return _this10;
    }

    return _createClass(pt);
  }(Ai);

  var dt = /*#__PURE__*/function (_U3) {
    _inherits(dt, _U3);

    var _super6 = _createSuper(dt);

    function dt(i, e) {
      var _this11;

      _classCallCheck(this, dt);

      _this11 = _super6.call(this, i, e, ce, T$3), _this11.core = i, _this11.logger = e;
      return _this11;
    }

    return _createClass(dt);
  }(Ai);

  var z$2 = /*#__PURE__*/function (_fe) {
    _inherits(z, _fe);

    var _super7 = _createSuper(z);

    function z(i) {
      var _this12;

      _classCallCheck(this, z);

      _this12 = _super7.call(this, i), _this12.protocol = Y$1, _this12.version = X$1, _this12.name = $$2.name, _this12.events = new C$2.EventEmitter(), _this12.on = function (t, s) {
        return _this12.events.on(t, s);
      }, _this12.once = function (t, s) {
        return _this12.events.once(t, s);
      }, _this12.off = function (t, s) {
        return _this12.events.off(t, s);
      }, _this12.removeListener = function (t, s) {
        return _this12.events.removeListener(t, s);
      }, _this12.connect = /*#__PURE__*/function () {
        var _ref61 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee67(t) {
          return regenerator.wrap(function _callee67$(_context67) {
            while (1) {
              switch (_context67.prev = _context67.next) {
                case 0:
                  _context67.prev = 0;
                  _context67.next = 3;
                  return _this12.engine.connect(t);

                case 3:
                  return _context67.abrupt("return", _context67.sent);

                case 6:
                  _context67.prev = 6;
                  _context67.t0 = _context67["catch"](0);
                  throw _this12.logger.error(_context67.t0.message), _context67.t0;

                case 9:
                case "end":
                  return _context67.stop();
              }
            }
          }, _callee67, null, [[0, 6]]);
        }));

        return function (_x78) {
          return _ref61.apply(this, arguments);
        };
      }(), _this12.pair = /*#__PURE__*/function () {
        var _ref62 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee68(t) {
          return regenerator.wrap(function _callee68$(_context68) {
            while (1) {
              switch (_context68.prev = _context68.next) {
                case 0:
                  _context68.prev = 0;
                  _context68.next = 3;
                  return _this12.engine.pair(t);

                case 3:
                  return _context68.abrupt("return", _context68.sent);

                case 6:
                  _context68.prev = 6;
                  _context68.t0 = _context68["catch"](0);
                  throw _this12.logger.error(_context68.t0.message), _context68.t0;

                case 9:
                case "end":
                  return _context68.stop();
              }
            }
          }, _callee68, null, [[0, 6]]);
        }));

        return function (_x79) {
          return _ref62.apply(this, arguments);
        };
      }(), _this12.approve = /*#__PURE__*/function () {
        var _ref63 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee69(t) {
          return regenerator.wrap(function _callee69$(_context69) {
            while (1) {
              switch (_context69.prev = _context69.next) {
                case 0:
                  _context69.prev = 0;
                  _context69.next = 3;
                  return _this12.engine.approve(t);

                case 3:
                  return _context69.abrupt("return", _context69.sent);

                case 6:
                  _context69.prev = 6;
                  _context69.t0 = _context69["catch"](0);
                  throw _this12.logger.error(_context69.t0.message), _context69.t0;

                case 9:
                case "end":
                  return _context69.stop();
              }
            }
          }, _callee69, null, [[0, 6]]);
        }));

        return function (_x80) {
          return _ref63.apply(this, arguments);
        };
      }(), _this12.reject = /*#__PURE__*/function () {
        var _ref64 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee70(t) {
          return regenerator.wrap(function _callee70$(_context70) {
            while (1) {
              switch (_context70.prev = _context70.next) {
                case 0:
                  _context70.prev = 0;
                  _context70.next = 3;
                  return _this12.engine.reject(t);

                case 3:
                  return _context70.abrupt("return", _context70.sent);

                case 6:
                  _context70.prev = 6;
                  _context70.t0 = _context70["catch"](0);
                  throw _this12.logger.error(_context70.t0.message), _context70.t0;

                case 9:
                case "end":
                  return _context70.stop();
              }
            }
          }, _callee70, null, [[0, 6]]);
        }));

        return function (_x81) {
          return _ref64.apply(this, arguments);
        };
      }(), _this12.update = /*#__PURE__*/function () {
        var _ref65 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee71(t) {
          return regenerator.wrap(function _callee71$(_context71) {
            while (1) {
              switch (_context71.prev = _context71.next) {
                case 0:
                  _context71.prev = 0;
                  _context71.next = 3;
                  return _this12.engine.update(t);

                case 3:
                  return _context71.abrupt("return", _context71.sent);

                case 6:
                  _context71.prev = 6;
                  _context71.t0 = _context71["catch"](0);
                  throw _this12.logger.error(_context71.t0.message), _context71.t0;

                case 9:
                case "end":
                  return _context71.stop();
              }
            }
          }, _callee71, null, [[0, 6]]);
        }));

        return function (_x82) {
          return _ref65.apply(this, arguments);
        };
      }(), _this12.extend = /*#__PURE__*/function () {
        var _ref66 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee72(t) {
          return regenerator.wrap(function _callee72$(_context72) {
            while (1) {
              switch (_context72.prev = _context72.next) {
                case 0:
                  _context72.prev = 0;
                  _context72.next = 3;
                  return _this12.engine.extend(t);

                case 3:
                  return _context72.abrupt("return", _context72.sent);

                case 6:
                  _context72.prev = 6;
                  _context72.t0 = _context72["catch"](0);
                  throw _this12.logger.error(_context72.t0.message), _context72.t0;

                case 9:
                case "end":
                  return _context72.stop();
              }
            }
          }, _callee72, null, [[0, 6]]);
        }));

        return function (_x83) {
          return _ref66.apply(this, arguments);
        };
      }(), _this12.request = /*#__PURE__*/function () {
        var _ref67 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee73(t) {
          return regenerator.wrap(function _callee73$(_context73) {
            while (1) {
              switch (_context73.prev = _context73.next) {
                case 0:
                  _context73.prev = 0;
                  _context73.next = 3;
                  return _this12.engine.request(t);

                case 3:
                  return _context73.abrupt("return", _context73.sent);

                case 6:
                  _context73.prev = 6;
                  _context73.t0 = _context73["catch"](0);
                  throw _this12.logger.error(_context73.t0.message), _context73.t0;

                case 9:
                case "end":
                  return _context73.stop();
              }
            }
          }, _callee73, null, [[0, 6]]);
        }));

        return function (_x84) {
          return _ref67.apply(this, arguments);
        };
      }(), _this12.respond = /*#__PURE__*/function () {
        var _ref68 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee74(t) {
          return regenerator.wrap(function _callee74$(_context74) {
            while (1) {
              switch (_context74.prev = _context74.next) {
                case 0:
                  _context74.prev = 0;
                  _context74.next = 3;
                  return _this12.engine.respond(t);

                case 3:
                  return _context74.abrupt("return", _context74.sent);

                case 6:
                  _context74.prev = 6;
                  _context74.t0 = _context74["catch"](0);
                  throw _this12.logger.error(_context74.t0.message), _context74.t0;

                case 9:
                case "end":
                  return _context74.stop();
              }
            }
          }, _callee74, null, [[0, 6]]);
        }));

        return function (_x85) {
          return _ref68.apply(this, arguments);
        };
      }(), _this12.ping = /*#__PURE__*/function () {
        var _ref69 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee75(t) {
          return regenerator.wrap(function _callee75$(_context75) {
            while (1) {
              switch (_context75.prev = _context75.next) {
                case 0:
                  _context75.prev = 0;
                  _context75.next = 3;
                  return _this12.engine.ping(t);

                case 3:
                  return _context75.abrupt("return", _context75.sent);

                case 6:
                  _context75.prev = 6;
                  _context75.t0 = _context75["catch"](0);
                  throw _this12.logger.error(_context75.t0.message), _context75.t0;

                case 9:
                case "end":
                  return _context75.stop();
              }
            }
          }, _callee75, null, [[0, 6]]);
        }));

        return function (_x86) {
          return _ref69.apply(this, arguments);
        };
      }(), _this12.emit = /*#__PURE__*/function () {
        var _ref70 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee76(t) {
          return regenerator.wrap(function _callee76$(_context76) {
            while (1) {
              switch (_context76.prev = _context76.next) {
                case 0:
                  _context76.prev = 0;
                  _context76.next = 3;
                  return _this12.engine.emit(t);

                case 3:
                  return _context76.abrupt("return", _context76.sent);

                case 6:
                  _context76.prev = 6;
                  _context76.t0 = _context76["catch"](0);
                  throw _this12.logger.error(_context76.t0.message), _context76.t0;

                case 9:
                case "end":
                  return _context76.stop();
              }
            }
          }, _callee76, null, [[0, 6]]);
        }));

        return function (_x87) {
          return _ref70.apply(this, arguments);
        };
      }(), _this12.disconnect = /*#__PURE__*/function () {
        var _ref71 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee77(t) {
          return regenerator.wrap(function _callee77$(_context77) {
            while (1) {
              switch (_context77.prev = _context77.next) {
                case 0:
                  _context77.prev = 0;
                  _context77.next = 3;
                  return _this12.engine.disconnect(t);

                case 3:
                  return _context77.abrupt("return", _context77.sent);

                case 6:
                  _context77.prev = 6;
                  _context77.t0 = _context77["catch"](0);
                  throw _this12.logger.error(_context77.t0.message), _context77.t0;

                case 9:
                case "end":
                  return _context77.stop();
              }
            }
          }, _callee77, null, [[0, 6]]);
        }));

        return function (_x88) {
          return _ref71.apply(this, arguments);
        };
      }(), _this12.find = function (t) {
        try {
          return _this12.engine.find(t);
        } catch (s) {
          throw _this12.logger.error(s.message), s;
        }
      }, _this12.name = (i === null || i === void 0 ? void 0 : i.name) || $$2.name, _this12.metadata = (i === null || i === void 0 ? void 0 : i.metadata) || In();
      var e = _typeof$1(i === null || i === void 0 ? void 0 : i.logger) < "u" && typeof (i === null || i === void 0 ? void 0 : i.logger) != "string" ? i.logger : browser$3(cjs$4.getDefaultLoggerOptions({
        level: (i === null || i === void 0 ? void 0 : i.logger) || $$2.logger
      }));
      _this12.core = (i === null || i === void 0 ? void 0 : i.core) || new zi(i), _this12.logger = cjs$4.generateChildLogger(e, _this12.name), _this12.pairing = new lt(_this12.core, _this12.logger), _this12.session = new dt(_this12.core, _this12.logger), _this12.proposal = new pt$1(_this12.core, _this12.logger), _this12.history = new ht(_this12.core, _this12.logger), _this12.expirer = new ct(_this12.core, _this12.logger), _this12.engine = new at(_assertThisInitialized(_this12));
      return _this12;
    }

    _createClass(z, [{
      key: "context",
      get: function get() {
        return cjs$4.getLoggerContext(this.logger);
      }
    }, {
      key: "initialize",
      value: function () {
        var _initialize = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee78() {
          return regenerator.wrap(function _callee78$(_context78) {
            while (1) {
              switch (_context78.prev = _context78.next) {
                case 0:
                  this.logger.trace("Initialized");
                  _context78.prev = 1;
                  _context78.next = 4;
                  return this.core.start();

                case 4:
                  _context78.next = 6;
                  return this.pairing.init();

                case 6:
                  _context78.next = 8;
                  return this.session.init();

                case 8:
                  _context78.next = 10;
                  return this.proposal.init();

                case 10:
                  _context78.next = 12;
                  return this.history.init();

                case 12:
                  _context78.next = 14;
                  return this.expirer.init();

                case 14:
                  _context78.next = 16;
                  return this.engine.init();

                case 16:
                  this.logger.info("SignClient Initilization Success");
                  _context78.next = 22;
                  break;

                case 19:
                  _context78.prev = 19;
                  _context78.t0 = _context78["catch"](1);
                  throw this.logger.info("SignClient Initilization Failure"), this.logger.error(_context78.t0.message), _context78.t0;

                case 22:
                case "end":
                  return _context78.stop();
              }
            }
          }, _callee78, this, [[1, 19]]);
        }));

        function initialize() {
          return _initialize.apply(this, arguments);
        }

        return initialize;
      }()
    }], [{
      key: "init",
      value: function () {
        var _init = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee79(i) {
          var e;
          return regenerator.wrap(function _callee79$(_context79) {
            while (1) {
              switch (_context79.prev = _context79.next) {
                case 0:
                  e = new z(i);
                  _context79.next = 3;
                  return e.initialize();

                case 3:
                  return _context79.abrupt("return", e);

                case 4:
                case "end":
                  return _context79.stop();
              }
            }
          }, _callee79);
        }));

        function init(_x89) {
          return _init.apply(this, arguments);
        }

        return init;
      }()
    }]);

    return z;
  }(C$4);

  var __spreadArrays = undefined && undefined.__spreadArrays || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
      s += arguments[i].length;
    }

    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
        r[k] = a[j];
      }
    }

    return r;
  };

  var BrowserInfo =
  /** @class */
  function () {
    function BrowserInfo(name, version, os) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.type = 'browser';
    }

    return BrowserInfo;
  }();

  var NodeInfo =
  /** @class */
  function () {
    function NodeInfo(version) {
      this.version = version;
      this.type = 'node';
      this.name = 'node';
      this.os = process.platform;
    }

    return NodeInfo;
  }();

  var SearchBotDeviceInfo =
  /** @class */
  function () {
    function SearchBotDeviceInfo(name, version, os, bot) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.bot = bot;
      this.type = 'bot-device';
    }

    return SearchBotDeviceInfo;
  }();

  var BotInfo =
  /** @class */
  function () {
    function BotInfo() {
      this.type = 'bot';
      this.bot = true; // NOTE: deprecated test name instead

      this.name = 'bot';
      this.version = null;
      this.os = null;
    }

    return BotInfo;
  }();

  var ReactNativeInfo =
  /** @class */
  function () {
    function ReactNativeInfo() {
      this.type = 'react-native';
      this.name = 'react-native';
      this.version = null;
      this.os = null;
    }

    return ReactNativeInfo;
  }();

  var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
  var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
  var REQUIRED_VERSION_PARTS = 3;
  var userAgentRules = [['aol', /AOLShield\/([0-9\._]+)/], ['edge', /Edge\/([0-9\._]+)/], ['edge-ios', /EdgiOS\/([0-9\._]+)/], ['yandexbrowser', /YaBrowser\/([0-9\._]+)/], ['kakaotalk', /KAKAOTALK\s([0-9\.]+)/], ['samsung', /SamsungBrowser\/([0-9\.]+)/], ['silk', /\bSilk\/([0-9._-]+)\b/], ['miui', /MiuiBrowser\/([0-9\.]+)$/], ['beaker', /BeakerBrowser\/([0-9\.]+)/], ['edge-chromium', /EdgA?\/([0-9\.]+)/], ['chromium-webview', /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/], ['phantomjs', /PhantomJS\/([0-9\.]+)(:?\s|$)/], ['crios', /CriOS\/([0-9\.]+)(:?\s|$)/], ['firefox', /Firefox\/([0-9\.]+)(?:\s|$)/], ['fxios', /FxiOS\/([0-9\.]+)/], ['opera-mini', /Opera Mini.*Version\/([0-9\.]+)/], ['opera', /Opera\/([0-9\.]+)(?:\s|$)/], ['opera', /OPR\/([0-9\.]+)(:?\s|$)/], ['ie', /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/], ['ie', /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/], ['ie', /MSIE\s(7\.0)/], ['bb10', /BB10;\sTouch.*Version\/([0-9\.]+)/], ['android', /Android\s([0-9\.]+)/], ['ios', /Version\/([0-9\._]+).*Mobile.*Safari.*/], ['safari', /Version\/([0-9\._]+).*Safari/], ['facebook', /FBAV\/([0-9\.]+)/], ['instagram', /Instagram\s([0-9\.]+)/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Mobile/], ['ios-webview', /AppleWebKit\/([0-9\.]+).*Gecko\)$/], ['searchbot', SEARCHBOX_UA_REGEX]];
  var operatingSystemRules = [['iOS', /iP(hone|od|ad)/], ['Android OS', /Android/], ['BlackBerry OS', /BlackBerry|BB10/], ['Windows Mobile', /IEMobile/], ['Amazon OS', /Kindle/], ['Windows 3.11', /Win16/], ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/], ['Windows 98', /(Windows 98)|(Win98)/], ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/], ['Windows XP', /(Windows NT 5.1)|(Windows XP)/], ['Windows Server 2003', /(Windows NT 5.2)/], ['Windows Vista', /(Windows NT 6.0)/], ['Windows 7', /(Windows NT 6.1)/], ['Windows 8', /(Windows NT 6.2)/], ['Windows 8.1', /(Windows NT 6.3)/], ['Windows 10', /(Windows NT 10.0)/], ['Windows ME', /Windows ME/], ['Open BSD', /OpenBSD/], ['Sun OS', /SunOS/], ['Chrome OS', /CrOS/], ['Linux', /(Linux)|(X11)/], ['Mac OS', /(Mac_PowerPC)|(Macintosh)/], ['QNX', /QNX/], ['BeOS', /BeOS/], ['OS/2', /OS\/2/]];
  function detect(userAgent) {
    if (!!userAgent) {
      return parseUserAgent(userAgent);
    }

    if (typeof document === 'undefined' && typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
      return new ReactNativeInfo();
    }

    if (typeof navigator !== 'undefined') {
      return parseUserAgent(navigator.userAgent);
    }

    return getNodeVersion();
  }

  function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return ua !== '' && userAgentRules.reduce(function (matched, _a) {
      var browser = _a[0],
          regex = _a[1];

      if (matched) {
        return matched;
      }

      var uaMatch = regex.exec(ua);
      return !!uaMatch && [browser, uaMatch];
    }, false);
  }
  function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);

    if (!matchedRule) {
      return null;
    }

    var name = matchedRule[0],
        match = matchedRule[1];

    if (name === 'searchbot') {
      return new BotInfo();
    }

    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);

    if (versionParts) {
      if (versionParts.length < REQUIRED_VERSION_PARTS) {
        versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
      }
    } else {
      versionParts = [];
    }

    var version = versionParts.join('.');
    var os = detectOS$1(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);

    if (searchBotMatch && searchBotMatch[1]) {
      return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }

    return new BrowserInfo(name, version, os);
  }
  function detectOS$1(ua) {
    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
      var _a = operatingSystemRules[ii],
          os = _a[0],
          regex = _a[1];
      var match = regex.exec(ua);

      if (match) {
        return os;
      }
    }

    return null;
  }
  function getNodeVersion() {
    var isNode = typeof process !== 'undefined' && process.version;
    return isNode ? new NodeInfo(process.version.slice(1)) : null;
  }

  function createVersionParts(count) {
    var output = [];

    for (var ii = 0; ii < count; ii++) {
      output.push('0');
    }

    return output;
  }

  function detectEnv(userAgent) {
    return detect(userAgent);
  }
  function detectOS() {
    var env = detectEnv();
    return env && env.os ? env.os : undefined;
  }
  function isAndroid$1() {
    var os = detectOS();
    return os ? os.toLowerCase().includes("android") : false;
  }
  function isIOS$1() {
    var os = detectOS();
    return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
  }
  function isMobile$1() {
    var os = detectOS();
    return os ? isAndroid$1() || isIOS$1() : false;
  }
  function isNode$1() {
    var env = detectEnv();
    var result = env && env.name ? env.name.toLowerCase() === "node" : false;
    return result;
  }
  function isBrowser() {
    var result = !isNode$1() && !!getNavigator();
    return result;
  }
  var getFromWindow = getFromWindow_1;
  var getFromWindowOrThrow = getFromWindowOrThrow_1;
  var getDocumentOrThrow = getDocumentOrThrow_1;
  var getDocument = getDocument_1;
  var getNavigatorOrThrow = getNavigatorOrThrow_1;
  var getNavigator = getNavigator_1;
  var getLocationOrThrow = getLocationOrThrow_1;
  var getLocation = getLocation_1;
  var getCryptoOrThrow = getCryptoOrThrow_1;
  var getCrypto = getCrypto_1;
  var getLocalStorageOrThrow = getLocalStorageOrThrow_1;
  var getLocalStorage = getLocalStorage_1;
  function getClientMeta() {
    return getWindowMetadata_1();
  }

  var safeJsonParse = safeJsonParse$1;
  var safeJsonStringify = safeJsonStringify$1;

  function setLocal(key, data) {
    var raw = safeJsonStringify(data);
    var local = getLocalStorage();

    if (local) {
      local.setItem(key, raw);
    }
  }
  function getLocal(key) {
    var data = null;
    var raw = null;
    var local = getLocalStorage();

    if (local) {
      raw = local.getItem(key);
    }

    data = raw ? safeJsonParse(raw) : raw;
    return data;
  }
  function removeLocal(key) {
    var local = getLocalStorage();

    if (local) {
      local.removeItem(key);
    }
  }

  var mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";
  function formatIOSMobile(uri, entry) {
    var encodedUri = encodeURIComponent(uri);
    return entry.universalLink ? "".concat(entry.universalLink, "/wc?uri=").concat(encodedUri) : entry.deepLink ? "".concat(entry.deepLink).concat(entry.deepLink.endsWith(":") ? "//" : "/", "wc?uri=").concat(encodedUri) : "";
  }
  function saveMobileLinkInfo(data) {
    var focusUri = data.href.split("?")[0];
    setLocal(mobileLinkChoiceKey, Object.assign(Object.assign({}, data), {
      href: focusUri
    }));
  }
  function getMobileRegistryEntry(registry, name) {
    return registry.filter(function (entry) {
      return entry.name.toLowerCase().includes(name.toLowerCase());
    })[0];
  }
  function getMobileLinkRegistry(registry, whitelist) {
    var links = registry;

    if (whitelist) {
      links = whitelist.map(function (name) {
        return getMobileRegistryEntry(registry, name);
      }).filter(Boolean);
    }

    return links;
  }

  var API_URL = "https://registry.walletconnect.com";
  function getWalletRegistryUrl() {
    return API_URL + "/api/v2/wallets";
  }
  function getDappRegistryUrl() {
    return API_URL + "/api/v2/dapps";
  }
  function formatMobileRegistryEntry(entry) {
    var platform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "mobile";

    var _a;

    return {
      name: entry.name || "",
      shortName: entry.metadata.shortName || "",
      color: entry.metadata.colors.primary || "",
      logo: (_a = entry.image_url.sm) !== null && _a !== void 0 ? _a : "",
      universalLink: entry[platform].universal || "",
      deepLink: entry[platform]["native"] || ""
    };
  }
  function formatMobileRegistry(registry) {
    var platform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "mobile";
    return Object.values(registry).filter(function (entry) {
      return !!entry[platform].universal || !!entry[platform]["native"];
    }).map(function (entry) {
      return formatMobileRegistryEntry(entry, platform);
    });
  }

  var esm = /*#__PURE__*/Object.freeze({
    __proto__: null,
    detectEnv: detectEnv,
    detectOS: detectOS,
    isAndroid: isAndroid$1,
    isIOS: isIOS$1,
    isMobile: isMobile$1,
    isNode: isNode$1,
    isBrowser: isBrowser,
    getFromWindow: getFromWindow,
    getFromWindowOrThrow: getFromWindowOrThrow,
    getDocumentOrThrow: getDocumentOrThrow,
    getDocument: getDocument,
    getNavigatorOrThrow: getNavigatorOrThrow,
    getNavigator: getNavigator,
    getLocationOrThrow: getLocationOrThrow,
    getLocation: getLocation,
    getCryptoOrThrow: getCryptoOrThrow,
    getCrypto: getCrypto,
    getLocalStorageOrThrow: getLocalStorageOrThrow,
    getLocalStorage: getLocalStorage,
    getClientMeta: getClientMeta,
    safeJsonParse: safeJsonParse,
    safeJsonStringify: safeJsonStringify,
    setLocal: setLocal,
    getLocal: getLocal,
    removeLocal: removeLocal,
    mobileLinkChoiceKey: mobileLinkChoiceKey,
    formatIOSMobile: formatIOSMobile,
    saveMobileLinkInfo: saveMobileLinkInfo,
    getMobileRegistryEntry: getMobileRegistryEntry,
    getMobileLinkRegistry: getMobileLinkRegistry,
    getWalletRegistryUrl: getWalletRegistryUrl,
    getDappRegistryUrl: getDappRegistryUrl,
    formatMobileRegistryEntry: formatMobileRegistryEntry,
    formatMobileRegistry: formatMobileRegistry
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(esm);

  var browser = {};

  // standard global objects
  // https://github.com/soldair/node-qrcode/issues/157

  var canPromise$1 = function canPromise() {
    return typeof Promise === 'function' && Promise.prototype && Promise.prototype.then;
  };

  var qrcode = {};

  var typedarrayBuffer = {};

  var toString = {}.toString;

  var isarray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  /**
   * Implementation of a subset of node.js Buffer methods for the browser.
   * Based on https://github.com/feross/buffer
   */

  var isArray$1 = isarray;

  function typedArraySupport() {
    // Can typed array instances be augmented?
    try {
      var arr = new Uint8Array(1);
      arr.__proto__ = {
        __proto__: Uint8Array.prototype,
        foo: function foo() {
          return 42;
        }
      };
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }

  Buffer$1.TYPED_ARRAY_SUPPORT = typedArraySupport();
  var K_MAX_LENGTH = Buffer$1.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;

  function Buffer$1(arg, offset, length) {
    if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
      return new Buffer$1(arg, offset, length);
    }

    if (typeof arg === 'number') {
      return allocUnsafe(this, arg);
    }

    return from(this, arg, offset, length);
  }

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    Buffer$1.prototype.__proto__ = Uint8Array.prototype;
    Buffer$1.__proto__ = Uint8Array; // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97

    if (typeof Symbol !== 'undefined' && Symbol.species && Buffer$1[Symbol.species] === Buffer$1) {
      Object.defineProperty(Buffer$1, Symbol.species, {
        value: null,
        configurable: true,
        enumerable: false,
        writable: false
      });
    }
  }

  function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }

    return length | 0;
  }

  function isnan(val) {
    return val !== val; // eslint-disable-line no-self-compare
  }

  function createBuffer(that, length) {
    var buf;

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      buf = new Uint8Array(length);
      buf.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      buf = that;

      if (buf === null) {
        buf = new Buffer$1(length);
      }

      buf.length = length;
    }

    return buf;
  }

  function allocUnsafe(that, size) {
    var buf = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

    if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        buf[i] = 0;
      }
    }

    return buf;
  }

  function fromString(that, string) {
    var length = byteLength(string) | 0;
    var buf = createBuffer(that, length);
    var actual = buf.write(string);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      buf = buf.slice(0, actual);
    }

    return buf;
  }

  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(that, length);

    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }

    return buf;
  }

  function fromArrayBuffer(that, array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds');
    }

    var buf;

    if (byteOffset === undefined && length === undefined) {
      buf = new Uint8Array(array);
    } else if (length === undefined) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      buf.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      buf = fromArrayLike(that, buf);
    }

    return buf;
  }

  function fromObject(that, obj) {
    if (Buffer$1.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(that, len);

      if (buf.length === 0) {
        return buf;
      }

      obj.copy(buf, 0, 0, len);
      return buf;
    }

    if (obj) {
      if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0);
        }

        return fromArrayLike(that, obj);
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i); // is surrogate component

      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } // valid lead


          leadSurrogate = codePoint;
          continue;
        } // 2 leads in a row


        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        } // valid surrogate pair


        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null; // encode utf8

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function byteLength(string) {
    if (Buffer$1.isBuffer(string)) {
      return string.length;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0;
    return utf8ToBytes(string).length;
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function from(that, value, offset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number');
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, offset, length);
    }

    if (typeof value === 'string') {
      return fromString(that, value);
    }

    return fromObject(that, value);
  }

  Buffer$1.prototype.write = function write(string, offset, length) {
    // Buffer#write(string)
    if (offset === undefined) {
      length = this.length;
      offset = 0; // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      length = this.length;
      offset = 0; // Buffer#write(string, offset[, length])
    } else if (isFinite(offset)) {
      offset = offset | 0;

      if (isFinite(length)) {
        length = length | 0;
      } else {
        length = undefined;
      }
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    return utf8Write(this, string, offset, length);
  };

  Buffer$1.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf;

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

      newBuf.__proto__ = Buffer$1.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$1(sliceLen, undefined);

      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf;
  };

  Buffer$1.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }

    return len;
  };

  Buffer$1.prototype.fill = function fill(val, start, end) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        end = this.length;
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (code < 256) {
          val = code;
        }
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } // Invalid ranges are not set to a default, so can range check early.


    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer$1.isBuffer(val) ? val : new Buffer$1(val);
      var len = bytes.length;

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  };

  Buffer$1.concat = function concat(list, length) {
    if (!isArray$1(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return createBuffer(null, 0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = allocUnsafe(null, length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (!Buffer$1.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      buf.copy(buffer, pos);
      pos += buf.length;
    }

    return buffer;
  };

  Buffer$1.byteLength = byteLength;
  Buffer$1.prototype._isBuffer = true;

  Buffer$1.isBuffer = function isBuffer(b) {
    return !!(b != null && b._isBuffer);
  };

  typedarrayBuffer.alloc = function (size) {
    var buffer = new Buffer$1(size);
    buffer.fill(0);
    return buffer;
  };

  typedarrayBuffer.from = function (data) {
    return new Buffer$1(data);
  };

  var utils$1 = {};

  var toSJISFunction;
  var CODEWORDS_COUNT = [0, // Not used
  26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
  /**
   * Returns the QR Code size for the specified version
   *
   * @param  {Number} version QR Code version
   * @return {Number}         size of QR code
   */

  utils$1.getSymbolSize = function getSymbolSize(version) {
    if (!version) throw new Error('"version" cannot be null or undefined');
    if (version < 1 || version > 40) throw new Error('"version" should be in range from 1 to 40');
    return version * 4 + 17;
  };
  /**
   * Returns the total number of codewords used to store data and EC information.
   *
   * @param  {Number} version QR Code version
   * @return {Number}         Data length in bits
   */


  utils$1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
    return CODEWORDS_COUNT[version];
  };
  /**
   * Encode data with Bose-Chaudhuri-Hocquenghem
   *
   * @param  {Number} data Value to encode
   * @return {Number}      Encoded value
   */


  utils$1.getBCHDigit = function (data) {
    var digit = 0;

    while (data !== 0) {
      digit++;
      data >>>= 1;
    }

    return digit;
  };

  utils$1.setToSJISFunction = function setToSJISFunction(f) {
    if (typeof f !== 'function') {
      throw new Error('"toSJISFunc" is not a valid function.');
    }

    toSJISFunction = f;
  };

  utils$1.isKanjiModeEnabled = function () {
    return typeof toSJISFunction !== 'undefined';
  };

  utils$1.toSJIS = function toSJIS(kanji) {
    return toSJISFunction(kanji);
  };

  var errorCorrectionLevel = {};

  (function (exports) {
    exports.L = {
      bit: 1
    };
    exports.M = {
      bit: 0
    };
    exports.Q = {
      bit: 3
    };
    exports.H = {
      bit: 2
    };

    function fromString(string) {
      if (typeof string !== 'string') {
        throw new Error('Param is not a string');
      }

      var lcStr = string.toLowerCase();

      switch (lcStr) {
        case 'l':
        case 'low':
          return exports.L;

        case 'm':
        case 'medium':
          return exports.M;

        case 'q':
        case 'quartile':
          return exports.Q;

        case 'h':
        case 'high':
          return exports.H;

        default:
          throw new Error('Unknown EC Level: ' + string);
      }
    }

    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== 'undefined' && level.bit >= 0 && level.bit < 4;
    };

    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }

      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  })(errorCorrectionLevel);

  function BitBuffer$1() {
    this.buffer = [];
    this.length = 0;
  }

  BitBuffer$1.prototype = {
    get: function get(index) {
      var bufIndex = Math.floor(index / 8);
      return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
    },
    put: function put(num, length) {
      for (var i = 0; i < length; i++) {
        this.putBit((num >>> length - i - 1 & 1) === 1);
      }
    },
    getLengthInBits: function getLengthInBits() {
      return this.length;
    },
    putBit: function putBit(bit) {
      var bufIndex = Math.floor(this.length / 8);

      if (this.buffer.length <= bufIndex) {
        this.buffer.push(0);
      }

      if (bit) {
        this.buffer[bufIndex] |= 0x80 >>> this.length % 8;
      }

      this.length++;
    }
  };
  var bitBuffer = BitBuffer$1;

  var BufferUtil$4 = typedarrayBuffer;
  /**
   * Helper class to handle QR Code symbol modules
   *
   * @param {Number} size Symbol size
   */

  function BitMatrix$1(size) {
    if (!size || size < 1) {
      throw new Error('BitMatrix size must be defined and greater than 0');
    }

    this.size = size;
    this.data = BufferUtil$4.alloc(size * size);
    this.reservedBit = BufferUtil$4.alloc(size * size);
  }
  /**
   * Set bit value at specified location
   * If reserved flag is set, this bit will be ignored during masking process
   *
   * @param {Number}  row
   * @param {Number}  col
   * @param {Boolean} value
   * @param {Boolean} reserved
   */


  BitMatrix$1.prototype.set = function (row, col, value, reserved) {
    var index = row * this.size + col;
    this.data[index] = value;
    if (reserved) this.reservedBit[index] = true;
  };
  /**
   * Returns bit value at specified location
   *
   * @param  {Number}  row
   * @param  {Number}  col
   * @return {Boolean}
   */


  BitMatrix$1.prototype.get = function (row, col) {
    return this.data[row * this.size + col];
  };
  /**
   * Applies xor operator at specified location
   * (used during masking process)
   *
   * @param {Number}  row
   * @param {Number}  col
   * @param {Boolean} value
   */


  BitMatrix$1.prototype.xor = function (row, col, value) {
    this.data[row * this.size + col] ^= value;
  };
  /**
   * Check if bit at specified location is reserved
   *
   * @param {Number}   row
   * @param {Number}   col
   * @return {Boolean}
   */


  BitMatrix$1.prototype.isReserved = function (row, col) {
    return this.reservedBit[row * this.size + col];
  };

  var bitMatrix = BitMatrix$1;

  var alignmentPattern = {};

  /**
   * Alignment pattern are fixed reference pattern in defined positions
   * in a matrix symbology, which enables the decode software to re-synchronise
   * the coordinate mapping of the image modules in the event of moderate amounts
   * of distortion of the image.
   *
   * Alignment patterns are present only in QR Code symbols of version 2 or larger
   * and their number depends on the symbol version.
   */

  (function (exports) {
    var getSymbolSize = utils$1.getSymbolSize;
    /**
     * Calculate the row/column coordinates of the center module of each alignment pattern
     * for the specified QR Code version.
     *
     * The alignment patterns are positioned symmetrically on either side of the diagonal
     * running from the top left corner of the symbol to the bottom right corner.
     *
     * Since positions are simmetrical only half of the coordinates are returned.
     * Each item of the array will represent in turn the x and y coordinate.
     * @see {@link getPositions}
     *
     * @param  {Number} version QR Code version
     * @return {Array}          Array of coordinate
     */

    exports.getRowColCoords = function getRowColCoords(version) {
      if (version === 1) return [];
      var posCount = Math.floor(version / 7) + 2;
      var size = getSymbolSize(version);
      var intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      var positions = [size - 7]; // Last coord is always (size - 7)

      for (var i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }

      positions.push(6); // First coord is always 6

      return positions.reverse();
    };
    /**
     * Returns an array containing the positions of each alignment pattern.
     * Each array's element represent the center point of the pattern as (x, y) coordinates
     *
     * Coordinates are calculated expanding the row/column coordinates returned by {@link getRowColCoords}
     * and filtering out the items that overlaps with finder pattern
     *
     * @example
     * For a Version 7 symbol {@link getRowColCoords} returns values 6, 22 and 38.
     * The alignment patterns, therefore, are to be centered on (row, column)
     * positions (6,22), (22,6), (22,22), (22,38), (38,22), (38,38).
     * Note that the coordinates (6,6), (6,38), (38,6) are occupied by finder patterns
     * and are not therefore used for alignment patterns.
     *
     * var pos = getPositions(7)
     * // [[6,22], [22,6], [22,22], [22,38], [38,22], [38,38]]
     *
     * @param  {Number} version QR Code version
     * @return {Array}          Array of coordinates
     */


    exports.getPositions = function getPositions(version) {
      var coords = [];
      var pos = exports.getRowColCoords(version);
      var posLength = pos.length;

      for (var i = 0; i < posLength; i++) {
        for (var j = 0; j < posLength; j++) {
          // Skip if position is occupied by finder patterns
          if (i === 0 && j === 0 || // top-left
          i === 0 && j === posLength - 1 || // bottom-left
          i === posLength - 1 && j === 0) {
            // top-right
            continue;
          }

          coords.push([pos[i], pos[j]]);
        }
      }

      return coords;
    };
  })(alignmentPattern);

  var finderPattern = {};

  var getSymbolSize = utils$1.getSymbolSize;
  var FINDER_PATTERN_SIZE = 7;
  /**
   * Returns an array containing the positions of each finder pattern.
   * Each array's element represent the top-left point of the pattern as (x, y) coordinates
   *
   * @param  {Number} version QR Code version
   * @return {Array}          Array of coordinates
   */

  finderPattern.getPositions = function getPositions(version) {
    var size = getSymbolSize(version);
    return [// top-left
    [0, 0], // top-right
    [size - FINDER_PATTERN_SIZE, 0], // bottom-left
    [0, size - FINDER_PATTERN_SIZE]];
  };

  var maskPattern = {};

  /**
   * Data mask pattern reference
   * @type {Object}
   */

  (function (exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    /**
     * Weighted penalty scores for the undesirable features
     * @type {Object}
     */

    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    /**
     * Check if mask pattern value is valid
     *
     * @param  {Number}  mask    Mask pattern
     * @return {Boolean}         true if valid, false otherwise
     */

    exports.isValid = function isValid(mask) {
      return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    /**
     * Returns mask pattern from a value.
     * If value is not valid, returns undefined
     *
     * @param  {Number|String} value        Mask pattern value
     * @return {Number}                     Valid mask pattern or undefined
     */


    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : undefined;
    };
    /**
    * Find adjacent modules in row/column with the same color
    * and assign a penalty value.
    *
    * Points: N1 + i
    * i is the amount by which the number of adjacent modules of the same color exceeds 5
    */


    exports.getPenaltyN1 = function getPenaltyN1(data) {
      var size = data.size;
      var points = 0;
      var sameCountCol = 0;
      var sameCountRow = 0;
      var lastCol = null;
      var lastRow = null;

      for (var row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;

        for (var col = 0; col < size; col++) {
          var module = data.get(row, col);

          if (module === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module;
            sameCountCol = 1;
          }

          module = data.get(col, row);

          if (module === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module;
            sameCountRow = 1;
          }
        }

        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }

      return points;
    };
    /**
     * Find 2x2 blocks with the same color and assign a penalty value
     *
     * Points: N2 * (m - 1) * (n - 1)
     */


    exports.getPenaltyN2 = function getPenaltyN2(data) {
      var size = data.size;
      var points = 0;

      for (var row = 0; row < size - 1; row++) {
        for (var col = 0; col < size - 1; col++) {
          var last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }

      return points * PenaltyScores.N2;
    };
    /**
     * Find 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column,
     * preceded or followed by light area 4 modules wide
     *
     * Points: N3 * number of pattern found
     */


    exports.getPenaltyN3 = function getPenaltyN3(data) {
      var size = data.size;
      var points = 0;
      var bitsCol = 0;
      var bitsRow = 0;

      for (var row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;

        for (var col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 0x7FF | data.get(row, col);
          if (col >= 10 && (bitsCol === 0x5D0 || bitsCol === 0x05D)) points++;
          bitsRow = bitsRow << 1 & 0x7FF | data.get(col, row);
          if (col >= 10 && (bitsRow === 0x5D0 || bitsRow === 0x05D)) points++;
        }
      }

      return points * PenaltyScores.N3;
    };
    /**
     * Calculate proportion of dark modules in entire symbol
     *
     * Points: N4 * k
     *
     * k is the rating of the deviation of the proportion of dark modules
     * in the symbol from 50% in steps of 5%
     */


    exports.getPenaltyN4 = function getPenaltyN4(data) {
      var darkCount = 0;
      var modulesCount = data.data.length;

      for (var i = 0; i < modulesCount; i++) {
        darkCount += data.data[i];
      }

      var k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    /**
     * Return mask value at given position
     *
     * @param  {Number} maskPattern Pattern reference value
     * @param  {Number} i           Row
     * @param  {Number} j           Column
     * @return {Boolean}            Mask value
     */


    function getMaskAt(maskPattern, i, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i + j) % 2 === 0;

        case exports.Patterns.PATTERN001:
          return i % 2 === 0;

        case exports.Patterns.PATTERN010:
          return j % 3 === 0;

        case exports.Patterns.PATTERN011:
          return (i + j) % 3 === 0;

        case exports.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;

        case exports.Patterns.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;

        case exports.Patterns.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;

        case exports.Patterns.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;

        default:
          throw new Error('bad maskPattern:' + maskPattern);
      }
    }
    /**
     * Apply a mask pattern to a BitMatrix
     *
     * @param  {Number}    pattern Pattern reference number
     * @param  {BitMatrix} data    BitMatrix data
     */


    exports.applyMask = function applyMask(pattern, data) {
      var size = data.size;

      for (var col = 0; col < size; col++) {
        for (var row = 0; row < size; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    /**
     * Returns the best mask pattern for data
     *
     * @param  {BitMatrix} data
     * @return {Number} Mask pattern reference number
     */


    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      var numPatterns = Object.keys(exports.Patterns).length;
      var bestPattern = 0;
      var lowerPenalty = Infinity;

      for (var p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data); // Calculate penalty

        var penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data); // Undo previously applied mask

        exports.applyMask(p, data);

        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }

      return bestPattern;
    };
  })(maskPattern);

  var errorCorrectionCode = {};

  var ECLevel$1 = errorCorrectionLevel;
  var EC_BLOCKS_TABLE = [// L  M  Q  H
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81];
  var EC_CODEWORDS_TABLE = [// L  M  Q  H
  7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
  /**
   * Returns the number of error correction block that the QR Code should contain
   * for the specified version and error correction level.
   *
   * @param  {Number} version              QR Code version
   * @param  {Number} errorCorrectionLevel Error correction level
   * @return {Number}                      Number of error correction blocks
   */

  errorCorrectionCode.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
    switch (errorCorrectionLevel) {
      case ECLevel$1.L:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];

      case ECLevel$1.M:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];

      case ECLevel$1.Q:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];

      case ECLevel$1.H:
        return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];

      default:
        return undefined;
    }
  };
  /**
   * Returns the number of error correction codewords to use for the specified
   * version and error correction level.
   *
   * @param  {Number} version              QR Code version
   * @param  {Number} errorCorrectionLevel Error correction level
   * @return {Number}                      Number of error correction codewords
   */


  errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
    switch (errorCorrectionLevel) {
      case ECLevel$1.L:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];

      case ECLevel$1.M:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];

      case ECLevel$1.Q:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];

      case ECLevel$1.H:
        return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];

      default:
        return undefined;
    }
  };

  var polynomial = {};

  var galoisField = {};

  var BufferUtil$3 = typedarrayBuffer;
  var EXP_TABLE = BufferUtil$3.alloc(512);
  var LOG_TABLE = BufferUtil$3.alloc(256)
  /**
   * Precompute the log and anti-log tables for faster computation later
   *
   * For each possible value in the galois field 2^8, we will pre-compute
   * the logarithm and anti-logarithm (exponential) of this value
   *
   * ref {@link https://en.wikiversity.org/wiki/Reed%E2%80%93Solomon_codes_for_coders#Introduction_to_mathematical_fields}
   */
  ;

  (function initTables() {
    var x = 1;

    for (var i = 0; i < 255; i++) {
      EXP_TABLE[i] = x;
      LOG_TABLE[x] = i;
      x <<= 1; // multiply by 2
      // The QR code specification says to use byte-wise modulo 100011101 arithmetic.
      // This means that when a number is 256 or larger, it should be XORed with 0x11D.

      if (x & 0x100) {
        // similar to x >= 256, but a lot faster (because 0x100 == 256)
        x ^= 0x11D;
      }
    } // Optimization: double the size of the anti-log table so that we don't need to mod 255 to
    // stay inside the bounds (because we will mainly use this table for the multiplication of
    // two GF numbers, no more).
    // @see {@link mul}


    for (i = 255; i < 512; i++) {
      EXP_TABLE[i] = EXP_TABLE[i - 255];
    }
  })();
  /**
   * Returns log value of n inside Galois Field
   *
   * @param  {Number} n
   * @return {Number}
   */


  galoisField.log = function log(n) {
    if (n < 1) throw new Error('log(' + n + ')');
    return LOG_TABLE[n];
  };
  /**
   * Returns anti-log value of n inside Galois Field
   *
   * @param  {Number} n
   * @return {Number}
   */


  galoisField.exp = function exp(n) {
    return EXP_TABLE[n];
  };
  /**
   * Multiplies two number inside Galois Field
   *
   * @param  {Number} x
   * @param  {Number} y
   * @return {Number}
   */


  galoisField.mul = function mul(x, y) {
    if (x === 0 || y === 0) return 0; // should be EXP_TABLE[(LOG_TABLE[x] + LOG_TABLE[y]) % 255] if EXP_TABLE wasn't oversized
    // @see {@link initTables}

    return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
  };

  (function (exports) {
    var BufferUtil = typedarrayBuffer;
    var GF = galoisField;
    /**
     * Multiplies two polynomials inside Galois Field
     *
     * @param  {Buffer} p1 Polynomial
     * @param  {Buffer} p2 Polynomial
     * @return {Buffer}    Product of p1 and p2
     */

    exports.mul = function mul(p1, p2) {
      var coeff = BufferUtil.alloc(p1.length + p2.length - 1);

      for (var i = 0; i < p1.length; i++) {
        for (var j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }

      return coeff;
    };
    /**
     * Calculate the remainder of polynomials division
     *
     * @param  {Buffer} divident Polynomial
     * @param  {Buffer} divisor  Polynomial
     * @return {Buffer}          Remainder
     */


    exports.mod = function mod(divident, divisor) {
      var result = BufferUtil.from(divident);

      while (result.length - divisor.length >= 0) {
        var coeff = result[0];

        for (var i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        } // remove all zeros from buffer head


        var offset = 0;

        while (offset < result.length && result[offset] === 0) {
          offset++;
        }

        result = result.slice(offset);
      }

      return result;
    };
    /**
     * Generate an irreducible generator polynomial of specified degree
     * (used by Reed-Solomon encoder)
     *
     * @param  {Number} degree Degree of the generator polynomial
     * @return {Buffer}        Buffer containing polynomial coefficients
     */


    exports.generateECPolynomial = function generateECPolynomial(degree) {
      var poly = BufferUtil.from([1]);

      for (var i = 0; i < degree; i++) {
        poly = exports.mul(poly, [1, GF.exp(i)]);
      }

      return poly;
    };
  })(polynomial);

  var buffer = {};

  (function (exports) {

    var base64 = base64Js;
    var ieee754$1 = ieee754;
    var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null;
    exports.Buffer = Buffer;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 0x7fffffff;
    exports.kMaxLength = K_MAX_LENGTH;
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Print warning and recommend using `buffer` v4.x which has an Object
     *               implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * We report that the browser does not support typed arrays if the are not subclassable
     * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
     * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
     * for __proto__ and has a buggy typed array implementation.
     */

    Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

    if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
    }

    function typedArraySupport() {
      // Can typed array instances can be augmented?
      try {
        var arr = new Uint8Array(1);
        var proto = {
          foo: function foo() {
            return 42;
          }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }

    Object.defineProperty(Buffer.prototype, 'parent', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer.prototype, 'offset', {
      enumerable: true,
      get: function get() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
      }
    });

    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      } // Return an augmented `Uint8Array` instance


      var buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */


    function Buffer(arg, encodingOrOffset, length) {
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }

        return allocUnsafe(arg);
      }

      return from(arg, encodingOrOffset, length);
    }

    Buffer.poolSize = 8192; // not used by this implementation

    function from(value, encodingOrOffset, length) {
      if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
      }

      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }

      if (value == null) {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof$1(value));
      }

      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }

      if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }

      var valueOf = value.valueOf && value.valueOf();

      if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
      }

      var b = fromObject(value);
      if (b) return b;

      if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
      }

      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof$1(value));
    }
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/


    Buffer.from = function (value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
    // https://github.com/feross/buffer/pull/148


    Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer, Uint8Array);

    function assertSize(size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }

    function alloc(size, fill, encoding) {
      assertSize(size);

      if (size <= 0) {
        return createBuffer(size);
      }

      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }

      return createBuffer(size);
    }
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/


    Buffer.alloc = function (size, fill, encoding) {
      return alloc(size, fill, encoding);
    };

    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */


    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(size);
    };
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */


    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(size);
    };

    function fromString(string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
      }

      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }

      var length = byteLength(string, encoding) | 0;
      var buf = createBuffer(length);
      var actual = buf.write(string, encoding);

      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
      }

      return buf;
    }

    function fromArrayLike(array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0;
      var buf = createBuffer(length);

      for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }

      return buf;
    }

    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }

      return fromArrayLike(arrayView);
    }

    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }

      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }

      var buf;

      if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
      } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      } // Return an augmented `Uint8Array` instance


      Object.setPrototypeOf(buf, Buffer.prototype);
      return buf;
    }

    function fromObject(obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);

        if (buf.length === 0) {
          return buf;
        }

        obj.copy(buf, 0, 0, len);
        return buf;
      }

      if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }

        return fromArrayLike(obj);
      }

      if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }

    function checked(length) {
      // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
      }

      return length | 0;
    }

    function SlowBuffer(length) {
      if (+length != length) {
        // eslint-disable-line eqeqeq
        length = 0;
      }

      return Buffer.alloc(+length);
    }

    Buffer.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
    };

    Buffer.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }

      if (a === b) return 0;
      var x = a.length;
      var y = b.length;

      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };

    Buffer.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true;

        default:
          return false;
      }
    };

    Buffer.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      if (list.length === 0) {
        return Buffer.alloc(0);
      }

      var i;

      if (length === undefined) {
        length = 0;

        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }

      var buffer = Buffer.allocUnsafe(length);
      var pos = 0;

      for (i = 0; i < list.length; ++i) {
        var buf = list[i];

        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            Buffer.from(buf).copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(buffer, buf, pos);
          }
        } else if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }

        pos += buf.length;
      }

      return buffer;
    };

    function byteLength(string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length;
      }

      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }

      if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof$1(string));
      }

      var len = string.length;
      var mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len;

          case 'utf8':
          case 'utf-8':
            return utf8ToBytes(string).length;

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2;

          case 'hex':
            return len >>> 1;

          case 'base64':
            return base64ToBytes(string).length;

          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
            }

            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }

    Buffer.byteLength = byteLength;

    function slowToString(encoding, start, end) {
      var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

      if (start === undefined || start < 0) {
        start = 0;
      } // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.


      if (start > this.length) {
        return '';
      }

      if (end === undefined || end > this.length) {
        end = this.length;
      }

      if (end <= 0) {
        return '';
      } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


      end >>>= 0;
      start >>>= 0;

      if (end <= start) {
        return '';
      }

      if (!encoding) encoding = 'utf8';

      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end);

          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end);

          case 'ascii':
            return asciiSlice(this, start, end);

          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end);

          case 'base64':
            return base64Slice(this, start, end);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = (encoding + '').toLowerCase();
            loweredCase = true;
        }
      }
    } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
    // to detect a Buffer instance. It's not possible to use `instanceof Buffer`
    // reliably in a browserify context because there could be multiple different
    // copies of the 'buffer' package in use. This method works even for Buffer
    // instances that were created from another copy of the `buffer` package.
    // See: https://github.com/feross/buffer/issues/154


    Buffer.prototype._isBuffer = true;

    function swap(b, n, m) {
      var i = b[n];
      b[n] = b[m];
      b[m] = i;
    }

    Buffer.prototype.swap16 = function swap16() {
      var len = this.length;

      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
      }

      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }

      return this;
    };

    Buffer.prototype.swap32 = function swap32() {
      var len = this.length;

      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
      }

      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }

      return this;
    };

    Buffer.prototype.swap64 = function swap64() {
      var len = this.length;

      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
      }

      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }

      return this;
    };

    Buffer.prototype.toString = function toString() {
      var length = this.length;
      if (length === 0) return '';
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };

    Buffer.prototype.toLocaleString = Buffer.prototype.toString;

    Buffer.prototype.equals = function equals(b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
      if (this === b) return true;
      return Buffer.compare(this, b) === 0;
    };

    Buffer.prototype.inspect = function inspect() {
      var str = '';
      var max = exports.INSPECT_MAX_BYTES;
      str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
      if (this.length > max) str += ' ... ';
      return '<Buffer ' + str + '>';
    };

    if (customInspectSymbol) {
      Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
    }

    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
      }

      if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof$1(target));
      }

      if (start === undefined) {
        start = 0;
      }

      if (end === undefined) {
        end = target ? target.length : 0;
      }

      if (thisStart === undefined) {
        thisStart = 0;
      }

      if (thisEnd === undefined) {
        thisEnd = this.length;
      }

      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
      }

      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }

      if (thisStart >= thisEnd) {
        return -1;
      }

      if (start >= end) {
        return 1;
      }

      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      var x = thisEnd - thisStart;
      var y = end - start;
      var len = Math.min(x, y);
      var thisCopy = this.slice(thisStart, thisEnd);
      var targetCopy = target.slice(start, end);

      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }

      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf


    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1; // Normalize byteOffset

      if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
      }

      byteOffset = +byteOffset; // Coerce to Number.

      if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
      } // Normalize byteOffset: negative offsets start from the end of the buffer


      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

      if (byteOffset >= buffer.length) {
        if (dir) return -1;else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;else return -1;
      } // Normalize val


      if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
      } // Finally, search either indexOf (if dir is true) or lastIndexOf


      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1;
        }

        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]

        if (typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }

        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }

      throw new TypeError('val must be string, number or Buffer');
    }

    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      var indexSize = 1;
      var arrLength = arr.length;
      var valLength = val.length;

      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();

        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }

          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }

      function read(buf, i) {
        if (indexSize === 1) {
          return buf[i];
        } else {
          return buf.readUInt16BE(i * indexSize);
        }
      }

      var i;

      if (dir) {
        var foundIndex = -1;

        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

        for (i = byteOffset; i >= 0; i--) {
          var found = true;

          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }

          if (found) return i;
        }
      }

      return -1;
    }

    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };

    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };

    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };

    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      var remaining = buf.length - offset;

      if (!length) {
        length = remaining;
      } else {
        length = Number(length);

        if (length > remaining) {
          length = remaining;
        }
      }

      var strLen = string.length;

      if (length > strLen / 2) {
        length = strLen / 2;
      }

      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }

      return i;
    }

    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }

    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }

    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }

    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }

    Buffer.prototype.write = function write(string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0; // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0; // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset >>> 0;

        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === undefined) encoding = 'utf8';
        } else {
          encoding = length;
          length = undefined;
        }
      } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
      }

      var remaining = this.length - offset;
      if (length === undefined || length > remaining) length = remaining;

      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
      }

      if (!encoding) encoding = 'utf8';
      var loweredCase = false;

      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length);

          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length);

          case 'ascii':
          case 'latin1':
          case 'binary':
            return asciiWrite(this, string, offset, length);

          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length);

          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length);

          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
            encoding = ('' + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };

    Buffer.prototype.toJSON = function toJSON() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };

    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }

    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      var res = [];
      var i = start;

      while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint;

          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte;
              }

              break;

            case 2:
              secondByte = buf[i + 1];

              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint;
                }
              }

              break;

            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];

              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint;
                }
              }

          }
        }

        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD;
          bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000;
          res.push(codePoint >>> 10 & 0x3FF | 0xD800);
          codePoint = 0xDC00 | codePoint & 0x3FF;
        }

        res.push(codePoint);
        i += bytesPerSequence;
      }

      return decodeCodePointsArray(res);
    } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety


    var MAX_ARGUMENTS_LENGTH = 0x1000;

    function decodeCodePointsArray(codePoints) {
      var len = codePoints.length;

      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
      } // Decode in chunks to avoid "call stack size exceeded".


      var res = '';
      var i = 0;

      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
      }

      return res;
    }

    function asciiSlice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
      }

      return ret;
    }

    function latin1Slice(buf, start, end) {
      var ret = '';
      end = Math.min(buf.length, end);

      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }

      return ret;
    }

    function hexSlice(buf, start, end) {
      var len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      var out = '';

      for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }

      return out;
    }

    function utf16leSlice(buf, start, end) {
      var bytes = buf.slice(start, end);
      var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

      for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }

      return res;
    }

    Buffer.prototype.slice = function slice(start, end) {
      var len = this.length;
      start = ~~start;
      end = end === undefined ? len : ~~end;

      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }

      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }

      if (end < start) end = start;
      var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

      Object.setPrototypeOf(newBuf, Buffer.prototype);
      return newBuf;
    };
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */


    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
    }

    Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      return val;
    };

    Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }

      var val = this[offset + --byteLength];
      var mul = 1;

      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul;
      }

      return val;
    };

    Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };

    Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };

    Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };

    Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
    };

    Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };

    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var val = this[offset];
      var mul = 1;
      var i = 0;

      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;
      if (!noAssert) checkOffset(offset, byteLength, this.length);
      var i = byteLength;
      var mul = 1;
      var val = this[offset + --i];

      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
      }

      mul *= 0x80;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength);
      return val;
    };

    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 0x80)) return this[offset];
      return (0xff - this[offset] + 1) * -1;
    };

    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset] | this[offset + 1] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      var val = this[offset + 1] | this[offset] << 8;
      return val & 0x8000 ? val | 0xFFFF0000 : val;
    };

    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };

    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };

    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, true, 23, 4);
    };

    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754$1.read(this, offset, false, 23, 4);
    };

    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, true, 52, 8);
    };

    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754$1.read(this, offset, false, 52, 8);
    };

    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
    }

    Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var mul = 1;
      var i = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength = byteLength >>> 0;

      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
      }

      var i = byteLength - 1;
      var mul = 1;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = value / mul & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = 0;
      var mul = 1;
      var sub = 0;
      this[offset] = value & 0xFF;

      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }

      var i = byteLength - 1;
      var mul = 1;
      var sub = 0;
      this[offset + i] = value & 0xFF;

      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }

        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
      }

      return offset + byteLength;
    };

    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
      if (value < 0) value = 0xff + value + 1;
      this[offset] = value & 0xff;
      return offset + 1;
    };

    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };

    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
      return offset + 2;
    };

    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };

    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
      if (value < 0) value = 0xffffffff + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
      return offset + 4;
    };

    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range');
      if (offset < 0) throw new RangeError('Index out of range');
    }

    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }

    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };

    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;

      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8);
      }

      ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }

    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };

    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
      }

      if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
      if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

      if (end > this.length) end = this.length;

      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }

      var len = end - start;

      if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }

      return len;
    }; // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])


    Buffer.prototype.fill = function fill(val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === 'string') {
          encoding = end;
          end = this.length;
        }

        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string');
        }

        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding);
        }

        if (val.length === 1) {
          var code = val.charCodeAt(0);

          if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
            // Fast path: If `val` fits into a single byte, use that numeric value.
            val = code;
          }
        }
      } else if (typeof val === 'number') {
        val = val & 255;
      } else if (typeof val === 'boolean') {
        val = Number(val);
      } // Invalid ranges are not set to a default, so can range check early.


      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
      }

      if (end <= start) {
        return this;
      }

      start = start >>> 0;
      end = end === undefined ? this.length : end >>> 0;
      if (!val) val = 0;
      var i;

      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        var len = bytes.length;

        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }

        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }

      return this;
    }; // HELPER FUNCTIONS
    // ================


    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

    function base64clean(str) {
      // Node takes equal signs as end of the Base64 encoding
      str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

      str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

      if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

      while (str.length % 4 !== 0) {
        str = str + '=';
      }

      return str;
    }

    function utf8ToBytes(string, units) {
      units = units || Infinity;
      var codePoint;
      var length = string.length;
      var leadSurrogate = null;
      var bytes = [];

      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i); // is surrogate component

        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
              continue;
            } // valid lead


            leadSurrogate = codePoint;
            continue;
          } // 2 leads in a row


          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            leadSurrogate = codePoint;
            continue;
          } // valid surrogate pair


          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }

        leadSurrogate = null; // encode utf8

        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break;
          bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break;
          bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break;
          bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
          throw new Error('Invalid code point');
        }
      }

      return bytes;
    }

    function asciiToBytes(str) {
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
      }

      return byteArray;
    }

    function utf16leToBytes(str, units) {
      var c, hi, lo;
      var byteArray = [];

      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }

      return byteArray;
    }

    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }

    function blitBuffer(src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }

      return i;
    } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
    // the `instanceof` check but they should be treated as of that type.
    // See: https://github.com/feross/buffer/issues/166


    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }

    function numberIsNaN(obj) {
      // For IE11 support
      return obj !== obj; // eslint-disable-line no-self-compare
    } // Create lookup table for `toString('hex')`
    // See: https://github.com/feross/buffer/issues/219


    var hexSliceLookupTable = function () {
      var alphabet = '0123456789abcdef';
      var table = new Array(256);

      for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;

        for (var j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }

      return table;
    }();
  })(buffer);

  var BufferUtil$2 = typedarrayBuffer;
  var Polynomial = polynomial;
  var Buffer = buffer.Buffer;

  function ReedSolomonEncoder$1(degree) {
    this.genPoly = undefined;
    this.degree = degree;
    if (this.degree) this.initialize(this.degree);
  }
  /**
   * Initialize the encoder.
   * The input param should correspond to the number of error correction codewords.
   *
   * @param  {Number} degree
   */


  ReedSolomonEncoder$1.prototype.initialize = function initialize(degree) {
    // create an irreducible generator polynomial
    this.degree = degree;
    this.genPoly = Polynomial.generateECPolynomial(this.degree);
  };
  /**
   * Encodes a chunk of data
   *
   * @param  {Buffer} data Buffer containing input data
   * @return {Buffer}      Buffer containing encoded data
   */


  ReedSolomonEncoder$1.prototype.encode = function encode(data) {
    if (!this.genPoly) {
      throw new Error('Encoder not initialized');
    } // Calculate EC for this data block
    // extends data size to data+genPoly size


    var pad = BufferUtil$2.alloc(this.degree);
    var paddedData = Buffer.concat([data, pad], data.length + this.degree); // The error correction codewords are the remainder after dividing the data codewords
    // by a generator polynomial

    var remainder = Polynomial.mod(paddedData, this.genPoly); // return EC data blocks (last n byte, where n is the degree of genPoly)
    // If coefficients number in remainder are less than genPoly degree,
    // pad with 0s to the left to reach the needed number of coefficients

    var start = this.degree - remainder.length;

    if (start > 0) {
      var buff = BufferUtil$2.alloc(this.degree);
      remainder.copy(buff, start);
      return buff;
    }

    return remainder;
  };

  var reedSolomonEncoder = ReedSolomonEncoder$1;

  var version = {};

  var mode = {};

  var versionCheck = {};

  /**
   * Check if QR Code version is valid
   *
   * @param  {Number}  version QR Code version
   * @return {Boolean}         true if valid version, false otherwise
   */

  versionCheck.isValid = function isValid(version) {
    return !isNaN(version) && version >= 1 && version <= 40;
  };

  var regex = {};

  var numeric = '[0-9]+';
  var alphanumeric = '[A-Z $%*+\\-./:]+';
  var kanji = '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|' + '[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|' + '[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|' + '[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+';
  kanji = kanji.replace(/u/g, "\\u");

  var _byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+';

  regex.KANJI = new RegExp(kanji, 'g');
  regex.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g');
  regex.BYTE = new RegExp(_byte, 'g');
  regex.NUMERIC = new RegExp(numeric, 'g');
  regex.ALPHANUMERIC = new RegExp(alphanumeric, 'g');
  var TEST_KANJI = new RegExp('^' + kanji + '$');
  var TEST_NUMERIC = new RegExp('^' + numeric + '$');
  var TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$');

  regex.testKanji = function testKanji(str) {
    return TEST_KANJI.test(str);
  };

  regex.testNumeric = function testNumeric(str) {
    return TEST_NUMERIC.test(str);
  };

  regex.testAlphanumeric = function testAlphanumeric(str) {
    return TEST_ALPHANUMERIC.test(str);
  };

  (function (exports) {
    var VersionCheck = versionCheck;
    var Regex = regex;
    /**
     * Numeric mode encodes data from the decimal digit set (0 - 9)
     * (byte values 30HEX to 39HEX).
     * Normally, 3 data characters are represented by 10 bits.
     *
     * @type {Object}
     */

    exports.NUMERIC = {
      id: 'Numeric',
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    /**
     * Alphanumeric mode encodes data from a set of 45 characters,
     * i.e. 10 numeric digits (0 - 9),
     *      26 alphabetic characters (A - Z),
     *   and 9 symbols (SP, $, %, *, +, -, ., /, :).
     * Normally, two input characters are represented by 11 bits.
     *
     * @type {Object}
     */

    exports.ALPHANUMERIC = {
      id: 'Alphanumeric',
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    /**
     * In byte mode, data is encoded at 8 bits per character.
     *
     * @type {Object}
     */

    exports.BYTE = {
      id: 'Byte',
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    /**
     * The Kanji mode efficiently encodes Kanji characters in accordance with
     * the Shift JIS system based on JIS X 0208.
     * The Shift JIS values are shifted from the JIS X 0208 values.
     * JIS X 0208 gives details of the shift coded representation.
     * Each two-byte character value is compacted to a 13-bit binary codeword.
     *
     * @type {Object}
     */

    exports.KANJI = {
      id: 'Kanji',
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    /**
     * Mixed mode will contain a sequences of data in a combination of any of
     * the modes described above
     *
     * @type {Object}
     */

    exports.MIXED = {
      bit: -1
    };
    /**
     * Returns the number of bits needed to store the data length
     * according to QR Code specifications.
     *
     * @param  {Mode}   mode    Data mode
     * @param  {Number} version QR Code version
     * @return {Number}         Number of bits
     */

    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits) throw new Error('Invalid mode: ' + mode);

      if (!VersionCheck.isValid(version)) {
        throw new Error('Invalid version: ' + version);
      }

      if (version >= 1 && version < 10) return mode.ccBits[0];else if (version < 27) return mode.ccBits[1];
      return mode.ccBits[2];
    };
    /**
     * Returns the most efficient mode to store the specified data
     *
     * @param  {String} dataStr Input data string
     * @return {Mode}           Best mode
     */


    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;else if (Regex.testKanji(dataStr)) return exports.KANJI;else return exports.BYTE;
    };
    /**
     * Return mode name as string
     *
     * @param {Mode} mode Mode object
     * @returns {String}  Mode name
     */


    exports.toString = function toString(mode) {
      if (mode && mode.id) return mode.id;
      throw new Error('Invalid mode');
    };
    /**
     * Check if input param is a valid mode object
     *
     * @param   {Mode}    mode Mode object
     * @returns {Boolean} True if valid mode, false otherwise
     */


    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    /**
     * Get mode object from its name
     *
     * @param   {String} string Mode name
     * @returns {Mode}          Mode object
     */


    function fromString(string) {
      if (typeof string !== 'string') {
        throw new Error('Param is not a string');
      }

      var lcStr = string.toLowerCase();

      switch (lcStr) {
        case 'numeric':
          return exports.NUMERIC;

        case 'alphanumeric':
          return exports.ALPHANUMERIC;

        case 'kanji':
          return exports.KANJI;

        case 'byte':
          return exports.BYTE;

        default:
          throw new Error('Unknown mode: ' + string);
      }
    }
    /**
     * Returns mode from a value.
     * If value is not a valid mode, returns defaultValue
     *
     * @param  {Mode|String} value        Encoding mode
     * @param  {Mode}        defaultValue Fallback value
     * @return {Mode}                     Encoding mode
     */


    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }

      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  })(mode);

  (function (exports) {
    var Utils = utils$1;
    var ECCode = errorCorrectionCode;
    var ECLevel = errorCorrectionLevel;
    var Mode = mode;
    var VersionCheck = versionCheck;
    var isArray = isarray; // Generator polynomial used to encode version information

    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);

    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }

      return undefined;
    }

    function getReservedBitsCount(mode, version) {
      // Character count indicator + mode indicator bits
      return Mode.getCharCountIndicator(mode, version) + 4;
    }

    function getTotalBitsFromDataArray(segments, version) {
      var totalBits = 0;
      segments.forEach(function (data) {
        var reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }

    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (var currentVersion = 1; currentVersion <= 40; currentVersion++) {
        var length = getTotalBitsFromDataArray(segments, currentVersion);

        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }

      return undefined;
    }
    /**
     * Returns version number from a value.
     * If value is not a valid version, returns defaultValue
     *
     * @param  {Number|String} value        QR Code version
     * @param  {Number}        defaultValue Fallback value
     * @return {Number}                     QR Code version number
     */


    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }

      return defaultValue;
    };
    /**
     * Returns how much data can be stored with the specified QR code version
     * and error correction level
     *
     * @param  {Number} version              QR Code version (1-40)
     * @param  {Number} errorCorrectionLevel Error correction level
     * @param  {Mode}   mode                 Data mode
     * @return {Number}                      Quantity of storable data
     */


    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error('Invalid QR Code version');
      } // Use Byte mode as default


      if (typeof mode === 'undefined') mode = Mode.BYTE; // Total codewords for this QR code version (Data + Error correction)

      var totalCodewords = Utils.getSymbolTotalCodewords(version); // Total number of error correction codewords

      var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel); // Total number of data codewords

      var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED) return dataTotalCodewordsBits;
      var usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version); // Return max number of storable codewords

      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);

        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);

        case Mode.KANJI:
          return Math.floor(usableBits / 13);

        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    /**
     * Returns the minimum version needed to contain the amount of data
     *
     * @param  {Segment} data                    Segment of data
     * @param  {Number} [errorCorrectionLevel=H] Error correction level
     * @param  {Mode} mode                       Data mode
     * @return {Number}                          QR Code version
     */


    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      var seg;
      var ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);

      if (isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }

        if (data.length === 0) {
          return 1;
        }

        seg = data[0];
      } else {
        seg = data;
      }

      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    /**
     * Returns version information with relative error correction bits
     *
     * The version information is included in QR Code symbols of version 7 or larger.
     * It consists of an 18-bit sequence containing 6 data bits,
     * with 12 error correction bits calculated using the (18, 6) Golay code.
     *
     * @param  {Number} version QR Code version
     * @return {Number}         Encoded version info bits
     */


    exports.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error('Invalid QR Code version');
      }

      var d = version << 12;

      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }

      return version << 12 | d;
    };
  })(version);

  var formatInfo = {};

  var Utils$3 = utils$1;
  var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
  var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
  var G15_BCH = Utils$3.getBCHDigit(G15);
  /**
   * Returns format information with relative error correction bits
   *
   * The format information is a 15-bit sequence containing 5 data bits,
   * with 10 error correction bits calculated using the (15, 5) BCH code.
   *
   * @param  {Number} errorCorrectionLevel Error correction level
   * @param  {Number} mask                 Mask pattern
   * @return {Number}                      Encoded format information bits
   */

  formatInfo.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
    var data = errorCorrectionLevel.bit << 3 | mask;
    var d = data << 10;

    while (Utils$3.getBCHDigit(d) - G15_BCH >= 0) {
      d ^= G15 << Utils$3.getBCHDigit(d) - G15_BCH;
    } // xor final data with mask pattern in order to ensure that
    // no combination of Error Correction Level and data mask pattern
    // will result in an all-zero data string


    return (data << 10 | d) ^ G15_MASK;
  };

  var segments = {};

  var Mode$4 = mode;

  function NumericData(data) {
    this.mode = Mode$4.NUMERIC;
    this.data = data.toString();
  }

  NumericData.getBitsLength = function getBitsLength(length) {
    return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
  };

  NumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };

  NumericData.prototype.getBitsLength = function getBitsLength() {
    return NumericData.getBitsLength(this.data.length);
  };

  NumericData.prototype.write = function write(bitBuffer) {
    var i, group, value; // The input data string is divided into groups of three digits,
    // and each group is converted to its 10-bit binary equivalent.

    for (i = 0; i + 3 <= this.data.length; i += 3) {
      group = this.data.substr(i, 3);
      value = parseInt(group, 10);
      bitBuffer.put(value, 10);
    } // If the number of input digits is not an exact multiple of three,
    // the final one or two digits are converted to 4 or 7 bits respectively.


    var remainingNum = this.data.length - i;

    if (remainingNum > 0) {
      group = this.data.substr(i);
      value = parseInt(group, 10);
      bitBuffer.put(value, remainingNum * 3 + 1);
    }
  };

  var numericData = NumericData;

  var Mode$3 = mode;
  /**
   * Array of characters available in alphanumeric mode
   *
   * As per QR Code specification, to each character
   * is assigned a value from 0 to 44 which in this case coincides
   * with the array index
   *
   * @type {Array}
   */

  var ALPHA_NUM_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', ' ', '$', '%', '*', '+', '-', '.', '/', ':'];

  function AlphanumericData(data) {
    this.mode = Mode$3.ALPHANUMERIC;
    this.data = data;
  }

  AlphanumericData.getBitsLength = function getBitsLength(length) {
    return 11 * Math.floor(length / 2) + 6 * (length % 2);
  };

  AlphanumericData.prototype.getLength = function getLength() {
    return this.data.length;
  };

  AlphanumericData.prototype.getBitsLength = function getBitsLength() {
    return AlphanumericData.getBitsLength(this.data.length);
  };

  AlphanumericData.prototype.write = function write(bitBuffer) {
    var i; // Input data characters are divided into groups of two characters
    // and encoded as 11-bit binary codes.

    for (i = 0; i + 2 <= this.data.length; i += 2) {
      // The character value of the first character is multiplied by 45
      var value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45; // The character value of the second digit is added to the product

      value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]); // The sum is then stored as 11-bit binary number

      bitBuffer.put(value, 11);
    } // If the number of input data characters is not a multiple of two,
    // the character value of the final character is encoded as a 6-bit binary number.


    if (this.data.length % 2) {
      bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
    }
  };

  var alphanumericData = AlphanumericData;

  var BufferUtil$1 = typedarrayBuffer;
  var Mode$2 = mode;

  function ByteData(data) {
    this.mode = Mode$2.BYTE;
    this.data = BufferUtil$1.from(data);
  }

  ByteData.getBitsLength = function getBitsLength(length) {
    return length * 8;
  };

  ByteData.prototype.getLength = function getLength() {
    return this.data.length;
  };

  ByteData.prototype.getBitsLength = function getBitsLength() {
    return ByteData.getBitsLength(this.data.length);
  };

  ByteData.prototype.write = function (bitBuffer) {
    for (var i = 0, l = this.data.length; i < l; i++) {
      bitBuffer.put(this.data[i], 8);
    }
  };

  var byteData = ByteData;

  var Mode$1 = mode;
  var Utils$2 = utils$1;

  function KanjiData(data) {
    this.mode = Mode$1.KANJI;
    this.data = data;
  }

  KanjiData.getBitsLength = function getBitsLength(length) {
    return length * 13;
  };

  KanjiData.prototype.getLength = function getLength() {
    return this.data.length;
  };

  KanjiData.prototype.getBitsLength = function getBitsLength() {
    return KanjiData.getBitsLength(this.data.length);
  };

  KanjiData.prototype.write = function (bitBuffer) {
    var i; // In the Shift JIS system, Kanji characters are represented by a two byte combination.
    // These byte values are shifted from the JIS X 0208 values.
    // JIS X 0208 gives details of the shift coded representation.

    for (i = 0; i < this.data.length; i++) {
      var value = Utils$2.toSJIS(this.data[i]); // For characters with Shift JIS values from 0x8140 to 0x9FFC:

      if (value >= 0x8140 && value <= 0x9FFC) {
        // Subtract 0x8140 from Shift JIS value
        value -= 0x8140; // For characters with Shift JIS values from 0xE040 to 0xEBBF
      } else if (value >= 0xE040 && value <= 0xEBBF) {
        // Subtract 0xC140 from Shift JIS value
        value -= 0xC140;
      } else {
        throw new Error('Invalid SJIS character: ' + this.data[i] + '\n' + 'Make sure your charset is UTF-8');
      } // Multiply most significant byte of result by 0xC0
      // and add least significant byte to product


      value = (value >>> 8 & 0xff) * 0xC0 + (value & 0xff); // Convert result to a 13-bit binary string

      bitBuffer.put(value, 13);
    }
  };

  var kanjiData = KanjiData;

  var dijkstra = {exports: {}};

  (function (module) {
    /******************************************************************************
     * Created 2008-08-19.
     *
     * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.
     *
     * Copyright (C) 2008
     *   Wyatt Baldwin <self@wyattbaldwin.com>
     *   All rights reserved
     *
     * Licensed under the MIT license.
     *
     *   http://www.opensource.org/licenses/mit-license.php
     *
     * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
     * THE SOFTWARE.
     *****************************************************************************/

    var dijkstra = {
      single_source_shortest_paths: function single_source_shortest_paths(graph, s, d) {
        // Predecessor map for each node that has been encountered.
        // node ID => predecessor node ID
        var predecessors = {}; // Costs of shortest paths from s to all nodes encountered.
        // node ID => cost

        var costs = {};
        costs[s] = 0; // Costs of shortest paths from s to all nodes encountered; differs from
        // `costs` in that it provides easy access to the node that currently has
        // the known shortest path from s.
        // XXX: Do we actually need both `costs` and `open`?

        var open = dijkstra.PriorityQueue.make();
        open.push(s, 0);
        var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;

        while (!open.empty()) {
          // In the nodes remaining in graph that have a known cost from s,
          // find the node, u, that currently has the shortest path from s.
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost; // Get nodes adjacent to u...

          adjacent_nodes = graph[u] || {}; // ...and explore the edges that connect u to those nodes, updating
          // the cost of the shortest paths to any or all of those nodes as
          // necessary. v is the node across the current edge from u.

          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              // Get the cost of the edge running from u to v.
              cost_of_e = adjacent_nodes[v]; // Cost of s to u plus the cost of u to v across e--this is *a*
              // cost from s to v that may or may not be less than the current
              // known cost to v.

              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e; // If we haven't visited v yet OR if the current known cost from s to
              // v is greater than the new cost we just found (cost of s to u plus
              // cost of u to v across e), update v's cost in the cost list and
              // update v's predecessor in the predecessor list (it's now u).

              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === 'undefined';

              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }

        if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
          var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');
          throw new Error(msg);
        }

        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function extract_shortest_path_from_predecessor_list(predecessors, d) {
        var nodes = [];
        var u = d;

        while (u) {
          nodes.push(u);
          predecessors[u];
          u = predecessors[u];
        }

        nodes.reverse();
        return nodes;
      },
      find_path: function find_path(graph, s, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);
      },

      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function make(opts) {
          var T = dijkstra.PriorityQueue,
              t = {},
              key;
          opts = opts || {};

          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t[key] = T[key];
            }
          }

          t.queue = [];
          t.sorter = opts.sorter || T.default_sorter;
          return t;
        },
        default_sorter: function default_sorter(a, b) {
          return a.cost - b.cost;
        },

        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function push(value, cost) {
          var item = {
            value: value,
            cost: cost
          };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },

        /**
         * Return the highest priority element in the queue.
         */
        pop: function pop() {
          return this.queue.shift();
        },
        empty: function empty() {
          return this.queue.length === 0;
        }
      }
    }; // node.js module exports

    {
      module.exports = dijkstra;
    }
  })(dijkstra);

  (function (exports) {
    var Mode = mode;
    var NumericData = numericData;
    var AlphanumericData = alphanumericData;
    var ByteData = byteData;
    var KanjiData = kanjiData;
    var Regex = regex;
    var Utils = utils$1;
    var dijkstra$1 = dijkstra.exports;
    /**
     * Returns UTF8 byte length
     *
     * @param  {String} str Input string
     * @return {Number}     Number of byte
     */

    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    /**
     * Get a list of segments of the specified mode
     * from a string
     *
     * @param  {Mode}   mode Segment mode
     * @param  {String} str  String to process
     * @return {Array}       Array of object with segments data
     */


    function getSegments(regex, mode, str) {
      var segments = [];
      var result;

      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode: mode,
          length: result[0].length
        });
      }

      return segments;
    }
    /**
     * Extracts a series of segments with the appropriate
     * modes from a string
     *
     * @param  {String} dataStr Input string
     * @return {Array}          Array of object with segments data
     */


    function getSegmentsFromString(dataStr) {
      var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      var byteSegs;
      var kanjiSegs;

      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }

      var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function (s1, s2) {
        return s1.index - s2.index;
      }).map(function (obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    /**
     * Returns how many bits are needed to encode a string of
     * specified length with the specified mode
     *
     * @param  {Number} length String length
     * @param  {Mode} mode     Segment mode
     * @return {Number}        Bit length
     */


    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);

        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);

        case Mode.KANJI:
          return KanjiData.getBitsLength(length);

        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    /**
     * Merges adjacent segments which have the same mode
     *
     * @param  {Array} segs Array of object with segments data
     * @return {Array}      Array of object with segments data
     */


    function mergeSegments(segs) {
      return segs.reduce(function (acc, curr) {
        var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;

        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }

        acc.push(curr);
        return acc;
      }, []);
    }
    /**
     * Generates a list of all possible nodes combination which
     * will be used to build a segments graph.
     *
     * Nodes are divided by groups. Each group will contain a list of all the modes
     * in which is possible to encode the given text.
     *
     * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.
     * The group for '12345' will contain then 3 objects, one for each
     * possible encoding mode.
     *
     * Each node represents a possible segment.
     *
     * @param  {Array} segs Array of object with segments data
     * @return {Array}      Array of object with segments data
     */


    function buildNodes(segs) {
      var nodes = [];

      for (var i = 0; i < segs.length; i++) {
        var seg = segs[i];

        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([seg, {
              data: seg.data,
              mode: Mode.ALPHANUMERIC,
              length: seg.length
            }, {
              data: seg.data,
              mode: Mode.BYTE,
              length: seg.length
            }]);
            break;

          case Mode.ALPHANUMERIC:
            nodes.push([seg, {
              data: seg.data,
              mode: Mode.BYTE,
              length: seg.length
            }]);
            break;

          case Mode.KANJI:
            nodes.push([seg, {
              data: seg.data,
              mode: Mode.BYTE,
              length: getStringByteLength(seg.data)
            }]);
            break;

          case Mode.BYTE:
            nodes.push([{
              data: seg.data,
              mode: Mode.BYTE,
              length: getStringByteLength(seg.data)
            }]);
        }
      }

      return nodes;
    }
    /**
     * Builds a graph from a list of nodes.
     * All segments in each node group will be connected with all the segments of
     * the next group and so on.
     *
     * At each connection will be assigned a weight depending on the
     * segment's byte length.
     *
     * @param  {Array} nodes    Array of object with segments data
     * @param  {Number} version QR Code version
     * @return {Object}         Graph of all possible segments
     */


    function buildGraph(nodes, version) {
      var table = {};
      var graph = {
        'start': {}
      };
      var prevNodeIds = ['start'];

      for (var i = 0; i < nodes.length; i++) {
        var nodeGroup = nodes[i];
        var currentNodeIds = [];

        for (var j = 0; j < nodeGroup.length; j++) {
          var node = nodeGroup[j];
          var key = '' + i + j;
          currentNodeIds.push(key);
          table[key] = {
            node: node,
            lastCount: 0
          };
          graph[key] = {};

          for (var n = 0; n < prevNodeIds.length; n++) {
            var prevNodeId = prevNodeIds[n];

            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version); // switch cost
            }
          }
        }

        prevNodeIds = currentNodeIds;
      }

      for (n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]]['end'] = 0;
      }

      return {
        map: graph,
        table: table
      };
    }
    /**
     * Builds a segment from a specified data and mode.
     * If a mode is not specified, the more suitable will be used.
     *
     * @param  {String} data             Input data
     * @param  {Mode | String} modesHint Data mode
     * @return {Segment}                 Segment
     */


    function buildSingleSegment(data, modesHint) {
      var mode;
      var bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode); // Make sure data can be encoded

      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '"' + ' cannot be encoded with mode ' + Mode.toString(mode) + '.\n Suggested mode is: ' + Mode.toString(bestMode));
      } // Use Mode.BYTE if Kanji support is disabled


      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }

      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);

        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);

        case Mode.KANJI:
          return new KanjiData(data);

        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    /**
     * Builds a list of segments from an array.
     * Array can contain Strings or Objects with segment's info.
     *
     * For each item which is a string, will be generated a segment with the given
     * string and the more appropriate encoding mode.
     *
     * For each item which is an object, will be generated a segment with the given
     * data and mode.
     * Objects must contain at least the property "data".
     * If property "mode" is not present, the more suitable mode will be used.
     *
     * @param  {Array} array Array of objects with segments data
     * @return {Array}       Array of Segments
     */


    exports.fromArray = function fromArray(array) {
      return array.reduce(function (acc, seg) {
        if (typeof seg === 'string') {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }

        return acc;
      }, []);
    };
    /**
     * Builds an optimized sequence of segments from a string,
     * which will produce the shortest possible bitstream.
     *
     * @param  {String} data    Input string
     * @param  {Number} version QR Code version
     * @return {Array}          Array of segments
     */


    exports.fromString = function fromString(data, version) {
      var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      var nodes = buildNodes(segs);
      var graph = buildGraph(nodes, version);
      var path = dijkstra$1.find_path(graph.map, 'start', 'end');
      var optimizedSegs = [];

      for (var i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }

      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    /**
     * Splits a string in various segments with the modes which
     * best represent their content.
     * The produced segments are far from being optimized.
     * The output of this function is only used to estimate a QR Code version
     * which may contain the data.
     *
     * @param  {string} data Input string
     * @return {Array}       Array of segments
     */


    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));
    };
  })(segments);

  var BufferUtil = typedarrayBuffer;
  var Utils$1 = utils$1;
  var ECLevel = errorCorrectionLevel;
  var BitBuffer = bitBuffer;
  var BitMatrix = bitMatrix;
  var AlignmentPattern = alignmentPattern;
  var FinderPattern = finderPattern;
  var MaskPattern = maskPattern;
  var ECCode = errorCorrectionCode;
  var ReedSolomonEncoder = reedSolomonEncoder;
  var Version = version;
  var FormatInfo = formatInfo;
  var Mode = mode;
  var Segments = segments;
  var isArray = isarray;
  /**
   * QRCode for JavaScript
   *
   * modified by Ryan Day for nodejs support
   * Copyright (c) 2011 Ryan Day
   *
   * Licensed under the MIT license:
   *   http://www.opensource.org/licenses/mit-license.php
   *
  //---------------------------------------------------------------------
  // QRCode for JavaScript
  //
  // Copyright (c) 2009 Kazuhiko Arase
  //
  // URL: http://www.d-project.com/
  //
  // Licensed under the MIT license:
  //   http://www.opensource.org/licenses/mit-license.php
  //
  // The word "QR Code" is registered trademark of
  // DENSO WAVE INCORPORATED
  //   http://www.denso-wave.com/qrcode/faqpatent-e.html
  //
  //---------------------------------------------------------------------
  */

  /**
   * Add finder patterns bits to matrix
   *
   * @param  {BitMatrix} matrix  Modules matrix
   * @param  {Number}    version QR Code version
   */

  function setupFinderPattern(matrix, version) {
    var size = matrix.size;
    var pos = FinderPattern.getPositions(version);

    for (var i = 0; i < pos.length; i++) {
      var row = pos[i][0];
      var col = pos[i][1];

      for (var r = -1; r <= 7; r++) {
        if (row + r <= -1 || size <= row + r) continue;

        for (var c = -1; c <= 7; c++) {
          if (col + c <= -1 || size <= col + c) continue;

          if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  /**
   * Add timing pattern bits to matrix
   *
   * Note: this function must be called before {@link setupAlignmentPattern}
   *
   * @param  {BitMatrix} matrix Modules matrix
   */


  function setupTimingPattern(matrix) {
    var size = matrix.size;

    for (var r = 8; r < size - 8; r++) {
      var value = r % 2 === 0;
      matrix.set(r, 6, value, true);
      matrix.set(6, r, value, true);
    }
  }
  /**
   * Add alignment patterns bits to matrix
   *
   * Note: this function must be called after {@link setupTimingPattern}
   *
   * @param  {BitMatrix} matrix  Modules matrix
   * @param  {Number}    version QR Code version
   */


  function setupAlignmentPattern(matrix, version) {
    var pos = AlignmentPattern.getPositions(version);

    for (var i = 0; i < pos.length; i++) {
      var row = pos[i][0];
      var col = pos[i][1];

      for (var r = -2; r <= 2; r++) {
        for (var c = -2; c <= 2; c++) {
          if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
            matrix.set(row + r, col + c, true, true);
          } else {
            matrix.set(row + r, col + c, false, true);
          }
        }
      }
    }
  }
  /**
   * Add version info bits to matrix
   *
   * @param  {BitMatrix} matrix  Modules matrix
   * @param  {Number}    version QR Code version
   */


  function setupVersionInfo(matrix, version) {
    var size = matrix.size;
    var bits = Version.getEncodedBits(version);
    var row, col, mod;

    for (var i = 0; i < 18; i++) {
      row = Math.floor(i / 3);
      col = i % 3 + size - 8 - 3;
      mod = (bits >> i & 1) === 1;
      matrix.set(row, col, mod, true);
      matrix.set(col, row, mod, true);
    }
  }
  /**
   * Add format info bits to matrix
   *
   * @param  {BitMatrix} matrix               Modules matrix
   * @param  {ErrorCorrectionLevel}    errorCorrectionLevel Error correction level
   * @param  {Number}    maskPattern          Mask pattern reference value
   */


  function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
    var size = matrix.size;
    var bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
    var i, mod;

    for (i = 0; i < 15; i++) {
      mod = (bits >> i & 1) === 1; // vertical

      if (i < 6) {
        matrix.set(i, 8, mod, true);
      } else if (i < 8) {
        matrix.set(i + 1, 8, mod, true);
      } else {
        matrix.set(size - 15 + i, 8, mod, true);
      } // horizontal


      if (i < 8) {
        matrix.set(8, size - i - 1, mod, true);
      } else if (i < 9) {
        matrix.set(8, 15 - i - 1 + 1, mod, true);
      } else {
        matrix.set(8, 15 - i - 1, mod, true);
      }
    } // fixed module


    matrix.set(size - 8, 8, 1, true);
  }
  /**
   * Add encoded data bits to matrix
   *
   * @param  {BitMatrix} matrix Modules matrix
   * @param  {Buffer}    data   Data codewords
   */


  function setupData(matrix, data) {
    var size = matrix.size;
    var inc = -1;
    var row = size - 1;
    var bitIndex = 7;
    var byteIndex = 0;

    for (var col = size - 1; col > 0; col -= 2) {
      if (col === 6) col--;

      while (true) {
        for (var c = 0; c < 2; c++) {
          if (!matrix.isReserved(row, col - c)) {
            var dark = false;

            if (byteIndex < data.length) {
              dark = (data[byteIndex] >>> bitIndex & 1) === 1;
            }

            matrix.set(row, col - c, dark);
            bitIndex--;

            if (bitIndex === -1) {
              byteIndex++;
              bitIndex = 7;
            }
          }
        }

        row += inc;

        if (row < 0 || size <= row) {
          row -= inc;
          inc = -inc;
          break;
        }
      }
    }
  }
  /**
   * Create encoded codewords from data input
   *
   * @param  {Number}   version              QR Code version
   * @param  {ErrorCorrectionLevel}   errorCorrectionLevel Error correction level
   * @param  {ByteData} data                 Data input
   * @return {Buffer}                        Buffer containing encoded codewords
   */


  function createData(version, errorCorrectionLevel, segments) {
    // Prepare data buffer
    var buffer = new BitBuffer();
    segments.forEach(function (data) {
      // prefix data with mode indicator (4 bits)
      buffer.put(data.mode.bit, 4); // Prefix data with character count indicator.
      // The character count indicator is a string of bits that represents the
      // number of characters that are being encoded.
      // The character count indicator must be placed after the mode indicator
      // and must be a certain number of bits long, depending on the QR version
      // and data mode
      // @see {@link Mode.getCharCountIndicator}.

      buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version)); // add binary data sequence to buffer

      data.write(buffer);
    }); // Calculate required number of bits

    var totalCodewords = Utils$1.getSymbolTotalCodewords(version);
    var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
    var dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8; // Add a terminator.
    // If the bit string is shorter than the total number of required bits,
    // a terminator of up to four 0s must be added to the right side of the string.
    // If the bit string is more than four bits shorter than the required number of bits,
    // add four 0s to the end.

    if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
      buffer.put(0, 4);
    } // If the bit string is fewer than four bits shorter, add only the number of 0s that
    // are needed to reach the required number of bits.
    // After adding the terminator, if the number of bits in the string is not a multiple of 8,
    // pad the string on the right with 0s to make the string's length a multiple of 8.


    while (buffer.getLengthInBits() % 8 !== 0) {
      buffer.putBit(0);
    } // Add pad bytes if the string is still shorter than the total number of required bits.
    // Extend the buffer to fill the data capacity of the symbol corresponding to
    // the Version and Error Correction Level by adding the Pad Codewords 11101100 (0xEC)
    // and 00010001 (0x11) alternately.


    var remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;

    for (var i = 0; i < remainingByte; i++) {
      buffer.put(i % 2 ? 0x11 : 0xEC, 8);
    }

    return createCodewords(buffer, version, errorCorrectionLevel);
  }
  /**
   * Encode input data with Reed-Solomon and return codewords with
   * relative error correction bits
   *
   * @param  {BitBuffer} bitBuffer            Data to encode
   * @param  {Number}    version              QR Code version
   * @param  {ErrorCorrectionLevel} errorCorrectionLevel Error correction level
   * @return {Buffer}                         Buffer containing encoded codewords
   */


  function createCodewords(bitBuffer, version, errorCorrectionLevel) {
    // Total codewords for this QR code version (Data + Error correction)
    var totalCodewords = Utils$1.getSymbolTotalCodewords(version); // Total number of error correction codewords

    var ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel); // Total number of data codewords

    var dataTotalCodewords = totalCodewords - ecTotalCodewords; // Total number of blocks

    var ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel); // Calculate how many blocks each group should contain

    var blocksInGroup2 = totalCodewords % ecTotalBlocks;
    var blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
    var totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
    var dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
    var dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1; // Number of EC codewords is the same for both groups

    var ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1; // Initialize a Reed-Solomon encoder with a generator polynomial of degree ecCount

    var rs = new ReedSolomonEncoder(ecCount);
    var offset = 0;
    var dcData = new Array(ecTotalBlocks);
    var ecData = new Array(ecTotalBlocks);
    var maxDataSize = 0;
    var buffer = BufferUtil.from(bitBuffer.buffer); // Divide the buffer into the required number of blocks

    for (var b = 0; b < ecTotalBlocks; b++) {
      var dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2; // extract a block of data from buffer

      dcData[b] = buffer.slice(offset, offset + dataSize); // Calculate EC codewords for this data block

      ecData[b] = rs.encode(dcData[b]);
      offset += dataSize;
      maxDataSize = Math.max(maxDataSize, dataSize);
    } // Create final data
    // Interleave the data and error correction codewords from each block


    var data = BufferUtil.alloc(totalCodewords);
    var index = 0;
    var i, r; // Add data codewords

    for (i = 0; i < maxDataSize; i++) {
      for (r = 0; r < ecTotalBlocks; r++) {
        if (i < dcData[r].length) {
          data[index++] = dcData[r][i];
        }
      }
    } // Apped EC codewords


    for (i = 0; i < ecCount; i++) {
      for (r = 0; r < ecTotalBlocks; r++) {
        data[index++] = ecData[r][i];
      }
    }

    return data;
  }
  /**
   * Build QR Code symbol
   *
   * @param  {String} data                 Input string
   * @param  {Number} version              QR Code version
   * @param  {ErrorCorretionLevel} errorCorrectionLevel Error level
   * @param  {MaskPattern} maskPattern     Mask pattern
   * @return {Object}                      Object containing symbol data
   */


  function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
    var segments;

    if (isArray(data)) {
      segments = Segments.fromArray(data);
    } else if (typeof data === 'string') {
      var estimatedVersion = version;

      if (!estimatedVersion) {
        var rawSegments = Segments.rawSplit(data); // Estimate best version that can contain raw splitted segments

        estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
      } // Build optimized segments
      // If estimated version is undefined, try with the highest version


      segments = Segments.fromString(data, estimatedVersion || 40);
    } else {
      throw new Error('Invalid data');
    } // Get the min version that can contain data


    var bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel); // If no version is found, data cannot be stored

    if (!bestVersion) {
      throw new Error('The amount of data is too big to be stored in a QR Code');
    } // If not specified, use min version as default


    if (!version) {
      version = bestVersion; // Check if the specified version can contain the data
    } else if (version < bestVersion) {
      throw new Error('\n' + 'The chosen QR Code version cannot contain this amount of data.\n' + 'Minimum version required to store current data is: ' + bestVersion + '.\n');
    }

    var dataBits = createData(version, errorCorrectionLevel, segments); // Allocate matrix buffer

    var moduleCount = Utils$1.getSymbolSize(version);
    var modules = new BitMatrix(moduleCount); // Add function modules

    setupFinderPattern(modules, version);
    setupTimingPattern(modules);
    setupAlignmentPattern(modules, version); // Add temporary dummy bits for format info just to set them as reserved.
    // This is needed to prevent these bits from being masked by {@link MaskPattern.applyMask}
    // since the masking operation must be performed only on the encoding region.
    // These blocks will be replaced with correct values later in code.

    setupFormatInfo(modules, errorCorrectionLevel, 0);

    if (version >= 7) {
      setupVersionInfo(modules, version);
    } // Add data codewords


    setupData(modules, dataBits);

    if (isNaN(maskPattern)) {
      // Find best mask pattern
      maskPattern = MaskPattern.getBestMask(modules, setupFormatInfo.bind(null, modules, errorCorrectionLevel));
    } // Apply mask pattern


    MaskPattern.applyMask(maskPattern, modules); // Replace format info bits with correct values

    setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
    return {
      modules: modules,
      version: version,
      errorCorrectionLevel: errorCorrectionLevel,
      maskPattern: maskPattern,
      segments: segments
    };
  }
  /**
   * QR Code
   *
   * @param {String | Array} data                 Input data
   * @param {Object} options                      Optional configurations
   * @param {Number} options.version              QR Code version
   * @param {String} options.errorCorrectionLevel Error correction level
   * @param {Function} options.toSJISFunc         Helper func to convert utf8 to sjis
   */


  qrcode.create = function create(data, options) {
    if (typeof data === 'undefined' || data === '') {
      throw new Error('No input text');
    }

    var errorCorrectionLevel = ECLevel.M;
    var version;
    var mask;

    if (typeof options !== 'undefined') {
      // Use higher error correction level as default
      errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
      version = Version.from(options.version);
      mask = MaskPattern.from(options.maskPattern);

      if (options.toSJISFunc) {
        Utils$1.setToSJISFunction(options.toSJISFunc);
      }
    }

    return createSymbol(data, version, errorCorrectionLevel, mask);
  };

  var canvas = {};

  var utils = {};

  (function (exports) {
    function hex2rgba(hex) {
      if (typeof hex === 'number') {
        hex = hex.toString();
      }

      if (typeof hex !== 'string') {
        throw new Error('Color should be defined as hex string');
      }

      var hexCode = hex.slice().replace('#', '').split('');

      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error('Invalid hex color: ' + hex);
      } // Convert from short to long form (fff -> ffffff)


      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function (c) {
          return [c, c];
        }));
      } // Add default alpha value


      if (hexCode.length === 6) hexCode.push('F', 'F');
      var hexValue = parseInt(hexCode.join(''), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: '#' + hexCode.slice(0, 6).join('')
      };
    }

    exports.getOptions = function getOptions(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      var margin = typeof options.margin === 'undefined' || options.margin === null || options.margin < 0 ? 4 : options.margin;
      var width = options.width && options.width >= 21 ? options.width : undefined;
      var scale = options.scale || 4;
      return {
        width: width,
        scale: width ? 4 : scale,
        margin: margin,
        color: {
          dark: hex2rgba(options.color.dark || '#000000ff'),
          light: hex2rgba(options.color.light || '#ffffffff')
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };

    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };

    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      var scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };

    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      var size = qr.modules.size;
      var data = qr.modules.data;
      var scale = exports.getScale(size, opts);
      var symbolSize = Math.floor((size + opts.margin * 2) * scale);
      var scaledMargin = opts.margin * scale;
      var palette = [opts.color.light, opts.color.dark];

      for (var i = 0; i < symbolSize; i++) {
        for (var j = 0; j < symbolSize; j++) {
          var posDst = (i * symbolSize + j) * 4;
          var pxColor = opts.color.light;

          if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            var iSrc = Math.floor((i - scaledMargin) / scale);
            var jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }

          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  })(utils);

  (function (exports) {
    var Utils = utils;

    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + 'px';
      canvas.style.width = size + 'px';
    }

    function getCanvasElement() {
      try {
        return document.createElement('canvas');
      } catch (e) {
        throw new Error('You need to specify a canvas element');
      }
    }

    exports.render = function render(qrData, canvas, options) {
      var opts = options;
      var canvasEl = canvas;

      if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = undefined;
      }

      if (!canvas) {
        canvasEl = getCanvasElement();
      }

      opts = Utils.getOptions(opts);
      var size = Utils.getImageWidth(qrData.modules.size, opts);
      var ctx = canvasEl.getContext('2d');
      var image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };

    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      var opts = options;

      if (typeof opts === 'undefined' && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = undefined;
      }

      if (!opts) opts = {};
      var canvasEl = exports.render(qrData, canvas, opts);
      var type = opts.type || 'image/png';
      var rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  })(canvas);

  var svgTag = {};

  var Utils = utils;

  function getColorAttrib(color, attrib) {
    var alpha = color.a / 255;
    var str = attrib + '="' + color.hex + '"';
    return alpha < 1 ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
  }

  function svgCmd(cmd, x, y) {
    var str = cmd + x;
    if (typeof y !== 'undefined') str += ' ' + y;
    return str;
  }

  function qrToPath(data, size, margin) {
    var path = '';
    var moveBy = 0;
    var newRow = false;
    var lineLength = 0;

    for (var i = 0; i < data.length; i++) {
      var col = Math.floor(i % size);
      var row = Math.floor(i / size);
      if (!col && !newRow) newRow = true;

      if (data[i]) {
        lineLength++;

        if (!(i > 0 && col > 0 && data[i - 1])) {
          path += newRow ? svgCmd('M', col + margin, 0.5 + row + margin) : svgCmd('m', moveBy, 0);
          moveBy = 0;
          newRow = false;
        }

        if (!(col + 1 < size && data[i + 1])) {
          path += svgCmd('h', lineLength);
          lineLength = 0;
        }
      } else {
        moveBy++;
      }
    }

    return path;
  }

  svgTag.render = function render(qrData, options, cb) {
    var opts = Utils.getOptions(options);
    var size = qrData.modules.size;
    var data = qrData.modules.data;
    var qrcodesize = size + opts.margin * 2;
    var bg = !opts.color.light.a ? '' : '<path ' + getColorAttrib(opts.color.light, 'fill') + ' d="M0 0h' + qrcodesize + 'v' + qrcodesize + 'H0z"/>';
    var path = '<path ' + getColorAttrib(opts.color.dark, 'stroke') + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
    var viewBox = 'viewBox="' + '0 0 ' + qrcodesize + ' ' + qrcodesize + '"';
    var width = !opts.width ? '' : 'width="' + opts.width + '" height="' + opts.width + '" ';
    var svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + '</svg>\n';

    if (typeof cb === 'function') {
      cb(null, svgTag);
    }

    return svgTag;
  };

  var canPromise = canPromise$1;
  var QRCode$1 = qrcode;
  var CanvasRenderer = canvas;
  var SvgRenderer = svgTag;

  function renderCanvas(renderFunc, canvas, text, opts, cb) {
    var args = [].slice.call(arguments, 1);
    var argsNum = args.length;
    var isLastArgCb = typeof args[argsNum - 1] === 'function';

    if (!isLastArgCb && !canPromise()) {
      throw new Error('Callback required as last argument');
    }

    if (isLastArgCb) {
      if (argsNum < 2) {
        throw new Error('Too few arguments provided');
      }

      if (argsNum === 2) {
        cb = text;
        text = canvas;
        canvas = opts = undefined;
      } else if (argsNum === 3) {
        if (canvas.getContext && typeof cb === 'undefined') {
          cb = opts;
          opts = undefined;
        } else {
          cb = opts;
          opts = text;
          text = canvas;
          canvas = undefined;
        }
      }
    } else {
      if (argsNum < 1) {
        throw new Error('Too few arguments provided');
      }

      if (argsNum === 1) {
        text = canvas;
        canvas = opts = undefined;
      } else if (argsNum === 2 && !canvas.getContext) {
        opts = text;
        text = canvas;
        canvas = undefined;
      }

      return new Promise(function (resolve, reject) {
        try {
          var data = QRCode$1.create(text, opts);
          resolve(renderFunc(data, canvas, opts));
        } catch (e) {
          reject(e);
        }
      });
    }

    try {
      var data = QRCode$1.create(text, opts);
      cb(null, renderFunc(data, canvas, opts));
    } catch (e) {
      cb(e);
    }
  }

  browser.create = QRCode$1.create;
  browser.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
  browser.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL); // only svg for now.

  browser.toString = renderCanvas.bind(null, function (data, _, opts) {
    return SvgRenderer.render(data, opts);
  });

  var toggleSelection = function toggleSelection() {
    var selection = document.getSelection();

    if (!selection.rangeCount) {
      return function () {};
    }

    var active = document.activeElement;
    var ranges = [];

    for (var i = 0; i < selection.rangeCount; i++) {
      ranges.push(selection.getRangeAt(i));
    }

    switch (active.tagName.toUpperCase()) {
      // .toUpperCase handles XHTML
      case 'INPUT':
      case 'TEXTAREA':
        active.blur();
        break;

      default:
        active = null;
        break;
    }

    selection.removeAllRanges();
    return function () {
      selection.type === 'Caret' && selection.removeAllRanges();

      if (!selection.rangeCount) {
        ranges.forEach(function (range) {
          selection.addRange(range);
        });
      }

      active && active.focus();
    };
  };

  var deselectCurrent = toggleSelection;
  var clipboardToIE11Formatting = {
    "text/plain": "Text",
    "text/html": "Url",
    "default": "Text"
  };
  var defaultMessage = "Copy to clipboard: #{key}, Enter";

  function format(message) {
    var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
    return message.replace(/#{\s*key\s*}/g, copyKey);
  }

  function copy$1(text, options) {
    var debug,
        message,
        reselectPrevious,
        range,
        selection,
        mark,
        success = false;

    if (!options) {
      options = {};
    }

    debug = options.debug || false;

    try {
      reselectPrevious = deselectCurrent();
      range = document.createRange();
      selection = document.getSelection();
      mark = document.createElement("span");
      mark.textContent = text; // avoid screen readers from reading out loud the text

      mark.ariaHidden = "true"; // reset user styles for span element

      mark.style.all = "unset"; // prevents scrolling to the end of the page

      mark.style.position = "fixed";
      mark.style.top = 0;
      mark.style.clip = "rect(0, 0, 0, 0)"; // used to preserve spaces and line breaks

      mark.style.whiteSpace = "pre"; // do not inherit user-select (it may be `none`)

      mark.style.webkitUserSelect = "text";
      mark.style.MozUserSelect = "text";
      mark.style.msUserSelect = "text";
      mark.style.userSelect = "text";
      mark.addEventListener("copy", function (e) {
        e.stopPropagation();

        if (options.format) {
          e.preventDefault();

          if (typeof e.clipboardData === "undefined") {
            // IE 11
            debug && console.warn("unable to use e.clipboardData");
            debug && console.warn("trying IE specific stuff");
            window.clipboardData.clearData();
            var format = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
            window.clipboardData.setData(format, text);
          } else {
            // all other browsers
            e.clipboardData.clearData();
            e.clipboardData.setData(options.format, text);
          }
        }

        if (options.onCopy) {
          e.preventDefault();
          options.onCopy(e.clipboardData);
        }
      });
      document.body.appendChild(mark);
      range.selectNodeContents(mark);
      selection.addRange(range);
      var successful = document.execCommand("copy");

      if (!successful) {
        throw new Error("copy command was unsuccessful");
      }

      success = true;
    } catch (err) {
      debug && console.error("unable to copy using execCommand: ", err);
      debug && console.warn("trying IE specific stuff");

      try {
        window.clipboardData.setData(options.format || "text", text);
        options.onCopy && options.onCopy(window.clipboardData);
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using clipboardData: ", err);
        debug && console.error("falling back to prompt");
        message = format("message" in options ? options.message : defaultMessage);
        window.prompt(message, text);
      }
    } finally {
      if (selection) {
        if (typeof selection.removeRange == "function") {
          selection.removeRange(range);
        } else {
          selection.removeAllRanges();
        }
      }

      if (mark) {
        document.body.removeChild(mark);
      }

      reselectPrevious();
    }

    return success;
  }

  var copyToClipboard = copy$1;

  var n,
      u$1,
      i$1,
      t$1,
      r$1,
      o$1,
      f$1,
      e$1 = {},
      c$1 = [],
      s$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

  function a$1(n, l) {
    for (var u in l) {
      n[u] = l[u];
    }

    return n;
  }

  function v$1(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
  }

  function h$1(n, l, u) {
    var i,
        t = arguments,
        r = {};

    for (i in l) {
      "key" !== i && "ref" !== i && (r[i] = l[i]);
    }

    if (arguments.length > 3) for (u = [u], i = 3; i < arguments.length; i++) {
      u.push(t[i]);
    }
    if (null != u && (r.children = u), "function" == typeof n && null != n.defaultProps) for (i in n.defaultProps) {
      void 0 === r[i] && (r[i] = n.defaultProps[i]);
    }
    return p$1(n, r, l && l.key, l && l.ref, null);
  }

  function p$1(l, u, i, t, r) {
    var o = {
      type: l,
      props: u,
      key: i,
      ref: t,
      __k: null,
      __: null,
      __b: 0,
      __e: null,
      __d: void 0,
      __c: null,
      constructor: void 0,
      __v: r
    };
    return null == r && (o.__v = o), n.vnode && n.vnode(o), o;
  }

  function y$1() {
    return {};
  }

  function d$1(n) {
    return n.children;
  }

  function m$1(n, l) {
    this.props = n, this.context = l;
  }

  function w$2(n, l) {
    if (null == l) return n.__ ? w$2(n.__, n.__.__k.indexOf(n) + 1) : null;

    for (var u; l < n.__k.length; l++) {
      if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    }

    return "function" == typeof n.type ? w$2(n) : null;
  }

  function k$1(n) {
    var l, u;

    if (null != (n = n.__) && null != n.__c) {
      for (n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++) {
        if (null != (u = n.__k[l]) && null != u.__e) {
          n.__e = n.__c.base = u.__e;
          break;
        }
      }

      return k$1(n);
    }
  }

  function g$1(l) {
    (!l.__d && (l.__d = !0) && u$1.push(l) && !i$1++ || r$1 !== n.debounceRendering) && ((r$1 = n.debounceRendering) || t$1)(_$2);
  }

  function _$2() {
    for (var n; i$1 = u$1.length;) {
      n = u$1.sort(function (n, l) {
        return n.__v.__b - l.__v.__b;
      }), u$1 = [], n.some(function (n) {
        var l, u, i, t, r, o, f;
        n.__d && (o = (r = (l = n).__v).__e, (f = l.__P) && (u = [], (i = a$1({}, r)).__v = i, t = A$2(f, r, i, l.__n, void 0 !== f.ownerSVGElement, null, u, null == o ? w$2(r) : o), T$2(u, r), t != o && k$1(r)));
      });
    }
  }

  function b(n, l, u, i, t, r, o, f, s) {
    var a,
        h,
        p,
        y,
        d,
        m,
        k,
        g = u && u.__k || c$1,
        _ = g.length;
    if (f == e$1 && (f = null != r ? r[0] : _ ? w$2(u, 0) : null), a = 0, l.__k = x$1(l.__k, function (u) {
      if (null != u) {
        if (u.__ = l, u.__b = l.__b + 1, null === (p = g[a]) || p && u.key == p.key && u.type === p.type) g[a] = void 0;else for (h = 0; h < _; h++) {
          if ((p = g[h]) && u.key == p.key && u.type === p.type) {
            g[h] = void 0;
            break;
          }

          p = null;
        }

        if (y = A$2(n, u, p = p || e$1, i, t, r, o, f, s), (h = u.ref) && p.ref != h && (k || (k = []), p.ref && k.push(p.ref, null, u), k.push(h, u.__c || y, u)), null != y) {
          var c;
          if (null == m && (m = y), void 0 !== u.__d) c = u.__d, u.__d = void 0;else if (r == p || y != f || null == y.parentNode) {
            n: if (null == f || f.parentNode !== n) n.appendChild(y), c = null;else {
              for (d = f, h = 0; (d = d.nextSibling) && h < _; h += 2) {
                if (d == y) break n;
              }

              n.insertBefore(y, f), c = f;
            }

            "option" == l.type && (n.value = "");
          }
          f = void 0 !== c ? c : y.nextSibling, "function" == typeof l.type && (l.__d = f);
        } else f && p.__e == f && f.parentNode != n && (f = w$2(p));
      }

      return a++, u;
    }), l.__e = m, null != r && "function" != typeof l.type) for (a = r.length; a--;) {
      null != r[a] && v$1(r[a]);
    }

    for (a = _; a--;) {
      null != g[a] && D$1(g[a], g[a]);
    }

    if (k) for (a = 0; a < k.length; a++) {
      j$1(k[a], k[++a], k[++a]);
    }
  }

  function x$1(n, l, u) {
    if (null == u && (u = []), null == n || "boolean" == typeof n) l && u.push(l(null));else if (Array.isArray(n)) for (var i = 0; i < n.length; i++) {
      x$1(n[i], l, u);
    } else u.push(l ? l("string" == typeof n || "number" == typeof n ? p$1(null, n, null, null, n) : null != n.__e || null != n.__c ? p$1(n.type, n.props, n.key, null, n.__v) : n) : n);
    return u;
  }

  function P$1(n, l, u, i, t) {
    var r;

    for (r in u) {
      "children" === r || "key" === r || r in l || N$1(n, r, null, u[r], i);
    }

    for (r in l) {
      t && "function" != typeof l[r] || "children" === r || "key" === r || "value" === r || "checked" === r || u[r] === l[r] || N$1(n, r, l[r], u[r], i);
    }
  }

  function C$1(n, l, u) {
    "-" === l[0] ? n.setProperty(l, u) : n[l] = "number" == typeof u && !1 === s$1.test(l) ? u + "px" : null == u ? "" : u;
  }

  function N$1(n, l, u, i, t) {
    var r, o, f, e, c;
    if (t ? "className" === l && (l = "class") : "class" === l && (l = "className"), "style" === l) {
      if (r = n.style, "string" == typeof u) r.cssText = u;else {
        if ("string" == typeof i && (r.cssText = "", i = null), i) for (e in i) {
          u && e in u || C$1(r, e, "");
        }
        if (u) for (c in u) {
          i && u[c] === i[c] || C$1(r, c, u[c]);
        }
      }
    } else "o" === l[0] && "n" === l[1] ? (o = l !== (l = l.replace(/Capture$/, "")), f = l.toLowerCase(), l = (f in n ? f : l).slice(2), u ? (i || n.addEventListener(l, z$1, o), (n.l || (n.l = {}))[l] = u) : n.removeEventListener(l, z$1, o)) : "list" !== l && "tagName" !== l && "form" !== l && "type" !== l && "size" !== l && !t && l in n ? n[l] = null == u ? "" : u : "function" != typeof u && "dangerouslySetInnerHTML" !== l && (l !== (l = l.replace(/^xlink:?/, "")) ? null == u || !1 === u ? n.removeAttributeNS("http://www.w3.org/1999/xlink", l.toLowerCase()) : n.setAttributeNS("http://www.w3.org/1999/xlink", l.toLowerCase(), u) : null == u || !1 === u && !/^ar/.test(l) ? n.removeAttribute(l) : n.setAttribute(l, u));
  }

  function z$1(l) {
    this.l[l.type](n.event ? n.event(l) : l);
  }

  function A$2(l, u, i, t, r, o, f, e, c) {
    var s,
        v,
        h,
        p,
        y,
        w,
        k,
        g,
        _,
        x,
        P = u.type;

    if (void 0 !== u.constructor) return null;
    (s = n.__b) && s(u);

    try {
      n: if ("function" == typeof P) {
        if (g = u.props, _ = (s = P.contextType) && t[s.__c], x = s ? _ ? _.props.value : s.__ : t, i.__c ? k = (v = u.__c = i.__c).__ = v.__E : ("prototype" in P && P.prototype.render ? u.__c = v = new P(g, x) : (u.__c = v = new m$1(g, x), v.constructor = P, v.render = E$2), _ && _.sub(v), v.props = g, v.state || (v.state = {}), v.context = x, v.__n = t, h = v.__d = !0, v.__h = []), null == v.__s && (v.__s = v.state), null != P.getDerivedStateFromProps && (v.__s == v.state && (v.__s = a$1({}, v.__s)), a$1(v.__s, P.getDerivedStateFromProps(g, v.__s))), p = v.props, y = v.state, h) null == P.getDerivedStateFromProps && null != v.componentWillMount && v.componentWillMount(), null != v.componentDidMount && v.__h.push(v.componentDidMount);else {
          if (null == P.getDerivedStateFromProps && g !== p && null != v.componentWillReceiveProps && v.componentWillReceiveProps(g, x), !v.__e && null != v.shouldComponentUpdate && !1 === v.shouldComponentUpdate(g, v.__s, x) || u.__v === i.__v && !v.__) {
            for (v.props = g, v.state = v.__s, u.__v !== i.__v && (v.__d = !1), v.__v = u, u.__e = i.__e, u.__k = i.__k, v.__h.length && f.push(v), s = 0; s < u.__k.length; s++) {
              u.__k[s] && (u.__k[s].__ = u);
            }

            break n;
          }

          null != v.componentWillUpdate && v.componentWillUpdate(g, v.__s, x), null != v.componentDidUpdate && v.__h.push(function () {
            v.componentDidUpdate(p, y, w);
          });
        }
        v.context = x, v.props = g, v.state = v.__s, (s = n.__r) && s(u), v.__d = !1, v.__v = u, v.__P = l, s = v.render(v.props, v.state, v.context), u.__k = null != s && s.type == d$1 && null == s.key ? s.props.children : Array.isArray(s) ? s : [s], null != v.getChildContext && (t = a$1(a$1({}, t), v.getChildContext())), h || null == v.getSnapshotBeforeUpdate || (w = v.getSnapshotBeforeUpdate(p, y)), b(l, u, i, t, r, o, f, e, c), v.base = u.__e, v.__h.length && f.push(v), k && (v.__E = v.__ = null), v.__e = !1;
      } else null == o && u.__v === i.__v ? (u.__k = i.__k, u.__e = i.__e) : u.__e = $$1(i.__e, u, i, t, r, o, f, c);

      (s = n.diffed) && s(u);
    } catch (l) {
      u.__v = null, n.__e(l, u, i);
    }

    return u.__e;
  }

  function T$2(l, u) {
    n.__c && n.__c(u, l), l.some(function (u) {
      try {
        l = u.__h, u.__h = [], l.some(function (n) {
          n.call(u);
        });
      } catch (l) {
        n.__e(l, u.__v);
      }
    });
  }

  function $$1(n, l, u, i, t, r, o, f) {
    var s,
        a,
        v,
        h,
        p,
        y = u.props,
        d = l.props;
    if (t = "svg" === l.type || t, null != r) for (s = 0; s < r.length; s++) {
      if (null != (a = r[s]) && ((null === l.type ? 3 === a.nodeType : a.localName === l.type) || n == a)) {
        n = a, r[s] = null;
        break;
      }
    }

    if (null == n) {
      if (null === l.type) return document.createTextNode(d);
      n = t ? document.createElementNS("http://www.w3.org/2000/svg", l.type) : document.createElement(l.type, d.is && {
        is: d.is
      }), r = null, f = !1;
    }

    if (null === l.type) y !== d && n.data != d && (n.data = d);else {
      if (null != r && (r = c$1.slice.call(n.childNodes)), v = (y = u.props || e$1).dangerouslySetInnerHTML, h = d.dangerouslySetInnerHTML, !f) {
        if (y === e$1) for (y = {}, p = 0; p < n.attributes.length; p++) {
          y[n.attributes[p].name] = n.attributes[p].value;
        }
        (h || v) && (h && v && h.__html == v.__html || (n.innerHTML = h && h.__html || ""));
      }

      P$1(n, d, y, t, f), h ? l.__k = [] : (l.__k = l.props.children, b(n, l, u, i, "foreignObject" !== l.type && t, r, o, e$1, f)), f || ("value" in d && void 0 !== (s = d.value) && s !== n.value && N$1(n, "value", s, y.value, !1), "checked" in d && void 0 !== (s = d.checked) && s !== n.checked && N$1(n, "checked", s, y.checked, !1));
    }
    return n;
  }

  function j$1(l, u, i) {
    try {
      "function" == typeof l ? l(u) : l.current = u;
    } catch (l) {
      n.__e(l, i);
    }
  }

  function D$1(l, u, i) {
    var t, r, o;

    if (n.unmount && n.unmount(l), (t = l.ref) && (t.current && t.current !== l.__e || j$1(t, null, u)), i || "function" == typeof l.type || (i = null != (r = l.__e)), l.__e = l.__d = void 0, null != (t = l.__c)) {
      if (t.componentWillUnmount) try {
        t.componentWillUnmount();
      } catch (l) {
        n.__e(l, u);
      }
      t.base = t.__P = null;
    }

    if (t = l.__k) for (o = 0; o < t.length; o++) {
      t[o] && D$1(t[o], u, i);
    }
    null != r && v$1(r);
  }

  function E$2(n, l, u) {
    return this.constructor(n, u);
  }

  function H$1(l, u, i) {
    var t, r, f;
    n.__ && n.__(l, u), r = (t = i === o$1) ? null : i && i.__k || u.__k, l = h$1(d$1, null, [l]), f = [], A$2(u, (t ? u : i || u).__k = l, r || e$1, e$1, void 0 !== u.ownerSVGElement, i && !t ? [i] : r ? null : c$1.slice.call(u.childNodes), f, i || e$1, t), T$2(f, l);
  }

  function I$1(n, l) {
    H$1(n, l, o$1);
  }

  function L$1(n, l) {
    var u, i;

    for (i in l = a$1(a$1({}, n.props), l), arguments.length > 2 && (l.children = c$1.slice.call(arguments, 2)), u = {}, l) {
      "key" !== i && "ref" !== i && (u[i] = l[i]);
    }

    return p$1(n.type, u, l.key || n.key, l.ref || n.ref, null);
  }

  function M$1(n) {
    var l = {},
        u = {
      __c: "__cC" + f$1++,
      __: n,
      Consumer: function Consumer(n, l) {
        return n.children(l);
      },
      Provider: function Provider(n) {
        var i,
            t = this;
        return this.getChildContext || (i = [], this.getChildContext = function () {
          return l[u.__c] = t, l;
        }, this.shouldComponentUpdate = function (n) {
          t.props.value !== n.value && i.some(function (l) {
            l.context = n.value, g$1(l);
          });
        }, this.sub = function (n) {
          i.push(n);
          var l = n.componentWillUnmount;

          n.componentWillUnmount = function () {
            i.splice(i.indexOf(n), 1), l && l.call(n);
          };
        }), n.children;
      }
    };
    return u.Consumer.contextType = u, u.Provider.__ = u, u;
  }

  n = {
    __e: function __e(n, l) {
      for (var u, i; l = l.__;) {
        if ((u = l.__c) && !u.__) try {
          if (u.constructor && null != u.constructor.getDerivedStateFromError && (i = !0, u.setState(u.constructor.getDerivedStateFromError(n))), null != u.componentDidCatch && (i = !0, u.componentDidCatch(n)), i) return g$1(u.__E = u);
        } catch (l) {
          n = l;
        }
      }

      throw n;
    }
  }, m$1.prototype.setState = function (n, l) {
    var u;
    u = this.__s !== this.state ? this.__s : this.__s = a$1({}, this.state), "function" == typeof n && (n = n(u, this.props)), n && a$1(u, n), null != n && this.__v && (l && this.__h.push(l), g$1(this));
  }, m$1.prototype.forceUpdate = function (n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), g$1(this));
  }, m$1.prototype.render = d$1, u$1 = [], i$1 = 0, t$1 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, o$1 = e$1, f$1 = 0;

  var t,
      u,
      r,
      i = 0,
      o = [],
      c = n.__r,
      f = n.diffed,
      e = n.__c,
      a = n.unmount;

  function v(t, r) {
    n.__h && n.__h(u, t, i || r), i = 0;
    var o = u.__H || (u.__H = {
      __: [],
      __h: []
    });
    return t >= o.__.length && o.__.push({}), o.__[t];
  }

  function m(n) {
    return i = 1, p(E$1, n);
  }

  function p(n, r, i) {
    var o = v(t++, 2);
    return o.__c || (o.__c = u, o.__ = [i ? i(r) : E$1(void 0, r), function (t) {
      var u = n(o.__[0], t);
      o.__[0] !== u && (o.__[0] = u, o.__c.setState({}));
    }]), o.__;
  }

  function l(r, i) {
    var o = v(t++, 3);
    !n.__s && x(o.__H, i) && (o.__ = r, o.__H = i, u.__H.__h.push(o));
  }

  function y(r, i) {
    var o = v(t++, 4);
    !n.__s && x(o.__H, i) && (o.__ = r, o.__H = i, u.__h.push(o));
  }

  function d(n) {
    return i = 5, h(function () {
      return {
        current: n
      };
    }, []);
  }

  function s(n, t, u) {
    i = 6, y(function () {
      "function" == typeof n ? n(t()) : n && (n.current = t());
    }, null == u ? u : u.concat(n));
  }

  function h(n, u) {
    var r = v(t++, 7);
    return x(r.__H, u) ? (r.__H = u, r.__h = n, r.__ = n()) : r.__;
  }

  function T$1(n, t) {
    return i = 8, h(function () {
      return n;
    }, t);
  }

  function w$1(n) {
    var r = u.context[n.__c],
        i = v(t++, 9);
    return i.__c = n, r ? (null == i.__ && (i.__ = !0, r.sub(u)), r.props.value) : n.__;
  }

  function A$1(t, u) {
    n.useDebugValue && n.useDebugValue(u ? u(t) : t);
  }

  function F$1(n) {
    var r = v(t++, 10),
        i = m();
    return r.__ = n, u.componentDidCatch || (u.componentDidCatch = function (n) {
      r.__ && r.__(n), i[1](n);
    }), [i[0], function () {
      i[1](void 0);
    }];
  }

  function _$1() {
    o.some(function (t) {
      if (t.__P) try {
        t.__H.__h.forEach(g), t.__H.__h.forEach(q$1), t.__H.__h = [];
      } catch (u) {
        return t.__H.__h = [], n.__e(u, t.__v), !0;
      }
    }), o = [];
  }

  function g(n) {
    n.t && n.t();
  }

  function q$1(n) {
    var t = n.__();

    "function" == typeof t && (n.t = t);
  }

  function x(n, t) {
    return !n || t.some(function (t, u) {
      return t !== n[u];
    });
  }

  function E$1(n, t) {
    return "function" == typeof t ? t(n) : t;
  }

  n.__r = function (n) {
    c && c(n), t = 0, (u = n.__c).__H && (u.__H.__h.forEach(g), u.__H.__h.forEach(q$1), u.__H.__h = []);
  }, n.diffed = function (t) {
    f && f(t);
    var u = t.__c;

    if (u) {
      var i = u.__H;
      i && i.__h.length && (1 !== o.push(u) && r === n.requestAnimationFrame || ((r = n.requestAnimationFrame) || function (n) {
        var t,
            u = function u() {
          clearTimeout(r), cancelAnimationFrame(t), setTimeout(n);
        },
            r = setTimeout(u, 100);

        "undefined" != typeof window && (t = requestAnimationFrame(u));
      })(_$1));
    }
  }, n.__c = function (t, u) {
    u.some(function (t) {
      try {
        t.__h.forEach(g), t.__h = t.__h.filter(function (n) {
          return !n.__ || q$1(n);
        });
      } catch (r) {
        u.some(function (n) {
          n.__h && (n.__h = []);
        }), u = [], n.__e(r, t.__v);
      }
    }), e && e(t, u);
  }, n.unmount = function (t) {
    a && a(t);
    var u = t.__c;

    if (u) {
      var r = u.__H;
      if (r) try {
        r.__.forEach(function (n) {
          return n.t && n.t();
        });
      } catch (t) {
        n.__e(t, u.__v);
      }
    }
  };

  function E(n, t) {
    for (var e in t) {
      n[e] = t[e];
    }

    return n;
  }

  function w(n, t) {
    for (var e in n) {
      if ("__source" !== e && !(e in t)) return !0;
    }

    for (var r in t) {
      if ("__source" !== r && n[r] !== t[r]) return !0;
    }

    return !1;
  }

  var C = function (n) {
    var t, e;

    function r(t) {
      var e;
      return (e = n.call(this, t) || this).isPureReactComponent = !0, e;
    }

    return e = n, (t = r).prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e, r.prototype.shouldComponentUpdate = function (n, t) {
      return w(this.props, n) || w(this.state, t);
    }, r;
  }(m$1);

  function _(n, t) {
    function e(n) {
      var e = this.props.ref,
          r = e == n.ref;
      return !r && e && (e.call ? e(null) : e.current = null), t ? !t(this.props, n) || !r : w(this.props, n);
    }

    function r(t) {
      return this.shouldComponentUpdate = e, h$1(n, E({}, t));
    }

    return r.prototype.isReactComponent = !0, r.displayName = "Memo(" + (n.displayName || n.name) + ")", r.t = !0, r;
  }

  var A = n.__b;

  function S(n) {
    function t(t) {
      var e = E({}, t);
      return delete e.ref, n(e, t.ref);
    }

    return t.prototype.isReactComponent = t.t = !0, t.displayName = "ForwardRef(" + (n.displayName || n.name) + ")", t;
  }

  n.__b = function (n) {
    n.type && n.type.t && n.ref && (n.props.ref = n.ref, n.ref = null), A && A(n);
  };

  var k = function k(n, t) {
    return n ? x$1(n).reduce(function (n, e, r) {
      return n.concat(t(e, r));
    }, []) : null;
  },
      R = {
    map: k,
    forEach: k,
    count: function count(n) {
      return n ? x$1(n).length : 0;
    },
    only: function only(n) {
      if (1 !== (n = x$1(n)).length) throw new Error("Children.only() expects only one child.");
      return n[0];
    },
    toArray: x$1
  },
      F = n.__e;

  function N(n) {
    return n && ((n = E({}, n)).__c = null, n.__k = n.__k && n.__k.map(N)), n;
  }

  function U() {
    this.__u = 0, this.o = null, this.__b = null;
  }

  function M(n) {
    var t = n.__.__c;
    return t && t.u && t.u(n);
  }

  function L(n) {
    var t, e, r;

    function o(o) {
      if (t || (t = n()).then(function (n) {
        e = n["default"] || n;
      }, function (n) {
        r = n;
      }), r) throw r;
      if (!e) throw t;
      return h$1(e, o);
    }

    return o.displayName = "Lazy", o.t = !0, o;
  }

  function O() {
    this.i = null, this.l = null;
  }

  n.__e = function (n, t, e) {
    if (n.then) for (var r, o = t; o = o.__;) {
      if ((r = o.__c) && r.__c) return r.__c(n, t.__c);
    }
    F(n, t, e);
  }, (U.prototype = new m$1()).__c = function (n, t) {
    var e = this;
    null == e.o && (e.o = []), e.o.push(t);

    var r = M(e.__v),
        o = !1,
        u = function u() {
      o || (o = !0, r ? r(i) : i());
    };

    t.__c = t.componentWillUnmount, t.componentWillUnmount = function () {
      u(), t.__c && t.__c();
    };

    var i = function i() {
      var n;
      if (! --e.__u) for (e.__v.__k[0] = e.state.u, e.setState({
        u: e.__b = null
      }); n = e.o.pop();) {
        n.forceUpdate();
      }
    };

    e.__u++ || e.setState({
      u: e.__b = e.__v.__k[0]
    }), n.then(u, u);
  }, U.prototype.render = function (n, t) {
    return this.__b && (this.__v.__k[0] = N(this.__b), this.__b = null), [h$1(m$1, null, t.u ? null : n.children), t.u && n.fallback];
  };

  var P = function P(n, t, e) {
    if (++e[1] === e[0] && n.l["delete"](t), n.props.revealOrder && ("t" !== n.props.revealOrder[0] || !n.l.size)) for (e = n.i; e;) {
      for (; e.length > 3;) {
        e.pop()();
      }

      if (e[1] < e[0]) break;
      n.i = e = e[2];
    }
  };

  (O.prototype = new m$1()).u = function (n) {
    var t = this,
        e = M(t.__v),
        r = t.l.get(n);
    return r[0]++, function (o) {
      var u = function u() {
        t.props.revealOrder ? (r.push(o), P(t, n, r)) : o();
      };

      e ? e(u) : u();
    };
  }, O.prototype.render = function (n) {
    this.i = null, this.l = new Map();
    var t = x$1(n.children);
    n.revealOrder && "b" === n.revealOrder[0] && t.reverse();

    for (var e = t.length; e--;) {
      this.l.set(t[e], this.i = [1, 0, this.i]);
    }

    return n.children;
  }, O.prototype.componentDidUpdate = O.prototype.componentDidMount = function () {
    var n = this;
    n.l.forEach(function (t, e) {
      P(n, e, t);
    });
  };

  var W = function () {
    function n() {}

    var t = n.prototype;
    return t.getChildContext = function () {
      return this.props.context;
    }, t.render = function (n) {
      return n.children;
    }, n;
  }();

  function j(n) {
    var t = this,
        e = n.container,
        r = h$1(W, {
      context: t.context
    }, n.vnode);
    return t.s && t.s !== e && (t.v.parentNode && t.s.removeChild(t.v), D$1(t.h), t.p = !1), n.vnode ? t.p ? (e.__k = t.__k, H$1(r, e), t.__k = e.__k) : (t.v = document.createTextNode(""), I$1("", e), e.appendChild(t.v), t.p = !0, t.s = e, H$1(r, e, t.v), t.__k = t.v.__k) : t.p && (t.v.parentNode && t.s.removeChild(t.v), D$1(t.h)), t.h = r, t.componentWillUnmount = function () {
      t.v.parentNode && t.s.removeChild(t.v), D$1(t.h);
    }, null;
  }

  function z(n, t) {
    return h$1(j, {
      vnode: n,
      container: t
    });
  }

  var D = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
  m$1.prototype.isReactComponent = {};
  var H = "undefined" != typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103;

  function T(n, t, e) {
    if (null == t.__k) for (; t.firstChild;) {
      t.removeChild(t.firstChild);
    }
    return H$1(n, t), "function" == typeof e && e(), n ? n.__c : null;
  }

  function V(n, t, e) {
    return I$1(n, t), "function" == typeof e && e(), n ? n.__c : null;
  }

  var Z = n.event;

  function I(n, t) {
    n["UNSAFE_" + t] && !n[t] && Object.defineProperty(n, t, {
      configurable: !1,
      get: function get() {
        return this["UNSAFE_" + t];
      },
      set: function set(n) {
        this["UNSAFE_" + t] = n;
      }
    });
  }

  n.event = function (n) {
    Z && (n = Z(n)), n.persist = function () {};
    var t = !1,
        e = !1,
        r = n.stopPropagation;

    n.stopPropagation = function () {
      r.call(n), t = !0;
    };

    var o = n.preventDefault;
    return n.preventDefault = function () {
      o.call(n), e = !0;
    }, n.isPropagationStopped = function () {
      return t;
    }, n.isDefaultPrevented = function () {
      return e;
    }, n.nativeEvent = n;
  };

  var $ = {
    configurable: !0,
    get: function get() {
      return this["class"];
    }
  },
      q = n.vnode;

  n.vnode = function (n) {
    n.$$typeof = H;
    var t = n.type,
        e = n.props;

    if (t) {
      if (e["class"] != e.className && ($.enumerable = "className" in e, null != e.className && (e["class"] = e.className), Object.defineProperty(e, "className", $)), "function" != typeof t) {
        var r, o, u;

        for (u in e.defaultValue && void 0 !== e.value && (e.value || 0 === e.value || (e.value = e.defaultValue), delete e.defaultValue), Array.isArray(e.value) && e.multiple && "select" === t && (x$1(e.children).forEach(function (n) {
          -1 != e.value.indexOf(n.props.value) && (n.props.selected = !0);
        }), delete e.value), e) {
          if (r = D.test(u)) break;
        }

        if (r) for (u in o = n.props = {}, e) {
          o[D.test(u) ? u.replace(/[A-Z0-9]/, "-$&").toLowerCase() : u] = e[u];
        }
      }

      !function (t) {
        var e = n.type,
            r = n.props;

        if (r && "string" == typeof e) {
          var o = {};

          for (var u in r) {
            /^on(Ani|Tra|Tou)/.test(u) && (r[u.toLowerCase()] = r[u], delete r[u]), o[u.toLowerCase()] = u;
          }

          if (o.ondoubleclick && (r.ondblclick = r[o.ondoubleclick], delete r[o.ondoubleclick]), o.onbeforeinput && (r.onbeforeinput = r[o.onbeforeinput], delete r[o.onbeforeinput]), o.onchange && ("textarea" === e || "input" === e.toLowerCase() && !/^fil|che|ra/i.test(r.type))) {
            var i = o.oninput || "oninput";
            r[i] || (r[i] = r[o.onchange], delete r[o.onchange]);
          }
        }
      }(), "function" == typeof t && !t.m && t.prototype && (I(t.prototype, "componentWillMount"), I(t.prototype, "componentWillReceiveProps"), I(t.prototype, "componentWillUpdate"), t.m = !0);
    }

    q && q(n);
  };

  var B = "16.8.0";

  function G(n) {
    return h$1.bind(null, n);
  }

  function J(n) {
    return !!n && n.$$typeof === H;
  }

  function K(n) {
    return J(n) ? L$1.apply(null, arguments) : n;
  }

  function Q(n) {
    return !!n.__k && (H$1(null, n), !0);
  }

  function X(n) {
    return n && (n.base || 1 === n.nodeType && n) || null;
  }

  var Y = function Y(n, t) {
    return n(t);
  };

  var compat_module = {
    useState: m,
    useReducer: p,
    useEffect: l,
    useLayoutEffect: y,
    useRef: d,
    useImperativeHandle: s,
    useMemo: h,
    useCallback: T$1,
    useContext: w$1,
    useDebugValue: A$1,
    version: "16.8.0",
    Children: R,
    render: T,
    hydrate: T,
    unmountComponentAtNode: Q,
    createPortal: z,
    createElement: h$1,
    createContext: M$1,
    createFactory: G,
    cloneElement: K,
    createRef: y$1,
    Fragment: d$1,
    isValidElement: J,
    findDOMNode: X,
    Component: m$1,
    PureComponent: C,
    memo: _,
    forwardRef: S,
    unstable_batchedUpdates: Y,
    Suspense: U,
    SuspenseList: O,
    lazy: L
  };

  var compat_module$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': compat_module,
    version: B,
    Children: R,
    render: T,
    hydrate: V,
    unmountComponentAtNode: Q,
    createPortal: z,
    createFactory: G,
    cloneElement: K,
    isValidElement: J,
    findDOMNode: X,
    PureComponent: C,
    memo: _,
    forwardRef: S,
    unstable_batchedUpdates: Y,
    Suspense: U,
    SuspenseList: O,
    lazy: L,
    createElement: h$1,
    createContext: M$1,
    createRef: y$1,
    Fragment: d$1,
    Component: m$1,
    useState: m,
    useReducer: p,
    useEffect: l,
    useLayoutEffect: y,
    useRef: d,
    useImperativeHandle: s,
    useMemo: h,
    useCallback: T$1,
    useContext: w$1,
    useDebugValue: A$1,
    useErrorBoundary: F$1
  });

  var require$$3 = /*@__PURE__*/getAugmentedNamespace(compat_module$1);

  function _interopDefault$1(ex) {
    return ex && _typeof$1(ex) === 'object' && 'default' in ex ? ex['default'] : ex;
  }

  var browserUtils = require$$0;

  var QRCode = _interopDefault$1(browser);

  var copy = _interopDefault$1(copyToClipboard);

  var React = require$$3;

  function open(uri) {
    QRCode.toString(uri, {
      type: "terminal"
    }).then(console.log);
  }

  var WALLETCONNECT_STYLE_SHEET = ":root {\n  --animation-duration: 300ms;\n}\n\n@keyframes fadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes fadeOut {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.animated {\n  animation-duration: var(--animation-duration);\n  animation-fill-mode: both;\n}\n\n.fadeIn {\n  animation-name: fadeIn;\n}\n\n.fadeOut {\n  animation-name: fadeOut;\n}\n\n#walletconnect-wrapper {\n  -webkit-user-select: none;\n  align-items: center;\n  display: flex;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  pointer-events: none;\n  position: fixed;\n  top: 0;\n  user-select: none;\n  width: 100%;\n  z-index: 99999999999999;\n}\n\n.walletconnect-modal__headerLogo {\n  height: 21px;\n}\n\n.walletconnect-modal__header p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n  align-items: flex-start;\n  display: flex;\n  flex: 1;\n  margin-left: 5px;\n}\n\n.walletconnect-modal__close__wrapper {\n  position: absolute;\n  top: 0px;\n  right: 0px;\n  z-index: 10000;\n  background: white;\n  border-radius: 26px;\n  padding: 6px;\n  box-sizing: border-box;\n  width: 26px;\n  height: 26px;\n  cursor: pointer;\n}\n\n.walletconnect-modal__close__icon {\n  position: relative;\n  top: 7px;\n  right: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  transform: rotate(45deg);\n}\n\n.walletconnect-modal__close__line1 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n}\n\n.walletconnect-modal__close__line2 {\n  position: absolute;\n  width: 100%;\n  border: 1px solid rgb(48, 52, 59);\n  transform: rotate(90deg);\n}\n\n.walletconnect-qrcode__base {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  background: rgba(37, 41, 46, 0.95);\n  height: 100%;\n  left: 0;\n  pointer-events: auto;\n  position: fixed;\n  top: 0;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  width: 100%;\n  will-change: opacity;\n  padding: 40px;\n  box-sizing: border-box;\n}\n\n.walletconnect-qrcode__text {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 10px 0 20px 0;\n  text-align: center;\n  width: 100%;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-qrcode__text {\n    font-size: 4vw;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-qrcode__text {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-qrcode__image {\n  width: calc(100% - 30px);\n  box-sizing: border-box;\n  cursor: none;\n  margin: 0 auto;\n}\n\n.walletconnect-qrcode__notification {\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  font-size: 16px;\n  padding: 16px 20px;\n  border-radius: 16px;\n  text-align: center;\n  transition: all 0.1s ease-in-out;\n  background: white;\n  color: black;\n  margin-bottom: -60px;\n  opacity: 0;\n}\n\n.walletconnect-qrcode__notification.notification__show {\n  opacity: 1;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__header {\n    height: 130px;\n  }\n  .walletconnect-modal__base {\n    overflow: auto;\n  }\n}\n\n@media only screen and (min-device-width: 415px) and (max-width: 768px) {\n  #content {\n    max-width: 768px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 375px) and (max-width: 415px) {\n  #content {\n    max-width: 414px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (min-width: 320px) and (max-width: 375px) {\n  #content {\n    max-width: 375px;\n    box-sizing: border-box;\n  }\n}\n\n@media only screen and (max-width: 320px) {\n  #content {\n    max-width: 320px;\n    box-sizing: border-box;\n  }\n}\n\n.walletconnect-modal__base {\n  -webkit-font-smoothing: antialiased;\n  background: #ffffff;\n  border-radius: 24px;\n  box-shadow: 0 10px 50px 5px rgba(0, 0, 0, 0.4);\n  font-family: ui-rounded, \"SF Pro Rounded\", \"SF Pro Text\", medium-content-sans-serif-font,\n    -apple-system, BlinkMacSystemFont, ui-sans-serif, \"Segoe UI\", Roboto, Oxygen, Ubuntu, Cantarell,\n    \"Open Sans\", \"Helvetica Neue\", sans-serif;\n  margin-top: 41px;\n  padding: 24px 24px 22px;\n  pointer-events: auto;\n  position: relative;\n  text-align: center;\n  transition: 0.4s cubic-bezier(0.19, 1, 0.22, 1);\n  will-change: transform;\n  overflow: visible;\n  transform: translateY(-50%);\n  top: 50%;\n  max-width: 500px;\n  margin: auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__base {\n    padding: 24px 12px;\n  }\n}\n\n.walletconnect-modal__base .hidden {\n  transform: translateY(150%);\n  transition: 0.125s cubic-bezier(0.4, 0, 1, 1);\n}\n\n.walletconnect-modal__header {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  left: 0;\n  justify-content: space-between;\n  position: absolute;\n  top: -42px;\n  width: 100%;\n}\n\n.walletconnect-modal__base .wc-logo {\n  align-items: center;\n  display: flex;\n  height: 26px;\n  margin-top: 15px;\n  padding-bottom: 15px;\n  pointer-events: auto;\n}\n\n.walletconnect-modal__base .wc-logo div {\n  background-color: #3399ff;\n  height: 21px;\n  margin-right: 5px;\n  mask-image: url(\"images/wc-logo.svg\") center no-repeat;\n  width: 32px;\n}\n\n.walletconnect-modal__base .wc-logo p {\n  color: #ffffff;\n  font-size: 20px;\n  font-weight: 600;\n  margin: 0;\n}\n\n.walletconnect-modal__base h2 {\n  color: rgba(60, 66, 82, 0.6);\n  font-size: 16px;\n  font-weight: 600;\n  letter-spacing: 0;\n  line-height: 1.1875em;\n  margin: 0 0 19px 0;\n  text-align: center;\n  width: 100%;\n}\n\n.walletconnect-modal__base__row {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  align-items: center;\n  border-radius: 20px;\n  cursor: pointer;\n  display: flex;\n  height: 56px;\n  justify-content: space-between;\n  padding: 0 15px;\n  position: relative;\n  margin: 0px 0px 8px;\n  text-align: left;\n  transition: 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  will-change: transform;\n  text-decoration: none;\n}\n\n.walletconnect-modal__base__row:hover {\n  background: rgba(60, 66, 82, 0.06);\n}\n\n.walletconnect-modal__base__row:active {\n  background: rgba(60, 66, 82, 0.06);\n  transform: scale(0.975);\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n}\n\n.walletconnect-modal__base__row__h3 {\n  color: #25292e;\n  font-size: 20px;\n  font-weight: 700;\n  margin: 0;\n  padding-bottom: 3px;\n}\n\n.walletconnect-modal__base__row__right {\n  align-items: center;\n  display: flex;\n  justify-content: center;\n}\n\n.walletconnect-modal__base__row__right__app-icon {\n  border-radius: 8px;\n  height: 34px;\n  margin: 0 11px 2px 0;\n  width: 34px;\n  background-size: 100%;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-modal__base__row__right__caret {\n  height: 18px;\n  opacity: 0.3;\n  transition: 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);\n  width: 8px;\n  will-change: opacity;\n}\n\n.walletconnect-modal__base__row:hover .caret,\n.walletconnect-modal__base__row:active .caret {\n  opacity: 0.6;\n}\n\n.walletconnect-modal__mobile__toggle {\n  width: 80%;\n  display: flex;\n  margin: 0 auto;\n  position: relative;\n  overflow: hidden;\n  border-radius: 8px;\n  margin-bottom: 18px;\n  background: #d4d5d9;\n}\n\n.walletconnect-modal__single_wallet {\n  display: flex;\n  justify-content: center;\n  margin-top: 7px;\n  margin-bottom: 18px;\n}\n\n.walletconnect-modal__single_wallet a {\n  cursor: pointer;\n  color: rgb(64, 153, 255);\n  font-size: 21px;\n  font-weight: 800;\n  text-decoration: none !important;\n  margin: 0 auto;\n}\n\n.walletconnect-modal__mobile__toggle_selector {\n  width: calc(50% - 8px);\n  background: white;\n  position: absolute;\n  border-radius: 5px;\n  height: calc(100% - 8px);\n  top: 4px;\n  transition: all 0.2s ease-in-out;\n  transform: translate3d(4px, 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle.right__selected .walletconnect-modal__mobile__toggle_selector {\n  transform: translate3d(calc(100% + 12px), 0, 0);\n}\n\n.walletconnect-modal__mobile__toggle a {\n  font-size: 12px;\n  width: 50%;\n  text-align: center;\n  padding: 8px;\n  margin: 0;\n  font-weight: 600;\n  z-index: 1;\n}\n\n.walletconnect-modal__footer {\n  display: flex;\n  justify-content: center;\n  margin-top: 20px;\n}\n\n@media only screen and (max-width: 768px) {\n  .walletconnect-modal__footer {\n    margin-top: 5vw;\n  }\n}\n\n.walletconnect-modal__footer a {\n  cursor: pointer;\n  color: #898d97;\n  font-size: 15px;\n  margin: 0 auto;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-modal__footer a {\n    font-size: 14px;\n  }\n}\n\n.walletconnect-connect__buttons__wrapper {\n  max-height: 44vh;\n}\n\n.walletconnect-connect__buttons__wrapper__android {\n  margin: 50% 0;\n}\n\n.walletconnect-connect__buttons__wrapper__wrap {\n  display: grid;\n  grid-template-columns: repeat(4, 1fr);\n  margin: 10px 0;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__buttons__wrapper__wrap {\n    margin-top: 40px;\n  }\n}\n\n.walletconnect-connect__button {\n  background-color: rgb(64, 153, 255);\n  padding: 12px;\n  border-radius: 8px;\n  text-decoration: none;\n  color: rgb(255, 255, 255);\n  font-weight: 500;\n}\n\n.walletconnect-connect__button__icon_anchor {\n  cursor: pointer;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n  margin: 8px;\n  width: 42px;\n  justify-self: center;\n  flex-direction: column;\n  text-decoration: none !important;\n}\n\n@media only screen and (max-width: 320px) {\n  .walletconnect-connect__button__icon_anchor {\n    margin: 4px;\n  }\n}\n\n.walletconnect-connect__button__icon {\n  border-radius: 10px;\n  height: 42px;\n  margin: 0;\n  width: 42px;\n  background-size: cover !important;\n  box-shadow: 0 4px 12px 0 rgba(37, 41, 46, 0.25);\n}\n\n.walletconnect-connect__button__text {\n  color: #424952;\n  font-size: 2.7vw;\n  text-decoration: none !important;\n  padding: 0;\n  margin-top: 1.8vw;\n  font-weight: 600;\n}\n\n@media only screen and (min-width: 768px) {\n  .walletconnect-connect__button__text {\n    font-size: 16px;\n    margin-top: 12px;\n  }\n}\n\n.walletconnect-search__input {\n  border: none;\n  background: #d4d5d9;\n  border-style: none;\n  padding: 8px 16px;\n  outline: none;\n  font-style: normal;\n  font-stretch: normal;\n  font-size: 16px;\n  font-style: normal;\n  font-stretch: normal;\n  line-height: normal;\n  letter-spacing: normal;\n  text-align: left;\n  border-radius: 8px;\n  width: calc(100% - 16px);\n  margin: 0;\n  margin-bottom: 8px;\n}\n"; // A type of promise-like that resolves synchronously and supports only one observer

  typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator"; // Asynchronously iterate through an object's values


  typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing


  function _catch(body, recover) {
    try {
      var result = body();
    } catch (e) {
      return recover(e);
    }

    if (result && result.then) {
      return result.then(void 0, recover);
    }

    return result;
  } // Asynchronously await a promise and pass the result to a finally continuation


  var WALLETCONNECT_LOGO_SVG_URL = "data:image/svg+xml,%3Csvg height='185' viewBox='0 0 300 185' width='300' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='m61.4385429 36.2562612c48.9112241-47.8881663 128.2119871-47.8881663 177.1232091 0l5.886545 5.7634174c2.445561 2.3944081 2.445561 6.2765112 0 8.6709204l-20.136695 19.715503c-1.222781 1.1972051-3.2053 1.1972051-4.428081 0l-8.100584-7.9311479c-34.121692-33.4079817-89.443886-33.4079817-123.5655788 0l-8.6750562 8.4936051c-1.2227816 1.1972041-3.205301 1.1972041-4.4280806 0l-20.1366949-19.7155031c-2.4455612-2.3944092-2.4455612-6.2765122 0-8.6709204zm218.7677961 40.7737449 17.921697 17.546897c2.445549 2.3943969 2.445563 6.2764769.000031 8.6708899l-80.810171 79.121134c-2.445544 2.394426-6.410582 2.394453-8.85616.000062-.00001-.00001-.000022-.000022-.000032-.000032l-57.354143-56.154572c-.61139-.598602-1.60265-.598602-2.21404 0-.000004.000004-.000007.000008-.000011.000011l-57.3529212 56.154531c-2.4455368 2.394432-6.4105755 2.394472-8.8561612.000087-.0000143-.000014-.0000296-.000028-.0000449-.000044l-80.81241943-79.122185c-2.44556021-2.394408-2.44556021-6.2765115 0-8.6709197l17.92172963-17.5468673c2.4455602-2.3944082 6.4105989-2.3944082 8.8561602 0l57.3549775 56.155357c.6113908.598602 1.602649.598602 2.2140398 0 .0000092-.000009.0000174-.000017.0000265-.000024l57.3521031-56.155333c2.445505-2.3944633 6.410544-2.3945531 8.856161-.0002.000034.0000336.000068.0000673.000101.000101l57.354902 56.155432c.61139.598601 1.60265.598601 2.21404 0l57.353975-56.1543249c2.445561-2.3944092 6.410599-2.3944092 8.85616 0z' fill='%233b99fc'/%3E%3C/svg%3E";
  var WALLETCONNECT_HEADER_TEXT = "WalletConnect";
  var ANIMATION_DURATION = 300;
  var DEFAULT_BUTTON_COLOR = "rgb(64, 153, 255)";
  var WALLETCONNECT_WRAPPER_ID = "walletconnect-wrapper";
  var WALLETCONNECT_STYLE_ID = "walletconnect-style-sheet";
  var WALLETCONNECT_MODAL_ID = "walletconnect-qrcode-modal";
  var WALLETCONNECT_CLOSE_BUTTON_ID = "walletconnect-qrcode-close";
  var WALLETCONNECT_CTA_TEXT_ID = "walletconnect-qrcode-text";
  var WALLETCONNECT_CONNECT_BUTTON_ID = "walletconnect-connect-button";

  function Header(props) {
    return React.createElement("div", {
      className: "walletconnect-modal__header"
    }, React.createElement("img", {
      src: WALLETCONNECT_LOGO_SVG_URL,
      className: "walletconnect-modal__headerLogo"
    }), React.createElement("p", null, WALLETCONNECT_HEADER_TEXT), React.createElement("div", {
      className: "walletconnect-modal__close__wrapper",
      onClick: props.onClose
    }, React.createElement("div", {
      id: WALLETCONNECT_CLOSE_BUTTON_ID,
      className: "walletconnect-modal__close__icon"
    }, React.createElement("div", {
      className: "walletconnect-modal__close__line1"
    }), React.createElement("div", {
      className: "walletconnect-modal__close__line2"
    }))));
  }

  function ConnectButton(props) {
    return React.createElement("a", {
      className: "walletconnect-connect__button",
      href: props.href,
      id: WALLETCONNECT_CONNECT_BUTTON_ID + "-" + props.name,
      onClick: props.onClick,
      rel: "noopener noreferrer",
      style: {
        backgroundColor: props.color
      },
      target: "_blank"
    }, props.name);
  }

  var CARET_SVG_URL = "data:image/svg+xml,%3Csvg fill='none' height='18' viewBox='0 0 8 18' width='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath clip-rule='evenodd' d='m.586301.213898c-.435947.33907-.5144813.967342-.175411 1.403292l4.87831 6.27212c.28087.36111.28087.86677 0 1.22788l-4.878311 6.27211c-.33907.436-.260536 1.0642.175412 1.4033.435949.3391 1.064219.2605 1.403289-.1754l4.87832-6.2721c.84259-1.08336.84259-2.60034 0-3.68367l-4.87832-6.27212c-.33907-.4359474-.96734-.514482-1.403289-.175412z' fill='%233c4252' fill-rule='evenodd'/%3E%3C/svg%3E";

  function WalletButton(props) {
    var color = props.color;
    var href = props.href;
    var name = props.name;
    var logo = props.logo;
    var onClick = props.onClick;
    return React.createElement("a", {
      className: "walletconnect-modal__base__row",
      href: href,
      onClick: onClick,
      rel: "noopener noreferrer",
      target: "_blank"
    }, React.createElement("h3", {
      className: "walletconnect-modal__base__row__h3"
    }, name), React.createElement("div", {
      className: "walletconnect-modal__base__row__right"
    }, React.createElement("div", {
      className: "walletconnect-modal__base__row__right__app-icon",
      style: {
        background: "url('" + logo + "') " + color,
        backgroundSize: "100%"
      }
    }), React.createElement("img", {
      src: CARET_SVG_URL,
      className: "walletconnect-modal__base__row__right__caret"
    })));
  }

  function WalletIcon(props) {
    var color = props.color;
    var href = props.href;
    var name = props.name;
    var logo = props.logo;
    var onClick = props.onClick;
    var fontSize = window.innerWidth < 768 ? (name.length > 8 ? 2.5 : 2.7) + "vw" : "inherit";
    return React.createElement("a", {
      className: "walletconnect-connect__button__icon_anchor",
      href: href,
      onClick: onClick,
      rel: "noopener noreferrer",
      target: "_blank"
    }, React.createElement("div", {
      className: "walletconnect-connect__button__icon",
      style: {
        background: "url('" + logo + "') " + color,
        backgroundSize: "100%"
      }
    }), React.createElement("div", {
      style: {
        fontSize: fontSize
      },
      className: "walletconnect-connect__button__text"
    }, name));
  }

  var GRID_MIN_COUNT = 5;
  var LINKS_PER_PAGE = 12;

  function LinkDisplay(props) {
    var android = browserUtils.isAndroid();
    var ref = React.useState("");
    var input = ref[0];
    var setInput = ref[1];
    var ref$1 = React.useState("");
    var filter = ref$1[0];
    var setFilter = ref$1[1];
    var ref$2 = React.useState(1);
    var page = ref$2[0];
    var setPage = ref$2[1];
    var links = filter ? props.links.filter(function (link) {
      return link.name.toLowerCase().includes(filter.toLowerCase());
    }) : props.links;
    var errorMessage = props.errorMessage;
    var grid = filter || links.length > GRID_MIN_COUNT;
    var pages = Math.ceil(links.length / LINKS_PER_PAGE);
    var range = [(page - 1) * LINKS_PER_PAGE + 1, page * LINKS_PER_PAGE];
    var pageLinks = links.length ? links.filter(function (_, index) {
      return index + 1 >= range[0] && index + 1 <= range[1];
    }) : [];
    var hasPaging = !!(!android && pages > 1);
    var filterTimeout = undefined;

    function handleInput(e) {
      setInput(e.target.value);
      clearTimeout(filterTimeout);

      if (e.target.value) {
        filterTimeout = setTimeout(function () {
          setFilter(e.target.value);
          setPage(1);
        }, 1000);
      } else {
        setInput("");
        setFilter("");
        setPage(1);
      }
    }

    return React.createElement("div", null, React.createElement("p", {
      id: WALLETCONNECT_CTA_TEXT_ID,
      className: "walletconnect-qrcode__text"
    }, android ? props.text.connect_mobile_wallet : props.text.choose_preferred_wallet), !android && React.createElement("input", {
      className: "walletconnect-search__input",
      placeholder: "Search",
      value: input,
      onChange: handleInput
    }), React.createElement("div", {
      className: "walletconnect-connect__buttons__wrapper" + (android ? "__android" : grid && links.length ? "__wrap" : "")
    }, !android ? pageLinks.length ? pageLinks.map(function (entry) {
      var color = entry.color;
      var name = entry.name;
      var shortName = entry.shortName;
      var logo = entry.logo;
      var href = browserUtils.formatIOSMobile(props.uri, entry);
      var handleClickIOS = React.useCallback(function () {
        browserUtils.saveMobileLinkInfo({
          name: name,
          href: href
        });
      }, [pageLinks]);
      return !grid ? React.createElement(WalletButton, {
        color: color,
        href: href,
        name: name,
        logo: logo,
        onClick: handleClickIOS
      }) : React.createElement(WalletIcon, {
        color: color,
        href: href,
        name: shortName || name,
        logo: logo,
        onClick: handleClickIOS
      });
    }) : React.createElement(React.Fragment, null, React.createElement("p", null, errorMessage.length ? props.errorMessage : !!props.links.length && !links.length ? props.text.no_wallets_found : props.text.loading)) : React.createElement(ConnectButton, {
      name: props.text.connect,
      color: DEFAULT_BUTTON_COLOR,
      href: props.uri,
      onClick: React.useCallback(function () {
        browserUtils.saveMobileLinkInfo({
          name: "Unknown",
          href: props.uri
        });
      }, [])
    })), hasPaging && React.createElement("div", {
      className: "walletconnect-modal__footer"
    }, Array(pages).fill(0).map(function (_, index) {
      var pageNumber = index + 1;
      var selected = page === pageNumber;
      return React.createElement("a", {
        style: {
          margin: "auto 10px",
          fontWeight: selected ? "bold" : "normal"
        },
        onClick: function onClick() {
          return setPage(pageNumber);
        }
      }, pageNumber);
    })));
  }

  function Notification(props) {
    var show = !!props.message.trim();
    return React.createElement("div", {
      className: "walletconnect-qrcode__notification" + (show ? " notification__show" : "")
    }, props.message);
  }

  var formatQRCodeImage = function formatQRCodeImage(data) {
    try {
      var result = "";
      return Promise.resolve(QRCode.toString(data, {
        margin: 0,
        type: "svg"
      })).then(function (dataString) {
        if (typeof dataString === "string") {
          result = dataString.replace("<svg", "<svg class=\"walletconnect-qrcode__image\"");
        }

        return result;
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };

  function QRCodeDisplay(props) {
    var ref = React.useState("");
    var notification = ref[0];
    var setNotification = ref[1];
    var ref$1 = React.useState("");
    var svg = ref$1[0];
    var setSvg = ref$1[1];
    React.useEffect(function () {
      try {
        return Promise.resolve(formatQRCodeImage(props.uri)).then(function (_formatQRCodeImage) {
          setSvg(_formatQRCodeImage);
        });
      } catch (e) {
        Promise.reject(e);
      }
    }, []);

    var copyToClipboard = function copyToClipboard() {
      var success = copy(props.uri);

      if (success) {
        setNotification(props.text.copied_to_clipboard);
        setInterval(function () {
          return setNotification("");
        }, 1200);
      } else {
        setNotification("Error");
        setInterval(function () {
          return setNotification("");
        }, 1200);
      }
    };

    return React.createElement("div", null, React.createElement("p", {
      id: WALLETCONNECT_CTA_TEXT_ID,
      className: "walletconnect-qrcode__text"
    }, props.text.scan_qrcode_with_wallet), React.createElement("div", {
      dangerouslySetInnerHTML: {
        __html: svg
      }
    }), React.createElement("div", {
      className: "walletconnect-modal__footer"
    }, React.createElement("a", {
      onClick: copyToClipboard
    }, props.text.copy_to_clipboard)), React.createElement(Notification, {
      message: notification
    }));
  }

  function Modal(props) {
    var android = browserUtils.isAndroid();
    var mobile = browserUtils.isMobile();
    var whitelist = mobile ? props.qrcodeModalOptions && props.qrcodeModalOptions.mobileLinks ? props.qrcodeModalOptions.mobileLinks : undefined : props.qrcodeModalOptions && props.qrcodeModalOptions.desktopLinks ? props.qrcodeModalOptions.desktopLinks : undefined;
    var ref = React.useState(false);
    var loading = ref[0];
    var setLoading = ref[1];
    var ref$1 = React.useState(false);
    var fetched = ref$1[0];
    var setFetched = ref$1[1];
    var ref$2 = React.useState(!mobile);
    var displayQRCode = ref$2[0];
    var setDisplayQRCode = ref$2[1];
    var displayProps = {
      mobile: mobile,
      text: props.text,
      uri: props.uri,
      qrcodeModalOptions: props.qrcodeModalOptions
    };
    var ref$3 = React.useState("");
    var singleLinkHref = ref$3[0];
    var setSingleLinkHref = ref$3[1];
    var ref$4 = React.useState(false);
    var hasSingleLink = ref$4[0];
    var setHasSingleLink = ref$4[1];
    var ref$5 = React.useState([]);
    var links = ref$5[0];
    var setLinks = ref$5[1];
    var ref$6 = React.useState("");
    var errorMessage = ref$6[0];
    var setErrorMessage = ref$6[1];

    var getLinksIfNeeded = function getLinksIfNeeded() {
      if (fetched || loading || whitelist && !whitelist.length || links.length > 0) {
        return;
      }

      React.useEffect(function () {
        var initLinks = function initLinks() {
          try {
            if (android) {
              return Promise.resolve();
            }

            setLoading(true);

            var _temp = _catch(function () {
              var url = props.qrcodeModalOptions && props.qrcodeModalOptions.registryUrl ? props.qrcodeModalOptions.registryUrl : browserUtils.getWalletRegistryUrl();
              return Promise.resolve(fetch(url)).then(function (registryResponse) {
                return Promise.resolve(registryResponse.json()).then(function (_registryResponse$jso) {
                  var registry = _registryResponse$jso.listings;
                  var platform = mobile ? "mobile" : "desktop";

                  var _links = browserUtils.getMobileLinkRegistry(browserUtils.formatMobileRegistry(registry, platform), whitelist);

                  setLoading(false);
                  setFetched(true);
                  setErrorMessage(!_links.length ? props.text.no_supported_wallets : "");
                  setLinks(_links);
                  var hasSingleLink = _links.length === 1;

                  if (hasSingleLink) {
                    setSingleLinkHref(browserUtils.formatIOSMobile(props.uri, _links[0]));
                    setDisplayQRCode(true);
                  }

                  setHasSingleLink(hasSingleLink);
                });
              });
            }, function (e) {
              setLoading(false);
              setFetched(true);
              setErrorMessage(props.text.something_went_wrong);
              console.error(e);
            });

            return Promise.resolve(_temp && _temp.then ? _temp.then(function () {}) : void 0);
          } catch (e) {
            return Promise.reject(e);
          }
        };

        initLinks();
      });
    };

    getLinksIfNeeded();
    var rightSelected = mobile ? displayQRCode : !displayQRCode;
    return React.createElement("div", {
      id: WALLETCONNECT_MODAL_ID,
      className: "walletconnect-qrcode__base animated fadeIn"
    }, React.createElement("div", {
      className: "walletconnect-modal__base"
    }, React.createElement(Header, {
      onClose: props.onClose
    }), hasSingleLink && displayQRCode ? React.createElement("div", {
      className: "walletconnect-modal__single_wallet"
    }, React.createElement("a", {
      onClick: function onClick() {
        return browserUtils.saveMobileLinkInfo({
          name: links[0].name,
          href: singleLinkHref
        });
      },
      href: singleLinkHref,
      rel: "noopener noreferrer",
      target: "_blank"
    }, props.text.connect_with + " " + (hasSingleLink ? links[0].name : "") + " ›")) : android || loading || !loading && links.length ? React.createElement("div", {
      className: "walletconnect-modal__mobile__toggle" + (rightSelected ? " right__selected" : "")
    }, React.createElement("div", {
      className: "walletconnect-modal__mobile__toggle_selector"
    }), mobile ? React.createElement(React.Fragment, null, React.createElement("a", {
      onClick: function onClick() {
        return setDisplayQRCode(false), getLinksIfNeeded();
      }
    }, props.text.mobile), React.createElement("a", {
      onClick: function onClick() {
        return setDisplayQRCode(true);
      }
    }, props.text.qrcode)) : React.createElement(React.Fragment, null, React.createElement("a", {
      onClick: function onClick() {
        return setDisplayQRCode(true);
      }
    }, props.text.qrcode), React.createElement("a", {
      onClick: function onClick() {
        return setDisplayQRCode(false), getLinksIfNeeded();
      }
    }, props.text.desktop))) : null, React.createElement("div", null, displayQRCode || !android && !loading && !links.length ? React.createElement(QRCodeDisplay, Object.assign({}, displayProps)) : React.createElement(LinkDisplay, Object.assign({}, displayProps, {
      links: links,
      errorMessage: errorMessage
    })))));
  }

  var de = {
    choose_preferred_wallet: "Wähle bevorzugte Wallet",
    connect_mobile_wallet: "Verbinde mit Mobile Wallet",
    scan_qrcode_with_wallet: "Scanne den QR-code mit einer WalletConnect kompatiblen Wallet",
    connect: "Verbinden",
    qrcode: "QR-Code",
    mobile: "Mobile",
    desktop: "Desktop",
    copy_to_clipboard: "In die Zwischenablage kopieren",
    copied_to_clipboard: "In die Zwischenablage kopiert!",
    connect_with: "Verbinden mit Hilfe von",
    loading: "Laden...",
    something_went_wrong: "Etwas ist schief gelaufen",
    no_supported_wallets: "Es gibt noch keine unterstützten Wallet",
    no_wallets_found: "keine Wallet gefunden"
  };
  var en = {
    choose_preferred_wallet: "Choose your preferred wallet",
    connect_mobile_wallet: "Connect to Mobile Wallet",
    scan_qrcode_with_wallet: "Scan QR code with a WalletConnect-compatible wallet",
    connect: "Connect",
    qrcode: "QR Code",
    mobile: "Mobile",
    desktop: "Desktop",
    copy_to_clipboard: "Copy to clipboard",
    copied_to_clipboard: "Copied to clipboard!",
    connect_with: "Connect with",
    loading: "Loading...",
    something_went_wrong: "Something went wrong",
    no_supported_wallets: "There are no supported wallets yet",
    no_wallets_found: "No wallets found"
  };
  var es = {
    choose_preferred_wallet: "Elige tu billetera preferida",
    connect_mobile_wallet: "Conectar a billetera móvil",
    scan_qrcode_with_wallet: "Escanea el código QR con una billetera compatible con WalletConnect",
    connect: "Conectar",
    qrcode: "Código QR",
    mobile: "Móvil",
    desktop: "Desktop",
    copy_to_clipboard: "Copiar",
    copied_to_clipboard: "Copiado!",
    connect_with: "Conectar mediante",
    loading: "Cargando...",
    something_went_wrong: "Algo salió mal",
    no_supported_wallets: "Todavía no hay billeteras compatibles",
    no_wallets_found: "No se encontraron billeteras"
  };
  var fr = {
    choose_preferred_wallet: "Choisissez votre portefeuille préféré",
    connect_mobile_wallet: "Se connecter au portefeuille mobile",
    scan_qrcode_with_wallet: "Scannez le QR code avec un portefeuille compatible WalletConnect",
    connect: "Se connecter",
    qrcode: "QR Code",
    mobile: "Mobile",
    desktop: "Desktop",
    copy_to_clipboard: "Copier",
    copied_to_clipboard: "Copié!",
    connect_with: "Connectez-vous à l'aide de",
    loading: "Chargement...",
    something_went_wrong: "Quelque chose a mal tourné",
    no_supported_wallets: "Il n'y a pas encore de portefeuilles pris en charge",
    no_wallets_found: "Aucun portefeuille trouvé"
  };
  var ko = {
    choose_preferred_wallet: "원하는 지갑을 선택하세요",
    connect_mobile_wallet: "모바일 지갑과 연결",
    scan_qrcode_with_wallet: "WalletConnect 지원 지갑에서 QR코드를 스캔하세요",
    connect: "연결",
    qrcode: "QR 코드",
    mobile: "모바일",
    desktop: "데스크탑",
    copy_to_clipboard: "클립보드에 복사",
    copied_to_clipboard: "클립보드에 복사되었습니다!",
    connect_with: "와 연결하다",
    loading: "로드 중...",
    something_went_wrong: "문제가 발생했습니다.",
    no_supported_wallets: "아직 지원되는 지갑이 없습니다",
    no_wallets_found: "지갑을 찾을 수 없습니다"
  };
  var pt = {
    choose_preferred_wallet: "Escolha sua carteira preferida",
    connect_mobile_wallet: "Conectar-se à carteira móvel",
    scan_qrcode_with_wallet: "Ler o código QR com uma carteira compatível com WalletConnect",
    connect: "Conectar",
    qrcode: "Código QR",
    mobile: "Móvel",
    desktop: "Desktop",
    copy_to_clipboard: "Copiar",
    copied_to_clipboard: "Copiado!",
    connect_with: "Ligar por meio de",
    loading: "Carregamento...",
    something_went_wrong: "Algo correu mal",
    no_supported_wallets: "Ainda não há carteiras suportadas",
    no_wallets_found: "Nenhuma carteira encontrada"
  };
  var zh = {
    choose_preferred_wallet: "选择你的钱包",
    connect_mobile_wallet: "连接至移动端钱包",
    scan_qrcode_with_wallet: "使用兼容 WalletConnect 的钱包扫描二维码",
    connect: "连接",
    qrcode: "二维码",
    mobile: "移动",
    desktop: "桌面",
    copy_to_clipboard: "复制到剪贴板",
    copied_to_clipboard: "复制到剪贴板成功！",
    connect_with: "通过以下方式连接",
    loading: "正在加载...",
    something_went_wrong: "出了问题",
    no_supported_wallets: "目前还没有支持的钱包",
    no_wallets_found: "没有找到钱包"
  };
  var fa = {
    choose_preferred_wallet: "کیف پول مورد نظر خود را انتخاب کنید",
    connect_mobile_wallet: "به کیف پول موبایل وصل شوید",
    scan_qrcode_with_wallet: "کد QR را با یک کیف پول سازگار با WalletConnect اسکن کنید",
    connect: "اتصال",
    qrcode: "کد QR",
    mobile: "سیار",
    desktop: "دسکتاپ",
    copy_to_clipboard: "کپی به کلیپ بورد",
    copied_to_clipboard: "در کلیپ بورد کپی شد!",
    connect_with: "ارتباط با",
    loading: "...بارگذاری",
    something_went_wrong: "مشکلی پیش آمد",
    no_supported_wallets: "هنوز هیچ کیف پول پشتیبانی شده ای وجود ندارد",
    no_wallets_found: "هیچ کیف پولی پیدا نشد"
  };
  var languages = {
    de: de,
    en: en,
    es: es,
    fr: fr,
    ko: ko,
    pt: pt,
    zh: zh,
    fa: fa
  };

  function injectStyleSheet() {
    var doc = browserUtils.getDocumentOrThrow();
    var prev = doc.getElementById(WALLETCONNECT_STYLE_ID);

    if (prev) {
      doc.head.removeChild(prev);
    }

    var style = doc.createElement("style");
    style.setAttribute("id", WALLETCONNECT_STYLE_ID);
    style.innerText = WALLETCONNECT_STYLE_SHEET;
    doc.head.appendChild(style);
  }

  function renderWrapper() {
    var doc = browserUtils.getDocumentOrThrow();
    var wrapper = doc.createElement("div");
    wrapper.setAttribute("id", WALLETCONNECT_WRAPPER_ID);
    doc.body.appendChild(wrapper);
    return wrapper;
  }

  function triggerCloseAnimation() {
    var doc = browserUtils.getDocumentOrThrow();
    var modal = doc.getElementById(WALLETCONNECT_MODAL_ID);

    if (modal) {
      modal.className = modal.className.replace("fadeIn", "fadeOut");
      setTimeout(function () {
        var wrapper = doc.getElementById(WALLETCONNECT_WRAPPER_ID);

        if (wrapper) {
          doc.body.removeChild(wrapper);
        }
      }, ANIMATION_DURATION);
    }
  }

  function getWrappedCallback(cb) {
    return function () {
      triggerCloseAnimation();

      if (cb) {
        cb();
      }
    };
  }

  function getText() {
    var lang = browserUtils.getNavigatorOrThrow().language.split("-")[0] || "en";
    return languages[lang] || languages["en"];
  }

  function open$1(uri, cb, qrcodeModalOptions) {
    injectStyleSheet();
    var wrapper = renderWrapper();
    React.render(React.createElement(Modal, {
      text: getText(),
      uri: uri,
      onClose: getWrappedCallback(cb),
      qrcodeModalOptions: qrcodeModalOptions
    }), wrapper);
  }

  function close$1() {
    triggerCloseAnimation();
  }

  var isNode = function isNode() {
    return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
  };

  function open$2(uri, cb, qrcodeModalOptions) {
    console.log(uri);

    if (isNode()) {
      open(uri);
    } else {
      open$1(uri, cb, qrcodeModalOptions);
    }
  }

  function close$2() {
    if (isNode()) ;else {
      close$1();
    }
  }

  var index = {
    open: open$2,
    close: close$2
  };
  var cjs = index;

  var CONFIGURED_NETWORK = null;
  var setConfiguredNetwork = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return config.get("flow.network");

            case 2:
              CONFIGURED_NETWORK = _context.sent;
              invariant$1(CONFIGURED_NETWORK === "mainnet" || CONFIGURED_NETWORK === "testnet", "FCL Configuration value for 'flow.network' is required (testnet || mainnet)");

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function setConfiguredNetwork() {
      return _ref.apply(this, arguments);
    };
  }();

  var makeFlowServicesFromWallets = function makeFlowServicesFromWallets(wallets) {
    return Object.values(wallets).filter(function (w) {
      return w.app_type === "wallet";
    }).map(function (wallet) {
      var _wallet$mobile, _wallet$image_url, _wallet$metadata, _wallet$metadata$colo;

      return {
        f_type: "Service",
        f_vsn: "1.0.0",
        type: "authn",
        method: "WC/RPC",
        uid: (_wallet$mobile = wallet.mobile) === null || _wallet$mobile === void 0 ? void 0 : _wallet$mobile.universal,
        endpoint: "flow_authn",
        optIn: true,
        provider: {
          address: null,
          name: wallet.name,
          icon: (_wallet$image_url = wallet.image_url) === null || _wallet$image_url === void 0 ? void 0 : _wallet$image_url.sm,
          description: wallet.description,
          website: wallet.homepage,
          color: (_wallet$metadata = wallet.metadata) === null || _wallet$metadata === void 0 ? void 0 : (_wallet$metadata$colo = _wallet$metadata.colors) === null || _wallet$metadata$colo === void 0 ? void 0 : _wallet$metadata$colo.primary,
          supportEmail: null
        }
      };
    });
  };

  var fetchFlowWallets = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(projectId) {
      var wcApiWallets;
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.next = 3;
              return fetch("https://explorer-api.walletconnect.com/v3/wallets?projectId=".concat(projectId, "&chains=flow:").concat(CONFIGURED_NETWORK, "&entries=5&page=1")).then(function (res) {
                return res.json();
              });

            case 3:
              wcApiWallets = _context2.sent;

              if (!((wcApiWallets === null || wcApiWallets === void 0 ? void 0 : wcApiWallets.count) > 0)) {
                _context2.next = 6;
                break;
              }

              return _context2.abrupt("return", makeFlowServicesFromWallets(wcApiWallets.listings));

            case 6:
              return _context2.abrupt("return", []);

            case 9:
              _context2.prev = 9;
              _context2.t0 = _context2["catch"](0);
              log({
                title: "".concat(_context2.t0.name, " Error fetching wallets from WalletConnect API"),
                message: _context2.t0.message,
                level: LEVELS.error
              });

            case 12:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, null, [[0, 9]]);
    }));

    return function fetchFlowWallets(_x) {
      return _ref2.apply(this, arguments);
    };
  }();
  function isAndroid() {
    return typeof navigator !== "undefined" && /android/i.test(navigator.userAgent);
  }
  function isSmallIOS() {
    return typeof navigator !== "undefined" && /iPhone|iPod/.test(navigator.userAgent);
  }
  function isLargeIOS() {
    return typeof navigator !== "undefined" && /iPad/.test(navigator.userAgent);
  }
  function isIOS() {
    return isSmallIOS() || isLargeIOS();
  }
  function isMobile() {
    return isAndroid() || isIOS();
  }

  var FLOW_METHODS = {
    FLOW_AUTHN: "flow_authn",
    FLOW_AUTHZ: "flow_authz",
    FLOW_USER_SIGN: "flow_user_sign"
  };
  var REQUEST_TYPES = {
    SESSION_REQUEST: "session_proposal",
    SIGNING_REQUEST: "signing_request"
  };

  var makeServicePlugin = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(client) {
      var opts,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              opts = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
              _context.next = 3;
              return makeWcServices(opts);

            case 3:
              _context.t0 = _context.sent;
              _context.t1 = {
                method: "WC/RPC",
                exec: makeExec(client, opts)
              };
              return _context.abrupt("return", {
                name: "fcl-plugin-service-walletconnect",
                f_type: "ServicePlugin",
                type: "discovery-service",
                services: _context.t0,
                serviceStrategy: _context.t1
              });

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function makeServicePlugin(_x) {
      return _ref.apply(this, arguments);
    };
  }();

  var makeExec = function makeExec(client, _ref2) {
    var wcRequestHook = _ref2.wcRequestHook,
        pairingModalOverride = _ref2.pairingModalOverride;
    return function (_ref3) {
      var service = _ref3.service,
          body = _ref3.body,
          opts = _ref3.opts;
      return new Promise( /*#__PURE__*/function () {
        var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(resolve, reject) {
          var session, pairing, windowRef, method, appLink, pairings, lastKeyIndex, _session, _pairing, _makeSessionData, _makeSessionData2, chainId, addr, address, data, result, validateAppLink, openDeepLink, makeSessionData, onResponse, onClose;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  onClose = function _onClose() {
                    reject("Declined: Externally Halted");
                  };

                  onResponse = function _onResponse(resp) {
                    try {
                      if (_typeof$1(resp) !== "object") return;

                      switch (resp.status) {
                        case "APPROVED":
                          resolve(resp.data);
                          break;

                        case "DECLINED":
                          reject("Declined: ".concat(resp.reason || "No reason supplied"));
                          break;

                        case "REDIRECT":
                          resolve(resp);
                          break;

                        default:
                          reject("Declined: No reason supplied");
                          break;
                      }
                    } catch (error) {
                      log({
                        title: "".concat(error.name, " \"WC/RPC onResponse error\""),
                        message: error.message,
                        level: LEVELS.error
                      });
                      throw error;
                    }
                  };

                  makeSessionData = function _makeSessionData3(session) {
                    var _Object$values$map$fl = Object.values(session.namespaces).map(function (namespace) {
                      return namespace.accounts;
                    }).flat().filter(function (account) {
                      return account.startsWith("flow:");
                    })[0].split(":"),
                        _Object$values$map$fl2 = _slicedToArray(_Object$values$map$fl, 3),
                        namespace = _Object$values$map$fl2[0],
                        reference = _Object$values$map$fl2[1],
                        address = _Object$values$map$fl2[2];

                    var chainId = "".concat(namespace, ":").concat(reference);
                    var addr = address;
                    return [chainId, addr, address];
                  };

                  openDeepLink = function _openDeepLink() {
                    if (windowRef) {
                      if (appLink.startsWith("http") && !isIOS()) {
                        // Workaround for https://github.com/rainbow-me/rainbowkit/issues/524.
                        // Using 'window.open' causes issues on iOS in non-Safari browsers and
                        // WebViews where a blank tab is left behind after connecting.
                        // This is especially bad in some WebView scenarios (e.g. following a
                        // link from Twitter) where the user doesn't have any mechanism for
                        // closing the blank tab.
                        // For whatever reason, links with a target of "_blank" don't suffer
                        // from this problem, and programmatically clicking a detached link
                        // element with the same attributes also avoids the issue.
                        var link = document.createElement("a");
                        link.href = appLink;
                        link.target = "_blank";
                        link.rel = "noreferrer noopener";
                        link.click();
                      } else {
                        windowRef.location.href = appLink;
                      }
                    } else {
                      log({
                        title: "Problem opening deep link in new window",
                        message: "Window failed to open (was it blocked by the browser?)",
                        level: LEVELS.warn
                      });
                    }
                  };

                  validateAppLink = function _validateAppLink(_ref5) {
                    var uid = _ref5.uid;

                    if (!(uid && /^(ftp|http|https):\/\/[^ "]+$/.test(uid))) {
                      log({
                        title: "WalletConnect Service Warning",
                        message: "service.uid should be a valid universal link url. Found: ".concat(uid),
                        level: LEVELS.warn
                      });
                    }

                    return uid;
                  };

                  invariant$1(client, "WalletConnect is not initialized");
                  method = service.endpoint;
                  appLink = validateAppLink(service);
                  pairings = client.pairing.getAll({
                    active: true
                  });

                  if (pairings.length > 0) {
                    pairing = pairings === null || pairings === void 0 ? void 0 : pairings.find(function (p) {
                      var _p$peerMetadata;

                      return ((_p$peerMetadata = p.peerMetadata) === null || _p$peerMetadata === void 0 ? void 0 : _p$peerMetadata.url) === service.uid;
                    });
                  }

                  if (client.session.length > 0) {
                    lastKeyIndex = client.session.keys.length - 1;
                    session = client.session.get(client.session.keys.at(lastKeyIndex));
                  }

                  if (isMobile()) {
                    if (opts.windowRef) {
                      windowRef = opts.windowRef;
                    } else {
                      windowRef = window.open("", "_blank");
                    }
                  }

                  if (!(session == null)) {
                    _context2.next = 16;
                    break;
                  }

                  _context2.next = 15;
                  return connectWc({
                    service: service,
                    onClose: onClose,
                    appLink: appLink,
                    windowRef: windowRef,
                    client: client,
                    method: method,
                    pairing: pairing,
                    wcRequestHook: wcRequestHook,
                    pairingModalOverride: pairingModalOverride
                  });

                case 15:
                  session = _context2.sent;

                case 16:
                  if (wcRequestHook && wcRequestHook instanceof Function) {
                    wcRequestHook({
                      type: REQUEST_TYPES.SIGNING_REQUEST,
                      method: method,
                      service: service,
                      session: (_session = session) !== null && _session !== void 0 ? _session : null,
                      pairing: (_pairing = pairing) !== null && _pairing !== void 0 ? _pairing : null,
                      uri: null
                    });
                  }

                  if (isMobile() && method !== FLOW_METHODS.FLOW_AUTHN) {
                    openDeepLink();
                  }

                  _makeSessionData = makeSessionData(session), _makeSessionData2 = _slicedToArray(_makeSessionData, 3), chainId = _makeSessionData2[0], addr = _makeSessionData2[1], address = _makeSessionData2[2];
                  data = JSON.stringify(_objectSpread2(_objectSpread2({}, body), {}, {
                    addr: addr,
                    address: address
                  }));
                  _context2.prev = 20;
                  _context2.next = 23;
                  return client.request({
                    topic: session.topic,
                    chainId: chainId,
                    request: {
                      method: method,
                      params: [data]
                    }
                  });

                case 23:
                  result = _context2.sent;
                  onResponse(result);
                  _context2.next = 31;
                  break;

                case 27:
                  _context2.prev = 27;
                  _context2.t0 = _context2["catch"](20);
                  log({
                    title: "".concat(_context2.t0.name, " Error on WalletConnect client ").concat(method, " request"),
                    message: _context2.t0.message,
                    level: LEVELS.error
                  });
                  reject("Declined: Externally Halted");

                case 31:
                  _context2.prev = 31;

                  if (windowRef && !windowRef.closed) {
                    windowRef.close();
                  }

                  return _context2.finish(31);

                case 34:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[20, 27, 31, 34]]);
        }));

        return function (_x2, _x3) {
          return _ref4.apply(this, arguments);
        };
      }());
    };
  };

  function connectWc(_x4) {
    return _connectWc.apply(this, arguments);
  }

  function _connectWc() {
    _connectWc = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3(_ref6) {
      var service, onClose, appLink, windowRef, client, method, pairing, wcRequestHook, pairingModalOverride, requiredNamespaces, _yield$client$connect, uri, approval, _uri, queryString, url, session;

      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              service = _ref6.service, onClose = _ref6.onClose, appLink = _ref6.appLink, windowRef = _ref6.windowRef, client = _ref6.client, method = _ref6.method, pairing = _ref6.pairing, wcRequestHook = _ref6.wcRequestHook, pairingModalOverride = _ref6.pairingModalOverride;
              requiredNamespaces = {
                flow: {
                  methods: [FLOW_METHODS.FLOW_AUTHN, FLOW_METHODS.FLOW_AUTHZ, FLOW_METHODS.FLOW_USER_SIGN],
                  chains: ["flow:".concat(CONFIGURED_NETWORK)],
                  events: ["chainChanged", "accountsChanged"]
                }
              };
              _context3.prev = 2;
              _context3.next = 5;
              return client.connect({
                pairingTopic: pairing === null || pairing === void 0 ? void 0 : pairing.topic,
                requiredNamespaces: requiredNamespaces
              });

            case 5:
              _yield$client$connect = _context3.sent;
              uri = _yield$client$connect.uri;
              approval = _yield$client$connect.approval;
              _uri = uri;

              if (wcRequestHook && wcRequestHook instanceof Function) {
                wcRequestHook({
                  type: REQUEST_TYPES.SESSION_REQUEST,
                  method: method,
                  service: service,
                  session: session !== null && session !== void 0 ? session : null,
                  pairing: pairing !== null && pairing !== void 0 ? pairing : null,
                  uri: uri !== null && uri !== void 0 ? uri : null
                });
              }

              if (!pairing) {
                invariant$1(uri, "Cannot establish connection, WalletConnect URI is undefined");
              }

              if (isMobile()) {
                queryString = new URLSearchParams({
                  uri: uri
                }).toString();
                url = pairing == null ? appLink + "?" + queryString : appLink;
                windowRef.location.href = url;
              } else if (!pairing) {
                if (!pairingModalOverride) {
                  cjs.open(uri, function () {
                    onClose();
                  });
                } else {
                  pairingModalOverride(uri, onClose);
                }
              }

              _context3.next = 14;
              return approval();

            case 14:
              session = _context3.sent;
              return _context3.abrupt("return", session);

            case 18:
              _context3.prev = 18;
              _context3.t0 = _context3["catch"](2);
              log({
                title: "".concat(_context3.t0.name, " Error establishing WalletConnect session"),
                message: "\n        ".concat(_context3.t0.message, "\n        uri: ").concat(_uri, "\n      "),
                level: LEVELS.error
              });
              onClose();
              throw _context3.t0;

            case 23:
              _context3.prev = 23;

              if (windowRef && !windowRef.closed) {
                windowRef.close();
              }

              cjs.close();
              return _context3.finish(23);

            case 27:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[2, 18, 23, 27]]);
    }));
    return _connectWc.apply(this, arguments);
  }

  var makeBaseWalletConnectService = function makeBaseWalletConnectService(includeBaseWC) {
    return {
      f_type: "Service",
      f_vsn: "1.0.0",
      type: "authn",
      method: "WC/RPC",
      uid: "https://walletconnect.com",
      endpoint: "flow_authn",
      optIn: !includeBaseWC,
      provider: {
        address: null,
        name: "WalletConnect",
        icon: "https://avatars.githubusercontent.com/u/37784886",
        description: "WalletConnect Base Service",
        website: "https://walletconnect.com",
        color: null,
        supportEmail: null
      }
    };
  };

  function makeWcServices(_x5) {
    return _makeWcServices.apply(this, arguments);
  }

  function _makeWcServices() {
    _makeWcServices = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4(_ref7) {
      var _yield$fetchFlowWalle;

      var projectId, includeBaseWC, wallets, wcBaseService, flowWcWalletServices, injectedWalletServices;
      return regenerator.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              projectId = _ref7.projectId, includeBaseWC = _ref7.includeBaseWC, wallets = _ref7.wallets;
              wcBaseService = makeBaseWalletConnectService(includeBaseWC);
              _context4.next = 4;
              return fetchFlowWallets(projectId);

            case 4:
              _context4.t1 = _yield$fetchFlowWalle = _context4.sent;
              _context4.t0 = _context4.t1 !== null;

              if (!_context4.t0) {
                _context4.next = 8;
                break;
              }

              _context4.t0 = _yield$fetchFlowWalle !== void 0;

            case 8:
              if (!_context4.t0) {
                _context4.next = 12;
                break;
              }

              _context4.t2 = _yield$fetchFlowWalle;
              _context4.next = 13;
              break;

            case 12:
              _context4.t2 = [];

            case 13:
              flowWcWalletServices = _context4.t2;
              injectedWalletServices = CONFIGURED_NETWORK === "testnet" ? wallets : [];
              return _context4.abrupt("return", [wcBaseService].concat(_toConsumableArray(flowWcWalletServices), _toConsumableArray(injectedWalletServices)));

            case 16:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _makeWcServices.apply(this, arguments);
  }

  var DEFAULT_RELAY_URL = "wss://relay.walletconnect.com";
  var DEFAULT_LOGGER = "debug";
  var client = null;

  var initClient = /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(_ref) {
      var projectId, metadata;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              projectId = _ref.projectId, metadata = _ref.metadata;
              invariant$1(projectId != null, "FCL Wallet Connect Error: WalletConnect projectId is required");
              _context.prev = 2;
              _context.next = 5;
              return z$2.init({
                logger: DEFAULT_LOGGER,
                relayUrl: DEFAULT_RELAY_URL,
                projectId: projectId,
                metadata: metadata
              });

            case 5:
              client = _context.sent;
              return _context.abrupt("return", client);

            case 9:
              _context.prev = 9;
              _context.t0 = _context["catch"](2);
              log({
                title: "".concat(_context.t0.name, " fcl-wc Init Client"),
                message: _context.t0.message,
                level: LEVELS.error
              });
              throw _context.t0;

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[2, 9]]);
    }));

    return function initClient(_x) {
      return _ref2.apply(this, arguments);
    };
  }();

  var init = /*#__PURE__*/function () {
    var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      var _client2;

      var _ref4,
          projectId,
          metadata,
          _ref4$includeBaseWC,
          includeBaseWC,
          _ref4$wcRequestHook,
          wcRequestHook,
          _ref4$pairingModalOve,
          pairingModalOverride,
          _ref4$wallets,
          wallets,
          _client,
          FclWcServicePlugin,
          _args2 = arguments;

      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _ref4 = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {}, projectId = _ref4.projectId, metadata = _ref4.metadata, _ref4$includeBaseWC = _ref4.includeBaseWC, includeBaseWC = _ref4$includeBaseWC === void 0 ? false : _ref4$includeBaseWC, _ref4$wcRequestHook = _ref4.wcRequestHook, wcRequestHook = _ref4$wcRequestHook === void 0 ? null : _ref4$wcRequestHook, _ref4$pairingModalOve = _ref4.pairingModalOverride, pairingModalOverride = _ref4$pairingModalOve === void 0 ? null : _ref4$pairingModalOve, _ref4$wallets = _ref4.wallets, wallets = _ref4$wallets === void 0 ? [] : _ref4$wallets;
              _context2.next = 3;
              return setConfiguredNetwork();

            case 3:
              if (!((_client2 = client) !== null && _client2 !== void 0)) {
                _context2.next = 7;
                break;
              }

              _context2.t0 = _client2;
              _context2.next = 10;
              break;

            case 7:
              _context2.next = 9;
              return initClient({
                projectId: projectId,
                metadata: metadata
              });

            case 9:
              _context2.t0 = _context2.sent;

            case 10:
              _client = _context2.t0;
              _context2.next = 13;
              return makeServicePlugin(_client, {
                projectId: projectId,
                includeBaseWC: includeBaseWC,
                wcRequestHook: wcRequestHook,
                pairingModalOverride: pairingModalOverride,
                wallets: wallets
              });

            case 13:
              FclWcServicePlugin = _context2.sent;
              discovery.authn.update();
              return _context2.abrupt("return", {
                FclWcServicePlugin: FclWcServicePlugin,
                client: client
              });

            case 16:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function init() {
      return _ref3.apply(this, arguments);
    };
  }();

  exports.getSdkError = N$2;
  exports.init = init;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=util-logger.umd.js.map
